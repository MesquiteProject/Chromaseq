/* Mesquite Chromaseq source code.  Copyright 2005-2011 David Maddison and Wayne Maddison.Version 1.0   December 2011Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.lib; import java.awt.*;import mesquite.lib.*;import mesquite.lib.ui.ColorTheme;import mesquite.lib.ui.MesquitePanel;import mesquite.categ.lib.*;public abstract class SequencePanel extends MesquitePanel  {	//	Chromatogram chromData;	protected int centerBase = 0;	public ContigDisplay window;	protected SequenceCanvas canvas;	protected MesquiteSequence sequence;	protected int width = 0;	protected int height = 0;	protected boolean showReadReadConflict = true;	protected boolean showSourceIsLowerQuality = false;	boolean scrollToTouched = false;	protected int contigID;	public SequencePanel(ContigDisplay window, MesquiteSequence sequence, int contigID) {		super();		this.window = window;		this.contigID = contigID;		this.sequence = sequence;		canvas = makeCanvas();		this.setLayout(null);		canvas.setBounds(0,0,getBounds().width, getBounds().height);		this.add("Center",canvas);		canvas.setVisible(true);		setBackground(ColorTheme.getContentBackground());	}		/*.................................................................................................................*/	public int getLength() {		if (sequence==null)			return 0;		return sequence.getLength();	}	/*.................................................................................................................*/	protected abstract SequenceCanvas makeCanvas();	/*.................................................................................................................*/	public SequenceCanvas getCanvas(){		return canvas;	}	/*.................................................................................................................*/	public boolean oneSelected(){		if (canvas==null)			return false;		return (canvas.oneSelected()>=0);	}	/*.................................................................................................................*/	public void setShowReadReadConflict(boolean showReadReadConflict) {		this.showReadReadConflict = showReadReadConflict;	}	/*.................................................................................................................*/	public boolean getShowReadReadConflict() {		return showReadReadConflict;	}	/*.................................................................................................................*/	public void setShowLowerQualSourceConflictsWithHigherQualRead(boolean showSourceIsLowerQuality) {		this.showSourceIsLowerQuality = showSourceIsLowerQuality;	}	/*.................................................................................................................*/	public boolean getShowLowerQualSourceConflictsWithHigherQualRead() {		return showSourceIsLowerQuality;	}	/*.................................................................................................................*/	public void setScrollToTouched(boolean scrollToTouched) {		this.scrollToTouched = scrollToTouched;	}	/*.................................................................................................................*/	public boolean getScrollToTouched() {		return scrollToTouched;	}	public  void setBounds(int x, int y, int width, int height) {		super.setBounds(x,y,width,height);		canvas.setBounds(0,0,getBounds().width, getBounds().height);	}/*--------------------------------------*/	public String getSequenceString(){		return sequence.getSequence();	}	/*--------------------------------------*/	public MesquiteSequence getSequence(){		return sequence;	}		public void setBackground(Color color){		super.setBackground(color);		if (canvas != null)			canvas.setBackground(color);	}	/*.................................................................................................................*/	public void setColorByQuality(boolean colorByQuality) {		if (canvas!=null)			canvas.setColorByQuality(colorByQuality);	}	boolean listen = true;   	 /*--------------------------------------*/	//uses index in consensus	public boolean setSelectedUniversalBase(int i, boolean sel, boolean repaint){		if (!listen)			return false;		return canvas.setSelectedUniversalBase(i, sel, repaint);	}//	uses index in consensus	public boolean getSelectedConsensus(int i){		return canvas.getSelectedConsensus(i);	}	public void deselectAll(){		canvas.deselectAll();	}	public void exportSelectUniversalBase(int i){		listen = false;		window.selectUniversalBaseInTable(i);				window.setSelectedUniversalBaseInChrom(i, true, true);		listen = true;	}	//this is consensus position	public void exportDeselectUniversalBase(int i){		listen = false;		window.deselectUniversalBaseInTable(i);		window.setSelectedUniversalBaseInChrom(i, false, true);		listen = true;	}	public void exportDeselectAll(){		listen = false;		window.deselectAllInTable();		window.deselectAllInPanels();		listen = true;	}	public void synchChromToTable(boolean syncPosition){		window.synchChromToTable(syncPosition);	}	public void repaintPanel(){		repaint();		canvas.repaint();	}	public void centerPanelAtOverallPosition(int i){		centerBase = i;		canvas.repaint();	}	public ContigDisplay getContigDisplay() {		return window;	}}