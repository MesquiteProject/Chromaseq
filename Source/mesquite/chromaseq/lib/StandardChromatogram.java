/* Mesquite Chromaseq source code.  Copyright 2005-2011 David Maddison and Wayne Maddison.Version 1.0   December 2011Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.lib; import mesquite.lib.IntegerArray;public abstract class StandardChromatogram extends Chromatogram {protected int[] basePosition, A, C, G, T;protected char[] base;protected String baseSequence;public String getTraceValuesString(int x) {	String s = ""+x+"\t";	if (x<0 || x> A.length-1)		s +="0\t";	else		s +=""+A[x]+"\t";	if (x<0 || x> C.length-1)		s +="0\t";	else		s +=""+C[x]+"\t";	if (x<0 || x> G.length-1)		s +="0\t";	else		s +=""+G[x]+"\t";	if (x<0 || x> T.length-1)		s +="0\n";	else		s +=""+T[x]+"\n";	return s;}public String getTraceValuesStringAllRows(boolean withTitle) {	StringBuffer sb= new StringBuffer();	if (withTitle)		sb.append("pos\tA\tC\tG\tT\n");	for (int i=0;i<getTraceLength();i++) {		sb.append(getTraceValuesString(i));	}	return sb.toString();}			public int getATrace(int x) {		if (x<0 || x> A.length-1)			return -1;		else			return A[x];	}		public int getCTrace(int x) {		if (x<0 || x> C.length-1)			return -1;		else			return C[x];	}		public int getGTrace(int x) {		if (x<0 || x> G.length-1)			return -1;		else			return G[x];	}		public int getTTrace(int x) {		if (x<0 || x> T.length-1)			return -1;		else			return T[x];	}	public int[] getATrace() {		return A;	}		public int[] getCTrace() {		return C;	}		public int[] getGTrace() {		return G;	}		public int[] getTTrace() {		return T;	}		public char getBase(int x) {		if (x<0 || x> base.length-1)			return ' ';		else 			return base[x];	}				public int getBasePosition(int x) {		if (x<0 || x> base.length-1)			return -1;		else			return basePosition[x];	}		public String getSequence() {		return baseSequence;	}		public int getBaseNumber() {		return (int) base.length;	}		public void reverseComplement(boolean reverseBasePosition) {				int[] Arc = new int[getTraceLength()];		int[] Crc = new int[getTraceLength()];		int[] Grc = new int[getTraceLength()];		int[] Trc = new int[getTraceLength()];		for (int i=0;i<getTraceLength();i++) {			Arc[i] = T[getTraceLength()-i-1];			Crc[i] = G[getTraceLength()-i-1];			Grc[i] = C[getTraceLength()-i-1];			Trc[i] = A[getTraceLength()-i-1];		}		for (int i=0;i<getTraceLength();i++) {			A[i] = Arc[i];			C[i] = Crc[i];			G[i] = Grc[i];			T[i] = Trc[i];		}				char[] baserc = new char[base.length];				for (int i=0;i<base.length;i++) {			baserc[i] = base[base.length-i-1];		}		for (int i=0;i<base.length;i++) {			if (baserc[i]=='A')				base[i]='T';			else if (baserc[i] == 'C')				base[i]='G';			else if (baserc[i] == 'G')				base[i]='C';			else if (baserc[i] == 'T')				base[i]='A';			else				base[i] = baserc[i];		}		baseSequence = new String(base);		if (reverseBasePosition)			basePosition = IntegerArray.reverse(basePosition);//		report("Reverse complement");	}	}