/* Mesquite Chromaseq source code.  Copyright 2005-2011 David Maddison and Wayne Maddison.Version 1.0   December 2011Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.ExportFastaDNAForGenBank;/*~~  */import java.awt.*;import java.util.Vector;import mesquite.lib.*;import mesquite.lib.characters.*;import mesquite.lib.duties.*;import mesquite.categ.lib.*;import mesquite.chromaseq.lib.ChromaseqUtil;import mesquite.io.lib.*;/* ============  a file interpreter for DNA/RNA  Fasta files ============*/public class ExportFastaDNAForGenBank extends InterpretFasta {	public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed		EmployeeNeed e = registerEmployeeNeed(VoucherInfoCoord.class, "Voucher information is needed for FASTA export for Genbank submissions.",				"This is activated automatically when you choose this exporter.");	}	VoucherInfoCoord voucherInfoTask;	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		voucherInfoTask = (VoucherInfoCoord)hireEmployee(VoucherInfoCoord.class, null);		return voucherInfoTask != null && super.startJob(arguments, condition, hiredByName);	}	/*.................................................................................................................*/	public boolean canImport() {  		return false;  //	}	public boolean canImport(String arguments){		return false;	}	protected int taxonNameLengthLimit() {		return 15;	}	protected String addendum = "";	protected String codeLabel = "DNAVoucher";	protected boolean addVoucherNumberToDescription = false;	protected boolean featureAnnotation = false;	/*.................................................................................................................*/	public boolean getExportOptions(CharacterData data, boolean dataSelected, boolean taxaSelected){		MesquiteInteger buttonPressed = new MesquiteInteger(1);		ExporterDialog exportDialog = new ExporterDialog(this,containerOfModule(), "Export FASTA for GenBank Options", buttonPressed);		exportDialog.appendToHelpString("Choose the options for exporting the matrix as a FASTA file prepared for processing by NCBI's Sequin.");		exportDialog.appendToHelpString("<br><br><b>SeqID Suffix</b>: this will be added to each taxon name to form the unique SeqID.");		exportDialog.appendToHelpString("<br><b>Description of gene fragment</b>: this will be added to each sequence's DEFINITION.");		exportDialog.appendToHelpString("<br><b>Text before OTU (Specimen) ID Code in DEFINITION</b>: this will be inserted between the organism name and the OTU (Specimen) ID Code in the DEFINITION.");		exportDialog.appendToHelpString("<br><b>Features Annotation Tables</b>: A table will be written for each sequence (see Genbank submission instructions).  Group name will become Feature's Product name.  Assumes first site in sequence in group will be representative; if has codon position, whole group will be considered CDs.");		String matrixName = "";		if (data!=null){			matrixName = data.getName();			exportDialog.addLabel("(Matrix: " + matrixName+ ")",Label.CENTER);		}		SingleLineTextField uniqueSuffixField = exportDialog.addTextField("SeqID Suffix", matrixName, 20);		TextArea fsText =null;		exportDialog.addLabel("Description of gene fragment:",Label.LEFT);		fsText =exportDialog.addTextAreaSmallFont(addendum,4);		Checkbox addVoucherNumberBox = exportDialog.addCheckBox("add OTU (Specimen) ID Code to DEFINITION", addVoucherNumberToDescription);		SingleLineTextField codeLabelField = exportDialog.addTextField("Text before OTU (Specimen) ID Code in DEFINITION", codeLabel, 20);		Checkbox includeGapsCheckBox = exportDialog.addCheckBox("include gaps", includeGaps);				//added WPM may 2012		Checkbox featureAnnotationCheckBox = exportDialog.addCheckBox("if gaps NOT included, save Genbank Features Annotation tables? \n(requires characters partitioned into groups)", featureAnnotation);		exportDialog.completeAndShowDialog(dataSelected, taxaSelected);		addendum = fsText.getText();		codeLabel = codeLabelField.getText();		uniqueSuffix = uniqueSuffixField.getText();		addVoucherNumberToDescription = addVoucherNumberBox.getState();		boolean ok = (exportDialog.query(dataSelected, taxaSelected)==0);		includeGaps = includeGapsCheckBox.getState();		featureAnnotation = featureAnnotationCheckBox.getState();		exportDialog.dispose();		return ok;	}		/*.................................................................................................................*/	public int getPartials(String nameOfPart){ //00 = not partial; 01 = partial end; 10 = partial start; 11 = partial both		MesquiteInteger buttonPressed = new MesquiteInteger(1);		ExtensibleDialog partialDialog = new ExtensibleDialog(containerOfModule(), "Partial?", buttonPressed);		TextArea uniqueSuffixField = partialDialog.addLargeTextLabel("Is the partition \"" + nameOfPart + "\" partial on either end?");		Checkbox start = partialDialog.addCheckBox("5' Partial", false);		Checkbox end = partialDialog.addCheckBox("3' Partial", false);		partialDialog.completeAndShowDialog();		int result = 0;		if (start.getState())			result += 2;		if (end.getState())			result += 1;		partialDialog.dispose();		return result;	}			/*.................................................................................................................*/	public boolean canExportEver() {  		return true;  //	}	/*.................................................................................................................*/	public boolean canExportProject(MesquiteProject project) {  		return project.getNumberCharMatrices(DNAState.class) > 0;  //	}	/*.................................................................................................................*/	public boolean canExportData(Class dataClass) {  		return (dataClass==DNAState.class);	}	/*.................................................................................................................*/	public CharacterData createData(CharactersManager charTask, Taxa taxa) {  		return charTask.newCharacterData(taxa, 0, DNAData.DATATYPENAME);  //	}	protected String getSupplementForTaxon(Taxa taxa, int it){		if (taxa!=null && voucherInfoTask != null) {			String s = " ";			String voucherID = ChromaseqUtil.getStringAssociated(taxa, VoucherInfo.voucherCodeRef, it);			VoucherInfo vi= voucherInfoTask.getVoucherInfo(ChromaseqUtil.getStringAssociated(taxa, VoucherInfo.voucherDBRef, it), voucherID);			if (vi != null) {				String gbs = vi.toGenBankString();				if (StringUtil.blank(gbs)) 					MesquiteMessage.println("Taxon with no Genbank information: " + taxa.getTaxonName(it) + "; OTU (specimen) ID code: " + voucherID);				s += gbs;				if (addVoucherNumberToDescription)					return s + " " + codeLabel + " " + voucherID + " " + addendum;				else					return s + " " + addendum;			}			else				MesquiteMessage.println("Taxon with no Genbank information: " + taxa.getTaxonName(it) + "; OTU (specimen) ID code: " + voucherID);		}		return null; 	}	static int taxonNameLengthLimit = 32;	/*.................................................................................................................*/	protected String getTaxonName(Taxa taxa, int it){		String s = StringUtil.cleanseStringOfFancyChars(taxa.getTaxonName(it),false,true);		String suffix = StringUtil.cleanseStringOfFancyChars(uniqueSuffix,false,true);		if (taxonNameLengthLimit>0) {			String taxnum = MesquiteInteger.toString(it);			int reduction = s.length() + suffix.length() - taxonNameLengthLimit;			if (reduction>0) {				reduction += taxnum.length();				String note = "\nSeqID (\"" + s + suffix + "\") too long; renamed as ";				if (s.length()-reduction <1)					s = taxnum;				else {					s = s.substring(0,4) + "_" + s.substring(5+reduction,s.length())+"_" + taxnum;				}				logln(note + "\"" + s + suffix+"\"");			}		}		return s+suffix;	}	int getSequencePosition(int column, int it, DNAData data){		int count = 0;		for (int ic=0; ic<=column; ic++){			if (!data.isInapplicable(ic, it))				count++;		}		return count;	}	int getCodonPositionOfFirstSiteOfPartition(Listable[] listArray, Object obj, DNAData data, int it){		for (int i=0; i<listArray.length; i++) {			if (listArray[i]==obj && (it<0 || !data.isInapplicable(i,it))) {				int cp = data.getCodonPosition(i);				return cp;			}		}		return MesquiteInteger.unassigned;	}	/*.................................................................................................................*/	Vector getListOfSegments(Listable[] listArray, Object obj, int it, DNAData data, boolean partialStart, boolean partialEnd) {		int continuing = 0;		String s="";		boolean found=false;		Vector v= new Vector();		int correction = 1;		int lastWritten = -1;		for (int i=0; i<listArray.length; i++) {			if (!data.isInapplicable(i, it)){				if (listArray[i]==obj) {					found=true;					if (continuing == 0) {//first instance						if (partialStart)							s += "<";						s += (getSequencePosition(i, it, data)); //START						lastWritten = i;						continuing = 1;					}					else if (continuing == 1) {						s += "\t";						continuing = 2;					}				}				else if (continuing >0) {					if (lastWritten != i-1) {						s += (getSequencePosition(i-1, it, data));						v.addElement(s);						s = "";						lastWritten = i-1;					}					else {						s += "\t" + (getSequencePosition(lastWritten, it, data));						v.addElement(s);						s = "";						lastWritten = -1;					}					continuing = 0;				}			}		}		if (continuing>1){			if (partialEnd)				s += ">";			s +=  (getSequencePosition(listArray.length-1, it, data));			v.addElement(s);			s = "";		}		if (found)			return v;		else			return null;	}	/*.................................................................................................................*/	protected void saveExtraFiles(CharacterData cata){		if (!(cata instanceof DNAData))			return;		DNAData data = (DNAData)cata;		if (featureAnnotation && !includeGaps){			CharactersGroup[] parts =null;			boolean hasCDs = data.someCoding();			boolean hasParts = false;			CharacterPartition characterPartition = (CharacterPartition)data.getCurrentSpecsSet(CharacterPartition.class);			if (characterPartition!=null) {				parts = characterPartition.getGroups();				hasParts = parts!=null;			}			if (!hasParts) {				return;			}			boolean[][] partial = new boolean[2][parts.length];			for (int ip = 0; ip<parts.length; ip++){				int p = getPartials(parts[ip].getName());				if (p == 1)//00 = not partial; 01 = partial end; 10 = partial start; 11 = partial both					partial[1][ip] = true;				else if (p == 2)					partial[0][ip] = true;				else if (p == 3){					partial[0][ip] = true;					partial[1][ip] = true;				}			}			String directory = MesquiteFile.chooseDirectory("Directory to Save Tables with Features Annotations");			//NOTE: Partitions are named by product, e.g. "has 16s, t-RNA and intergene spacer" or "Actin 5C"			//Part = feature.  If first site in part is coding, treated as CDS.  Otherwise, not.			for (int it = 0; it< data.getNumTaxa(); it++){				if ((!writeOnlySelectedTaxa || (data.getTaxa().getSelected(it))) && (!includeOnlyTaxaWithData || taxonHasData(data, it))){					StringBuffer buffer = new StringBuffer();					buffer.append(">Features " + getTaxonName(data.getTaxa(), it) + "\t\t\t\t");					buffer.append("\n");					for (int i=0; i<parts.length; i++) {						Vector v = getListOfSegments((Listable[])characterPartition.getProperties(), parts[i], it, data, partial[0][i], partial[1][i]);						if (v != null){							for (int k = 0; k<v.size(); k++) {								String s = (String)v.elementAt(k);								if (k == 0) {									int cp = getCodonPositionOfFirstSiteOfPartition((Listable[])characterPartition.getProperties(), parts[i], data, -1);									if (cp>=1 && cp<=3)										buffer.append(s + "\t" + "CDS\t\t");									else if (StringUtil.indexOfIgnoreCase(parts[i].getName(), "intron")>=0)										buffer.append(s + "\t" + "intron\t\t");									else 										buffer.append(s + "\t" + "misc_feature\t\t");								}								else									buffer.append(s + "\t\t\t");								buffer.append("\n");							}							buffer.append("\t\t\tproduct\t" + parts[i].getName());							buffer.append("\n");							int cp = getCodonPositionOfFirstSiteOfPartition((Listable[])characterPartition.getProperties(), parts[i], data, it);							if (cp>=1 && cp <=3){								/*Genbank has this strange convention where the codon start is the offset until the next full codon, 								 * but starting counting at 1, so that if the start of the feature is at codon position 1, offset is treated as 1 (not 0!):								 * If first codon position is 2, then start of the next codon is treated as offset 3 								 * If first codon position is 3, then start of the next codon is treated as offset 2								 * Go figure.  I can see using offsets, but then it should be 0 based.								*/								int genbankOffset = 0;								if (cp ==1)									genbankOffset = 1;								else	if (cp == 2) 									genbankOffset = 3;								else	if (cp == 3) 									genbankOffset = 2;								buffer.append("\t\t\tcodon_start\t" + genbankOffset);								buffer.append("\n");							}						}					}					MesquiteFile.putFileContents(directory + MesquiteFile.fileSeparator + (it+1) + "-features_" + getTaxonName(data.getTaxa(), it) + ".txt", buffer.toString(), true);				}			}		}	}	/*.................................................................................................................*/	public CharacterData findDataToExport(MesquiteFile file, String arguments) { 		return getProject().chooseData(containerOfModule(), file, null, DNAState.class, "Select data to export");	}	/*.................................................................................................................*/	public void setFastaState(CharacterData data, int ic, int it, char c) { 		if ((c=='U')||(c=='u')) {			((DNAData)data).setDisplayAsRNA(true);		}		((DNAData)data).setState(ic,it,c);	}	/*.................................................................................................................*/	public  String getUnassignedSymbol(){		return "N";	}	/*.................................................................................................................*/	public String getName() {		return "FASTA (DNA/RNA) for GenBank Deposition";	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Exports FASTA files for GenBank deposition." ;	}}