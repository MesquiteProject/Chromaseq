/* Mesquite chromaseq source code.  Copyright 2005-2007 D. Maddison and W. Maddison.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.ViewChromatograms; import java.awt.*;import mesquite.align.lib.*;import mesquite.chromaseq.lib.*;import mesquite.lib.*;import mesquite.categ.lib.*;class BasicChromatogramPanel extends ChromatogramPanel {	protected BasicChromatogramCanvas chromArea;	int width = 0;	int height = 0;	int top = 0;	static boolean SHOWREADMATRIXCONFLICTDEFAULT = true;	boolean colorByQuality = true;	boolean fadeLowQuality = false;	boolean showFades = true;	boolean fadeNonSourceRead = false;	boolean fadeNonSourceLowerQualityRead = true;	int fadeQualityThreshold = 30;	boolean showReadName = true;	boolean useSequencherColors = true;	boolean showBaseNumberWithinRead = true;	boolean showReadMatrixConflict = SHOWREADMATRIXCONFLICTDEFAULT;	boolean showA = true;	boolean showC = true;	boolean showG = true;	boolean showT = true;	boolean showBaseSource = true;	boolean showCodonPosition = false;	boolean simplerGraphics = true;	int id;	int conflictLevelThreshold = 30;	boolean dimLowQualityConflicts = true;	boolean showMagPanel = false;	PairwiseAligner primerAligner;	String[] primerSequence = null; //primer	String[] primerNames = null; //primer	long[][][][] primerAlignment = null; //primer orientation site whichSequence	int[][][] primerMatch; //primer orientation position	int[][] lastPrimerDraw;  //primer orientation	boolean[][] showPrimer;	int numPrimers;	String[] orientName = new String[] {"", "(C)", " (R)", " (RC)"};	boolean useReadNameforPrimerName = true;	boolean ignorePrimerUsedForRead=true;	boolean showOnlySpecifiedPrimersForEachRead=false;	final static int READ=0;	final static int PRIMER=1;//	boolean showSingleSpecifiedPrimer= true;	public BasicChromatogramPanel(Chromatogram myChrom, ContigDisplay panel, int id, int contigID) {		super();		this.id = id;  // this is the read number		this.contigID = contigID;  //this is the taxon number or other id for contig		this.panel = panel;		addKeyListener(panel);		chromatogram = myChrom;		chromatogram.setWindow(panel);		chromArea = new BasicChromatogramCanvas(this, id);		//this.setLayout(new BorderLayout(0,0));		chromArea.setBounds(0, 0, getWidth(), getHeight());		this.add("Center",chromArea);		if (chromatogram.getRead().getComplemented()) 			setBackground(ColorDistribution.veryVeryLightGray);		else			setBackground(Color.white);	}	/*.................................................................................................................*/	public boolean firstRead(){		return id==0;	}	/*.................................................................................................................*/	private boolean primerOKToShow(long[][] alignment, double permittedMismatch){		int mismatches = 0;		int matches = 0;		for (int i = 0; i<alignment.length; i++){			if (alignment[i][READ] != CategoricalState.inapplicable && alignment[i][PRIMER] != CategoricalState.inapplicable ){				if (!CategoricalState.statesShared(alignment[i][READ] , alignment[i][1]))					mismatches++;				else					matches++;			}		}		return mismatches * 1.0 / (matches + mismatches) <= permittedMismatch;	}	/*.................................................................................................................*/	private boolean primerOKToShowBasedOnEndOfPrimer(long[][] alignment, boolean isReversed){		int mismatches = 0;		int matches = 0;		int primerBases = 0;		if (isReversed) {			for (int i = 0; i<alignment.length; i++){   // count from start				if (alignment[i][PRIMER] != CategoricalState.inapplicable ){					primerBases ++;				}				if (alignment[i][PRIMER] != CategoricalState.inapplicable)					if (!CategoricalState.statesShared(alignment[i][READ] , alignment[i][PRIMER]) )  //mismatch, and the primer has a base here						mismatches++;					else if (alignment[i][READ] != CategoricalState.inapplicable )						matches++;				if (primerBases>=5 && mismatches==0)					return true;				if (primerBases>=7 && mismatches<=1)					return true;				if (primerBases>=10 && mismatches<=2)					return true;				if (primerBases>=14 && mismatches<=3)					return true;			}		}		else {			for (int i = alignment.length-1; i>=0; i--){  // count from end				if (alignment[i][PRIMER] != CategoricalState.inapplicable ){					primerBases++;				}				if (alignment[i][PRIMER] != CategoricalState.inapplicable)					if (!CategoricalState.statesShared(alignment[i][READ] , alignment[i][PRIMER]) )  //mismatch, and the primer has a base here						mismatches++;					else if (alignment[i][READ] != CategoricalState.inapplicable )						matches++;				if (primerBases>=5 && mismatches==0)					return true;				if (primerBases>=7 && mismatches<=1)					return true;				if (primerBases>=10 && mismatches<=2)					return true;				if (primerBases>=14 && mismatches<=3)					return true;			}		}		return false;	}	/*.................................................................................................................*/	public void setUpPrimers(){		Contig contig = panel.getContig();		ListableVector v = new ListableVector();		if (showOnlySpecifiedPrimersForEachRead || panel.getShowSinglePrimerMatch()) {			v.addElement(new Primer(getPrimerToShow()), false);		} 		else {			String s = contig.getRead(0).getPrimerName();			boolean primerNamesStored = ! StringUtil.blank(s);			for (int i = 0; i< contig.getNumReadsToShow(); i++){				if (primerNamesStored)					s = contig.getRead(i).getPrimerName();				else if (useReadNameforPrimerName) {  // we need to parse the chromatogram name					s = contig.getRead(i).getName();					s = StringUtil.getAllButLastItem(s, ".");					s = StringUtil.getLastItem(s, ".");				}				if (!v.nameAlreadyInList(s))					v.addElement(new Primer(s), false);			}		}		numPrimers = v.size();		primerSequence = new String[numPrimers];		primerNames = new String[numPrimers];		primerAlignment = new long[numPrimers][4][][];		primerMatch = new int[numPrimers][4][];		lastPrimerDraw = new int[numPrimers][4];		showPrimer = new boolean[numPrimers][4];		int alphabetLength = 4;		int subs[][] = AlignUtil.getDefaultSubstitutionCosts(alphabetLength);  		primerAligner = new PairwiseAligner (true, subs, 40, 20,  5, 5, alphabetLength);		String[][] primerSequences = panel.getPrimerSequences();		for(int primer = 0; primer < numPrimers; primer++){			primerNames[primer] = v.nameOfElementAt(primer);			setUpPrimer(primer, primerSequences);		}	}	private void setUpPrimer(int primer, String[][] primerSequences){		boolean doRevPrimer = false;  // search for reverse of primer		boolean doCompPrimer = false;  // search for complement of primer		String title = primerNames[primer];		if (ignorePrimerUsedForRead && title != null && title.equalsIgnoreCase(getPrimerName()))			return;		if (!StringUtil.blank(title)){			if (primerSequences == null)				return;			boolean found = false;			//find primer that this corresponds to			for (int i= 0; i<primerSequences.length; i++){				if (title.equalsIgnoreCase(primerSequences[i][0])){					primerSequence[primer] = primerSequences[i][1];					primerSequence[primer] = DNAData.collapseSymbol(primerSequence[primer], '*');					primerSequence[primer] = DNAData.collapseSymbol(primerSequence[primer], '-');					found = true;					break;				}			}			if (!found)				MesquiteMessage.warnProgrammer("Primer not found in primer list: " + title);		}		if (!StringUtil.blank(primerSequence[primer])){			try {				//getting long[] version of this sequence				String sequenceString = chromatogram.getRead().getSequence();				sequenceString = cleanSequenceString(sequenceString);				boolean verbose = false;				if (verbose) Debugg.println("sequencesString length " + sequenceString.length());							long[] readSequence = DNAData.convertTerminalMissingToGaps(DNAData.sequenceLongsFromString(sequenceString));				if (verbose) Debugg.println("readSequence length " + readSequence.length);							//getting long versions of the primer sequence				long[] asIs = DNAData.sequenceLongsFromString(primerSequence[primer], sequenceString.length());				if (verbose) Debugg.println("asIs length " + asIs.length);							String complement = DNAData.complementString(primerSequence[primer]);				long[] comp=null;				if (doCompPrimer)					comp = DNAData.sequenceLongsFromString(complement, sequenceString.length());				if (verbose) Debugg.println("comp length " + comp.length);							long[] rev =null;				if (doRevPrimer)					rev= DNAData.sequenceLongsFromString(DNAData.reverseString(primerSequence[primer]), sequenceString.length());				long[] revComp = DNAData.sequenceLongsFromString(DNAData.reverseString(complement), sequenceString.length());				if (verbose){					Debugg.println("@@@@@@@@@@@@@@@@@ " + chromatogram.getTitle());					Debugg.println("primer [" + DNAData.sequenceStringFromLongs(asIs) + "]");					if (doCompPrimer)						Debugg.println("comp " + DNAData.sequenceStringFromLongs(comp));					if (doRevPrimer)						Debugg.println("rev " + DNAData.sequenceStringFromLongs(rev));					Debugg.println("revComp " + DNAData.sequenceStringFromLongs(revComp));					Debugg.println("READunalligned [" + DNAData.sequenceStringFromLongs(readSequence, false) + "]");				}				MesquiteNumber scoreAsIs = new MesquiteNumber();				MesquiteNumber scoreComp = new MesquiteNumber();				MesquiteNumber scoreRev = new MesquiteNumber();				MesquiteNumber scoreRevComp = new MesquiteNumber();				MesquiteNumber bestScore;				int chosen = 0;				for (int i = 0; i<4; i++) {					showPrimer[primer][i]=false;					primerAlignment[primer][i] = new long[0][0];				}//				OK, let's first try aligning the primer to the sequence				primerAlignment[primer][0] = primerAligner.alignSequences( readSequence, asIs, true, scoreAsIs);				showPrimer[primer][0] = primerOKToShow(primerAlignment[primer][0], 0.2);				if (!showPrimer[primer][0])					showPrimer[primer][0] = primerOKToShowBasedOnEndOfPrimer(primerAlignment[primer][0], false);				bestScore = scoreAsIs;				int min = (sequenceString.length() - primerSequence[primer].length())*2;				if (verbose) Debugg.println("$$$$$$$$ seq len " + sequenceString.length() + " primer " + primerSequence[primer].length() + " min " + min);				if (verbose) Debugg.println("ASIS &&&&&&&&&&&&&&&&" + scoreAsIs);				if (verbose) Debugg.println("PRIMER " + DNAData.sequenceStringFromLongs(asIs));				if (verbose) printPrimerAlignment(primerAlignment[primer][0]);//				Now let's try aligning the complement of the primer to the sequence				long[][] align = null;				if (doCompPrimer) {					align = primerAligner.alignSequences( readSequence, comp, true, scoreComp);					if (verbose) Debugg.println("comp &&&&&&&&&&&&&&&&" + scoreComp);					if (verbose) Debugg.println("PRIMER " + DNAData.sequenceStringFromLongs(comp));					if (verbose) printPrimerAlignment(align);					primerAlignment[primer][1] = align;					showPrimer[primer][1] = primerOKToShow(align, 0.2);					if (!showPrimer[primer][1])						showPrimer[primer][1] = primerOKToShowBasedOnEndOfPrimer(align, true);					if (scoreComp.isLessThan(bestScore)){						bestScore = scoreComp;						chosen = 1;					}				}//				Aligning the reverse of the primer to the sequence				if (doRevPrimer) {					align = primerAligner.alignSequences( readSequence, rev, true, scoreRev);					if (verbose) Debugg.println("rev &&&&&&&&&&&&&&&&" + scoreRev);					if (verbose) Debugg.println("PRIMER " + DNAData.sequenceStringFromLongs(rev));					if (verbose) printPrimerAlignment(align);					primerAlignment[primer][2] = align;					showPrimer[primer][2] = primerOKToShow(align, 0.2);					if (!showPrimer[primer][2])						showPrimer[primer][2] = primerOKToShowBasedOnEndOfPrimer(align, false);					if (scoreRev.isLessThan(bestScore)){						bestScore = scoreRev;						chosen = 2;					}				}//				Aligning the reverse complement of the primer to the sequence				align = primerAligner.alignSequences( readSequence, revComp, true, scoreRevComp);				if (verbose) Debugg.println("revComp &&&&&&&&&&&&&&&&" + scoreRevComp);				if (verbose) Debugg.println("PRIMER " + DNAData.sequenceStringFromLongs(revComp));				if (verbose) printPrimerAlignment(align);				primerAlignment[primer][3] = align;				showPrimer[primer][3] = primerOKToShow(align, 0.2);				if (!showPrimer[primer][3])					showPrimer[primer][3] = primerOKToShowBasedOnEndOfPrimer(align, true);				if (scoreRevComp.isLessThan(bestScore)){					bestScore = scoreRevComp;					chosen = 3;				}//				Now we are done testing out the alignments				if (!showPrimer[primer][chosen]){					showPrimer[primer][chosen] = primerOKToShow(align, 0.33);					if (!showPrimer[primer][chosen])						for (int i = 0; i<4; i++)							if (showPrimer[primer][i]) {								chosen=i;								break;							}				}				MesquiteMessage.println("Primer (" + title + ") found to align with read " + chromatogram.getTitle() + ": " + primerSequence[primer]);				if (verbose) Debugg.println("CHOSEN == " + chosen);				if (verbose) printPrimerAlignment(primerAlignment[primer][chosen]);				primerMatch[primer] = new int[4][];				for (int orientation = 0; orientation < 4; orientation++) {					primerMatch[primer][orientation] = new int[primerAlignment[primer][orientation].length];					if (verbose) Debugg.println("orient " + orientation + "   lengthA " + primerMatch[primer][orientation].length);				}				for (int k = 0; k<4; k++)					for (int i=0; i< primerMatch[primer][k].length; i++)						primerMatch[primer][k][i] = -1;				if (verbose) System.out.println(">>>>>>>>>>>");				for (int orientation=0; orientation<4; orientation++){					int siteCount = -1;					int primerCount = -1;					boolean foundPrimer = false;					int startOfPrimer = -1;					for (int i=0; i<primerAlignment[primer][orientation].length; i++){						if (primerAlignment[primer][orientation][i][1] != MolecularState.inapplicable) {//primer has something 							primerCount++;							if (!foundPrimer)								startOfPrimer= i;							foundPrimer=true;						}						if (primerAlignment[primer][orientation][i][0] != MolecularState.inapplicable){ //sequence has something							siteCount++;							if (primerAlignment[primer][orientation][i][1]!= MolecularState.inapplicable){ // primer and sequence both have something//								Debugg.println("lengthB " + siteCount);								primerMatch[primer][orientation][siteCount] = i;								if (verbose) System.out.print("-" + siteCount);							}						}					}//					Debugg.println("primer: " + title + ", orientation: " + orientation + "(" + chosen + "), primerCount: " + primerCount + ", siteCount: " + siteCount+ ", startOfPrimer: " + startOfPrimer);//					Debugg.println("            showPrimer[primer][orientation]: " + showPrimer[primer][orientation]);				}				if (verbose) System.out.println("<<<<<<<<<<<<<<<");			}			catch (Exception e){				for (int orientation = 0; orientation<4; orientation++){					primerMatch[primer][orientation] = null;					primerAlignment[primer][orientation] = null;				}				MesquiteMessage.warnProgrammer("Exception thrown in primer alignment");				e.printStackTrace();			}		}	}	int[] primerAlignedSeqToOrigSeq;	private String cleanSequenceString( String seq){		primerAlignedSeqToOrigSeq = new int[seq.length()];		for (int i = 0; i < seq.length(); i++) 			primerAlignedSeqToOrigSeq[i] = -1;		StringBuffer s = new StringBuffer(seq.length());		String badString = "-N?*\r\n\t";		int count = -1;		for (int i = 0; i < seq.length(); i++) {			if (badString.indexOf(seq.charAt(i))<0){				count++;				s.append(seq.charAt(i));				primerAlignedSeqToOrigSeq[i] = count;			}		}		return s.toString();	}	private void printPrimerAlignment(long[][] alignment){		String sP = "";		String sR = "";		for (int i= 0; i<alignment.length; i++){			sP += DNAState.toCharStatic(alignment[i][1]);			sR += DNAState.toCharStatic(alignment[i][0]);		}		Debugg.println("AlignedPRIM " + sP);		Debugg.println("AlignedREAD " + sR);	}	public boolean isShownReversed(){		return panel.isShownReversed();	}	public boolean isShownComplemented(){		return panel.isShownComplemented();	}	public int getWidth() {		if (showMagPanel)			return getBounds().width-100;		else			return getBounds().width;	}	public int getHeight() {		return getBounds().height;	}	//uses index in consensus; this viewer must translate to index in the read	public boolean selectConsensusPositionInChrom(int i, boolean sel, boolean repaint){		if (!listen)			return false;		if (chromArea != null)			return chromArea.setSelectedInChrom(panel.getOverallBaseFromConsensusBase(i), sel, repaint);		return false;	}	public void deselectAllChrom(int overallBase){		panel.deselectAllChrom(overallBase);	}	public void deselectAll(){		chromArea.deselectAll();	}	public void deselectAll(int overallBase){		chromArea.setSelected(overallBase,false);	}	public void synchChromToTable(boolean synchPosition){		panel.synchChromToTable(synchPosition);	}	public void synchTableToChrom(boolean synchPosition){		panel.synchTableToChrom(synchPosition);	}	public void repaintPanel(){		if (chromArea != null ) {			chromArea.repaint();		}	}	public void setMagnification(double mag){		if (chromArea != null ) {			chromArea.setMagnification(mag);		}	}	public void setShadowOffset(int o){		if (chromArea != null ) {			chromArea.setShadowOffset(o);		}	}	public void setShadowReduction(double mag){		if (chromArea != null ) {			chromArea.setShadowReduction(mag);		}	}	public Dimension minimumSize() {		return new Dimension(100,100);	}	/*.................................................................................................................*/	public Read getRead() {		if (chromatogram==null)			return null;		return chromatogram.getRead();	}	/*.................................................................................................................*/	public String getPrimerName() {		Read read = getRead();		if (read==null)			return null;		return read.getPrimerName();	}	/*.................................................................................................................*/	public String getPrimerToShow() {		if (panel.getShowSinglePrimerMatch()) {			return panel.getSinglePrimer();		} 		else {			Read read = getRead();			if (read==null)				return null;			return read.getPrimerToShow();		}	}	/*.................................................................................................................*/	public Contig getContig() {		return panel.getContig();	}	/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		this.fadeQualityThreshold = fadeQualityThreshold;	}	/*.................................................................................................................*/	public int getFadeQualityThreshold() {		return fadeQualityThreshold;	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		this.showBaseNumberWithinRead = showBaseNumberWithinRead;	}	/*.................................................................................................................*/	public boolean getShowBaseNumberWithinRead() {		return showBaseNumberWithinRead;	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		this.showReadName = showReadName;	}	/*.................................................................................................................*/	public boolean getShowReadName() {		return showReadName;	}	/*.................................................................................................................*/	public void setUseSequencherColors(boolean useSequencherColors) {		this.useSequencherColors = useSequencherColors;	}	/*.................................................................................................................*/	public boolean getUseSequencherColors() {		return useSequencherColors;	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean showReadMatrixConflict) {		this.showReadMatrixConflict = showReadMatrixConflict;	}	/*.................................................................................................................*/	public boolean getShowReadMatrixConflict() {		return showReadMatrixConflict;	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		this.fadeNonSourceRead = fadeNonSourceRead;	}	/*.................................................................................................................*/	public boolean getFadeNonSourceRead() {		return fadeNonSourceRead;	}	/*.................................................................................................................*/	public void setFadeNonSourceLowerQualityRead(boolean fadeNonSourceLowerQualityRead) {		this.fadeNonSourceLowerQualityRead = fadeNonSourceLowerQualityRead;	}	/*.................................................................................................................*/	public boolean getFadeNonSourceLowerQualityRead() {		return fadeNonSourceLowerQualityRead;	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		this.fadeLowQuality = fadeLowQuality;	}	/*.................................................................................................................*/	public boolean getShowFades() {		return showFades;	}	/*.................................................................................................................*/	public void setShowFades(boolean showFades) {		this.showFades = showFades;	}	/*.................................................................................................................*/	public boolean getFadeLowQuality() {		return fadeLowQuality;	}	/*.................................................................................................................*/	public  void setDimConflictMarkerThreshold (int conflictLevelThreshold){		this.conflictLevelThreshold = conflictLevelThreshold;	}	/*.................................................................................................................*/	public  int getDimConflictMarkerThreshold (){		return conflictLevelThreshold;	}	/*.................................................................................................................*/	public  void setDimLowQualityConflicts (boolean dimLowQualityConflicts){		this.dimLowQualityConflicts = dimLowQualityConflicts;	}	/*.................................................................................................................*/	public  boolean getDimLowQualityConflicts (){		return dimLowQualityConflicts;	}	/*.................................................................................................................*/	public void setColorByQuality(boolean colorByQuality) {		this.colorByQuality = colorByQuality;	}	/*.................................................................................................................*/	public boolean getColorByQuality() {		return colorByQuality;	}	/*.................................................................................................................*/	public void setShowA(boolean showA) {		this.showA = showA;	}	/*.................................................................................................................*/	public boolean getShowA() {		return showA;	}	/*.................................................................................................................*/	public void setShowC(boolean showC) {		this.showC = showC;	}	/*.................................................................................................................*/	public boolean getShowC() {		return showC;	}	/*.................................................................................................................*/	public void setShowG(boolean showG) {		this.showG = showG;	}	/*.................................................................................................................*/	public boolean getShowG() {		return showG;	}	/*.................................................................................................................*/	public void setShowT(boolean showT) {		this.showT = showT;	}	/*.................................................................................................................*/	public boolean getShowT() {		return showT;	}	/*.................................................................................................................*/	public void setShowCodonPosition(boolean showCodonPosition) {		this.showCodonPosition= showCodonPosition;	}	/*.................................................................................................................*/	public boolean getShowCodonPosition() {		return showCodonPosition;	}	public boolean getShowBaseSource() {		return showBaseSource;	}	public void setShowBaseSource(boolean showBaseSource) {		this.showBaseSource = showBaseSource;	}	public void centerPanelAtOverallPosition(int i){		centerBase = i;		chromArea.repaint();	}	public void setVerticalPosition(int i){				verticalPosition = i;		chromArea.repaint();	}	public boolean getSelected(int overallBase) {		return chromArea.getSelected(overallBase);	}	public  int getTop() {		return top;	}	public  void setTop(int top) {		this.top = top;	}	public  void adjustTop(int adjustment) {		int x = getBounds().x;		int y = this.top-adjustment;		setBounds(x,y,width,height);		//chromArea.repaint();	}	public  void setBounds(int x, int y, int width, int height) {		super.setBounds(x,y,width,height);		this.width = width;		this.height = height;		chromArea.setBounds(0, 0, getWidth(), getHeight());		//chromArea.repaint();	}	public  void setSize( int width, int height) {		super.setSize(width,height);		this.width = width;		this.height = height;		chromArea.setBounds(0, 0, getWidth(), getHeight());		chromArea.repaint();	}}//=======================================================================================class BasicChromatogramCanvas extends ChromatogramCanvas {	BasicChromatogramPanel chromatogramPanel;	boolean blackBackground=false;	boolean simplerGraphics=true;	static final double NONSOURCEDIMFRACTION = 0.2;	static final double NONSOURCELOWERQUALITYDIMFRACTION = 0.15;	/*..........................*/	public BasicChromatogramCanvas(BasicChromatogramPanel parentV, int id) {		super(parentV,  id);		chromatogramPanel = parentV;		addKeyListener(panel);	}	/*...........................................................................*/	public void paint(Graphics g) {			int v = -verticalPosition;		Read read = chromatogram.getRead();		int cheight = getBounds().height;		int shadowHeight = 5;		int labelHeight = 18;		int labelBottom = v+cheight-shadowHeight;		int labelTop = labelBottom-labelHeight+1;		int cwidth = getBounds().width;		double scale = 1.0*maxValue / cheight / magnification;		int halfPeaks = panel.getApproximateNumberOfPeaksVisible()/2;		if (blackBackground)			setBackground(Color.black);		else			setBackground(panel.getBackgroundColor());		reCalcCenterBase();		int centerConsensusBase = centerBase-panel.getContig().getReadExcessAtStart();		int centerReadBase = getReadBaseFromConsensusBase(centerConsensusBase);		int firstReadBase = centerReadBase - halfPeaks;		int lastReadBase = centerReadBase+halfPeaks;		int firstReadLocation = getPhdLocation(read, cwidth, centerReadBase,panel,true) - cwidth/2;		/*David: here a correction is introduced to discover what is actually the first and last read bases visible.  Previously		these bases were calcualted incorrectly if some reads were effectively compressed, and thus drawing didn't go all the way to the edges		A similar problem of compression was affecting findConsensusBaseNumber, hence some of this code is repeated there.		 */		int count = 0;		while (getPhdLocation(read, cwidth, firstReadBase,panel,true)  - firstReadLocation >0 && firstReadLocation>0 && count++<200)			firstReadBase--; //correcting for error in numpeaksvisible for this read		count = 0;		while (getPhdLocation(read, cwidth, lastReadBase,panel,true)  - firstReadLocation <cwidth && count++<200)			lastReadBase++; //correcting for error in numpeaksvisible for this read		firstReadBase--;		lastReadBase++;		int i;		double fadeMax = 0.5;		int offsetForInserted = 0;//		Now to show the read-matrix conflict marker		int firstSel = MesquiteInteger.unassigned;		ColorDistribution.setTransparentGraphics(g);				int cmid = 0;		for (i=firstReadBase-1; i<=lastReadBase+1;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getConsensusBaseFromReadBase(i);				offsetForInserted += panel.getSpaceInsertedBeforeConsensusBase(consensusBase);				int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);				char c = read.getPhdBaseChar(i);				if (chromatogramPanel.getShowReadMatrixConflict()){					consensusBase = getConsensusBaseFromReadBase(i);					char contigBase = panel.getMatrixStateAtConsensusPosition(consensusBase);					if (contigBase != c) {						int quality = read.getPhdBaseQuality(i);						if (chromatogramPanel.getDimLowQualityConflicts()) {							if (quality==0)								continue;							else if (quality>=chromatogramPanel.getDimConflictMarkerThreshold())								g.setColor(ColorDistribution.burlyWood);							else								g.setColor(ColorDistribution.brighter(ColorDistribution.burlyWood, (float)(quality/(1.0*chromatogramPanel.getDimConflictMarkerThreshold()))));						}						else 							g.setColor(ColorDistribution.burlyWood);						int rightLoc = read.getPhdRightBoundary(i,panel,true);						int leftLoc = read.getPhdLeftBoundary(i,panel,true);						fillRect(g, cwidth, leftLoc - firstReadLocation + offsetForInserted, 0, rightLoc-leftLoc, labelTop-1);						g.setColor(Color.gray);					}				}			}		}		ColorDistribution.setOpaqueGraphics(g);		//		=====================  COLOR THE CODON POSITIONS ==============================		offsetForInserted = 0;		if (chromatogramPanel.getShowCodonPosition()) {			ColorDistribution.setTransparentGraphics(g,0.2f);					for (i=firstReadBase; i<=lastReadBase;i++) {				if (i>=0 && i<read.getBasesLength()) {					int consensusBase = getConsensusBaseFromReadBase(i);					offsetForInserted += panel.getSpaceInsertedBeforeConsensusBase(consensusBase);					int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);					int codonPosition = panel.getCodonPositionOfOverallBase(overallBase);					if (codonPosition>0 && codonPosition<4) {						switch (codonPosition) {						case 1: g.setColor(Color.blue); break;						case 2: g.setColor(Color.green); break;						case 3: g.setColor(Color.red); break;						default: g.setColor(Color.white); break;						}						int w = read.getPhdRightBoundary(i,panel,true) - read.getPhdLeftBoundary(i,panel,true);						int hor = read.getPhdLeftBoundary(i, panel,true)- firstReadLocation + offsetForInserted;						fillRect(g, cwidth, hor, 16, w, 26);					}				}			}			ColorDistribution.setOpaqueGraphics(g);				}		offsetForInserted =0;//		Drawing the center line		g.setColor(Color.lightGray);		g.drawLine(cwidth/2,0,cwidth/2,v+cheight);		Color inverseBlackColor = Color.white;//		=====================  DRAWING THE PEAKS ==============================		int peakBottom = labelBottom - labelHeight; //+lines;		int prevCons = 0;		int lostSpaceByInsert = 0;		int lastReadPos = MesquiteInteger.unassigned;		int start= 0;		int end = cwidth-2;		for (i=start;i < end;i+=2) {   //this goes through the pixels that are to be displayed, and sees if any from this read are in here			int readPos = i+firstReadLocation;  //this is pixels in the whole thing			int ic = findConsensusBaseNumber(i, firstReadBase, lastReadBase, firstReadLocation);//			if (!MesquiteInteger.isCombinable(ic)) Debugg.println("! ic " + ic);			if (MesquiteInteger.isCombinable(ic)){				if (MesquiteInteger.isCombinable(lastReadPos))					lostSpaceByInsert += readPos - lastReadPos -2;				lastReadPos = readPos;				readPos -= lostSpaceByInsert;//				if (!(readPos>=0&&readPos+2<A.length )) Debugg.println("! ic " + ic + "  " + readPos + "  " + A.length + " firstReadLocation " + firstReadLocation);				if ((readPos>=0&&readPos+2<A.length )) {  //is it within bounds of read?					int minPeakHeightToDraw = 3;					if (A[readPos]>minPeakHeightToDraw || C[readPos]>minPeakHeightToDraw || G[readPos]>minPeakHeightToDraw || T[readPos]>minPeakHeightToDraw){						if (prevCons != ic) {							//	offsetForInserted += spaceFollows;							offsetForInserted += panel.getSpaceInsertedAfterConsensusBase(ic);							//offsetForInserted += space;						}						int readBaseNumber = read.getReadBaseFromConsensusBase(ic);						prevCons=ic;						int qual = read.getPhdBaseQuality(readBaseNumber);						if (chromatogramPanel.getShowFades()) {							if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())								if (qual==0)									continue;								else 									ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));							if (chromatogramPanel.getFadeNonSourceRead()) {								int consensusBase = getConsensusBaseFromReadBase(readBaseNumber);								int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);								if (readUsed!=id) {									ColorDistribution.setTransparentGraphics(g,(float)NONSOURCEDIMFRACTION);								}							}							if (chromatogramPanel.getFadeNonSourceLowerQualityRead()) {								int consensusBase = getConsensusBaseFromReadBase(readBaseNumber);								int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);								Read sourceRead = chromatogramPanel.getContig().getRead(readUsed);								int qualityOfSourceBase = 0;								if (sourceRead!=null)									qualityOfSourceBase = sourceRead.getPhdBaseQuality(sourceRead.getReadBaseFromConsensusBase(consensusBase));								if (readUsed!=id  && qual<qualityOfSourceBase)									if (qual==0)										continue;									else 										ColorDistribution.setTransparentGraphics(g,(float)NONSOURCELOWERQUALITYDIMFRACTION);							}						}						int pixels = panel.getHorizontalPixels(i);//+ offsetForInserted);  //returns scaled horizontal pixels						/*temporary; to illustrate what read base the curve thinks its on *					//char c = read.getPhdBaseChar(readBaseNumber);					char c = panel.getMatrixStateAtConsensusPosition(ic);					Color tempC = panel.getBaseColor(c);					g.setColor(tempC);					fillRect(g, cwidth, pixels, 0, 2, 1000);	/**/						//int shadowOffset = (int)(2*(scale-10));						//	shadowOffset = 0;						//Debugg.println("scale " + 2*(scale-10));						//shadowOffset = 0;						//scale = 3;						Color baseColor;						if (chromatogramPanel.getShowA()) {							if (isShownComplemented())								baseColor = panel.getBaseColor(DNAState.T, panel.getBackgroundColor());							else 								baseColor = panel.getBaseColor(DNAState.A,panel.getBackgroundColor());							if (baseColor.equals(Color.black) && blackBackground)								baseColor = inverseBlackColor;							g.setColor(baseColor);							if (shadowOffset != 0 && (readPos-shadowOffset>=0&&readPos+2-shadowOffset<A.length ))								drawLine(g, cwidth, pixels,peakBottom-(int)((A[readPos] - shadowReduction*A[readPos-shadowOffset]) / scale),pixels+2,peakBottom-(int)((A[readPos+2]- shadowReduction*A[readPos+2-shadowOffset] )/ scale));							else								drawLine(g, cwidth, pixels,peakBottom-(int)(A[readPos] / scale),pixels+2,peakBottom-(int)(A[readPos+2] / scale));						}						if (chromatogramPanel.getShowC()) {							if (isShownComplemented())								baseColor = panel.getBaseColor(DNAState.G,panel.getBackgroundColor());							else 								baseColor = panel.getBaseColor(DNAState.C,panel.getBackgroundColor());							if (baseColor.equals(Color.black) && blackBackground)								baseColor = inverseBlackColor;							g.setColor(baseColor);							if (shadowOffset != 0 && (readPos-shadowOffset>=0&&readPos+2-shadowOffset<A.length ))								drawLine(g, cwidth, pixels,peakBottom-(int)((C[readPos] - shadowReduction*C[readPos-shadowOffset]) / scale),pixels+2,peakBottom-(int)((C[readPos+2]- shadowReduction*C[readPos+2-shadowOffset] )/ scale));							else								drawLine(g, cwidth, pixels,peakBottom-(int)(C[readPos] / scale),pixels+2,peakBottom-(int)(C[readPos+2] / scale));						}						if (chromatogramPanel.getShowG()) {							if (isShownComplemented())								baseColor = panel.getBaseColor(DNAState.C,panel.getBackgroundColor());							else 								baseColor = panel.getBaseColor(DNAState.G,panel.getBackgroundColor());							if (baseColor.equals(Color.black) && blackBackground)								baseColor = inverseBlackColor;							g.setColor(baseColor);							if (shadowOffset != 0 && (readPos-shadowOffset>=0&&readPos+2-shadowOffset<A.length ))								drawLine(g, cwidth, pixels,peakBottom-(int)((G[readPos] - shadowReduction*G[readPos-shadowOffset]) / scale),pixels+2,peakBottom-(int)((G[readPos+2]- shadowReduction*G[readPos+2-shadowOffset] )/ scale));							else								drawLine(g, cwidth, pixels,peakBottom-(int)(G[readPos] / scale),pixels+2,peakBottom-(int)(G[readPos+2] / scale));						}						if (chromatogramPanel.getShowT()) {							if (isShownComplemented())								baseColor = panel.getBaseColor(DNAState.A,panel.getBackgroundColor());							else 								baseColor = panel.getBaseColor(DNAState.T,panel.getBackgroundColor());							if (baseColor.equals(Color.black) && blackBackground)								baseColor = inverseBlackColor;							g.setColor(baseColor);							if (shadowOffset != 0 && (readPos-shadowOffset>=0&&readPos+2-shadowOffset<A.length ))								drawLine(g, cwidth, pixels,peakBottom-(int)((T[readPos] - shadowReduction*T[readPos-shadowOffset]) / scale),pixels+2,peakBottom-(int)((T[readPos+2]- shadowReduction*T[readPos+2-shadowOffset] )/ scale));							else								drawLine(g, cwidth, pixels,peakBottom-(int)(T[readPos] / scale),pixels+2,peakBottom-(int)(T[readPos+2] / scale));						}					}					if (chromatogramPanel.getShowFades() && (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead() || chromatogramPanel.getFadeNonSourceLowerQualityRead()))						ColorDistribution.setOpaqueGraphics(g);				}			}		}		if (shadowOffset != 0){			g.setColor(Color.gray);			String s = "Shadow offset " + shadowOffset + "; reduction: " + MesquiteDouble.toString(shadowReduction);			g.drawString(s,cwidth/2+8,v+30);			if (shadowOffset <0)				g.fillRect(cwidth/2 + shadowOffset, v+40, -shadowOffset, 4);			else				g.fillRect(cwidth/2, v+40, shadowOffset, 4);		}//		=====================  DRAWING THE READ NAME ==============================		if (!StringUtil.blank(chromatogram.getTitle()) && chromatogramPanel.getShowReadName()) {			if (chromatogram.getRead().getComplemented())				g.setColor(Color.red);			else				g.setColor(Color.black);			g.drawString(chromatogram.getTitle(),10,v+30);		}		VChromWindow window = (VChromWindow)chromatogramPanel.getMesquiteWindow();		if (chromatogramPanel.firstRead() && window!=null && window.extraContigsShown()) {			g.setColor(Color.black);			String s = panel.getContig().getName();			int stringWidth = StringUtil.getStringDrawLength(g,s);			g.drawString(s,cwidth-stringWidth-20,v+30);		}		/*		 * if (isShownReversed())			g.drawImage(VChromWindow.leftArrow,10,36, this);		else			g.drawImage(VChromWindow.rightArrow,10,36, this);		 */		if (isShownComplemented())			g.drawString("COMPLEMENTED", 10,v+64);		offsetForInserted = 0;//		=====================  COLOR THE BASES UNDER THE READ ==============================		for (i=firstReadBase;i < chromatogram.getBaseNumber() && i<=lastReadBase;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getConsensusBaseFromReadBase(i);				int space = panel.getSpaceInsertedBeforeConsensusBase(consensusBase);				offsetForInserted += space;				int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);				char c = read.getPhdBaseChar(i);				int qual = read.getPhdBaseQuality(i);				if (chromatogramPanel.getShowFades()) {					if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())						if (qual==0)							continue;						else 							ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));					if (chromatogramPanel.getFadeNonSourceRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);						if (readUsed!=id) {							ColorDistribution.setTransparentGraphics(g,(float)NONSOURCEDIMFRACTION);						}					}					if (chromatogramPanel.getFadeNonSourceLowerQualityRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);						Read sourceRead = chromatogramPanel.getContig().getRead(readUsed);						int qualityOfSourceBase = 0;						if (sourceRead!=null)							qualityOfSourceBase = sourceRead.getPhdBaseQuality(sourceRead.getReadBaseFromConsensusBase(consensusBase));						if (readUsed!=id  && qual<qualityOfSourceBase)							if (qual==0)								continue;							else 								ColorDistribution.setTransparentGraphics(g,(float)NONSOURCELOWERQUALITYDIMFRACTION);					}				}				cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				int w = 0;				if (i+1< chromatogram.getBaseNumber())					//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;					w = getPhdLocation(read, cwidth, i+1, panel,true) - getPhdLocation(read, cwidth, i, panel,true) + 1;				else					w =  (int)panel.getAveragePeakDistance();				if (qual>=0 && panel.getColorReadCallsByQuality()) {					if (qual==0)						g.setColor(Color.white);					//g.setColor(ColorDistribution.brighter(AceFile.getColorOfQuality(qual),0.2));					else						g.setColor(ColorDistribution.brighter(AceFile.getColorOfQuality(qual),0.5));					/*	char cc= panel.getMatrixStateAtConsensusPosition(consensusBase);		Color tempC = panel.getBaseColor(cc);		g.setColor(tempC);*/					fillRect(g, cwidth, getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted, labelTop, w, labelHeight);				}				if (chromatogramPanel.getShowFades() && (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead() || chromatogramPanel.getFadeNonSourceLowerQualityRead()))					ColorDistribution.setOpaqueGraphics(g);				if (selected[overallBase]){					w = 0;					if (i+1< chromatogram.getBaseNumber())						//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;						w = getPhdLocation(read, cwidth, i+1, panel,true) - getPhdLocation(read, cwidth, i, panel,true) + 1;					else						w =  (int)panel.getAveragePeakDistance();					g.setColor(Color.gray);					fillRect(g, cwidth, getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted, labelTop, w, labelHeight);				}			}		}		offsetForInserted = 0;//		=====================  SHOW THE SELECTION ==============================		firstSel = MesquiteInteger.unassigned;		ColorDistribution.setTransparentGraphics(g);				g.setColor(Color.gray);		cmid = 0;		for (i=firstReadBase-1; i<=lastReadBase+1;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getConsensusBaseFromReadBase(i);				offsetForInserted += panel.getSpaceInsertedBeforeConsensusBase(consensusBase);				int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);				char c = read.getPhdBaseChar(i);				cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				if (selected[overallBase]){					if (firstSel == MesquiteInteger.unassigned)						firstSel = getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted;				}				else if (firstSel != MesquiteInteger.unassigned){					int endOfSel = getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted;					fillRect(g, cwidth, firstSel, 0, endOfSel - firstSel, cheight);					firstSel = MesquiteInteger.unassigned;				}			}		}		if (firstSel != MesquiteInteger.unassigned){ //unfinished selection			int endOfSel = getPhdLocation(read, cwidth, lastReadBase+1, panel,true)- firstReadLocation - 2 + offsetForInserted;			fillRect(g, cwidth, firstSel, 0, endOfSel - firstSel, cheight);			firstSel = MesquiteInteger.unassigned;		}		ColorDistribution.setOpaqueGraphics(g);				offsetForInserted = 0;//		=====================  DRAW THE BASES UNDER THE READ ==============================		for (int primer=0; primer<chromatogramPanel.numPrimers;primer++)			for (int k=0; k<4; k++)				chromatogramPanel.lastPrimerDraw[primer][k]= -1;		for (i=firstReadBase;i < chromatogram.getBaseNumber() && i<=lastReadBase;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getConsensusBaseFromReadBase(i);				offsetForInserted += panel.getSpaceInsertedBeforeConsensusBase(consensusBase);				int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);				char c = read.getPhdBaseChar(i);				int qual = read.getPhdBaseQuality(i);				if (chromatogramPanel.getShowFades()) {					if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())						ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));					if (chromatogramPanel.getFadeNonSourceRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);						if (readUsed!=id) {							ColorDistribution.setTransparentGraphics(g,(float)NONSOURCEDIMFRACTION);						}					}					if (chromatogramPanel.getFadeNonSourceLowerQualityRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);						Read sourceRead = chromatogramPanel.getContig().getRead(readUsed);						int qualityOfSourceBase = 0;						if (sourceRead!=null)							qualityOfSourceBase = sourceRead.getPhdBaseQuality(sourceRead.getReadBaseFromConsensusBase(consensusBase));						if (readUsed!=id  && qual<qualityOfSourceBase)							if (qual==0)								continue;							else 								ColorDistribution.setTransparentGraphics(g,(float)NONSOURCELOWERQUALITYDIMFRACTION);					}				}				cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				if (isShownComplemented()){					c = DNAData.complementChar(c);				}
				Color textC = panel.getBaseColor(c,panel.getBackgroundColor());				int pixels = panel.getHorizontalPixels(getPhdLocation(read, cwidth, i, panel,true) - firstReadLocation) + offsetForInserted;				if (selected[overallBase]){					StringUtil.highlightString(g, String.valueOf(c), pixels - cmid, labelBottom-3, textC, Color.white);				}				else {					if (c=='N') 						g.setColor(Color.lightGray);					else {						if (textC.equals(Color.black) && blackBackground)							g.setColor(inverseBlackColor);						else							g.setColor(textC);						GraphicsUtil.setFontStyle(Font.BOLD,g);					}					GraphicsUtil.setFontSize(12,g);					drawString(g, cwidth, ""+c,pixels - cmid, labelBottom-3);					String aaa = chromatogram.getTitle();//					Drawing primers										if (panel.showPrimers()){						g.setColor(Color.gray);						for (int primer = 0; primer < chromatogramPanel.numPrimers; primer++)							for (int orientation = 0; orientation<4; orientation++){								if (chromatogramPanel.showPrimer[primer][orientation]){//									Wayne!!  note that I have commented out two conditions in the next three lines, involving i and k relative to  chromatogramPanel.primerMatch[primer][orientation].length//									If these two pieces are left in the code, then they prevent the primer wg578F from being drawn on the chromatogram									if (chromatogramPanel.primerMatch[primer][orientation] != null && i>=0 ){//&& i< chromatogramPanel.primerMatch[primer][orientation].length){										int k = chromatogramPanel.primerAlignedSeqToOrigSeq[i];										if (k>=0 ){//&& k< chromatogramPanel.primerMatch[primer][orientation].length){											int primerBase = chromatogramPanel.primerMatch[primer][orientation][k];											if (primerBase >=0 && primerBase < chromatogramPanel.primerAlignment[primer][orientation].length){												long primerState = chromatogramPanel.primerAlignment[primer][orientation][primerBase][1];												if (!DNAState.isInapplicable(primerState)){													String primerChar = "" + DNAState.toCharStatic(primerState);													drawString(g, cwidth, primerChar, pixels-cmid, labelBottom-30); 													chromatogramPanel.lastPrimerDraw[primer][orientation] = pixels-cmid;												}											}										}									}								}							}					}					GraphicsUtil.setFontStyle(Font.PLAIN,g);				}				if ((i+1) % 10 == 0 && chromatogramPanel.getShowBaseNumberWithinRead()) {					g.setColor(Color.lightGray);					GraphicsUtil.setFontSize(10,g);					int nmid = getFontMetrics(g.getFont()).stringWidth(String.valueOf(i+1)) / 2;					drawString(g, cwidth, String.valueOf(i+1),pixels - nmid,v+12);				}				if (chromatogramPanel.getShowFades() && (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead() || chromatogramPanel.getFadeNonSourceLowerQualityRead()))					ColorDistribution.setOpaqueGraphics(g);				if (chromatogramPanel.getShowBaseSource()) {					consensusBase = getConsensusBaseFromReadBase(i);					int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);					if (readUsed==id) {						g.setColor(ColorDistribution.sienna);						int rightLoc = read.getPhdRightBoundary(i,panel,true);						int leftLoc = read.getPhdLeftBoundary(i,panel,true);						fillRect(g, cwidth, leftLoc - firstReadLocation + offsetForInserted, labelTop, rightLoc-leftLoc, 3);					}				}			}		}		for (int primer=0; primer<chromatogramPanel.numPrimers;primer++)			for (int orientation = 0; orientation<4; orientation++)				if (chromatogramPanel.showPrimer[primer][orientation])					if (chromatogramPanel.lastPrimerDraw[primer][orientation]!= -1)						drawString(g, cwidth, chromatogramPanel.primerNames[primer] + chromatogramPanel.orientName[orientation], chromatogramPanel.lastPrimerDraw[primer][orientation], labelBottom-45);//		=====================  DRAW THE BOTTOM LINES ==============================		if (!simplerGraphics) {			g.setColor(Color.black);			g.drawLine(0,cheight-5,cwidth,v+cheight-5);			g.drawLine(0,cheight-4,cwidth,v+cheight-4);			g.setColor(Color.gray);			g.drawLine(0,cheight-3,cwidth,v+cheight-3);			g.setColor(Color.lightGray);			g.drawLine(0,cheight-2,cwidth,v+cheight-2);			g.setColor(ColorDistribution.veryLightGray);			g.drawLine(0,cheight-1,cwidth,v+cheight-1);		}//		Debugg.println("end of paint, "+chromatogram.getTitle());	}	/*--------------------------------------*/	/* to be used by subclasses to tell that panel touched */	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		int ic = findOverallBaseNumber(x); 		boolean onRequiredSelection = chromTool.getWorksOnlyOnSelection() && !getSelected(ic);		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels() &&!onRequiredSelection){			int cons = findConsensusBaseNumber(x);			((ChromatogramTool)tool).touched(cons, cons, true, id, chromatogramPanel.getContigID(), modifiers);
			/*		MesquiteWindow w = chromatogramPanel.getMesquiteWindow();		if (w!=null)			w.showQuickMessage(chromatogramPanel,null,x,y,"testing");			 */
			return;		}		if (MesquiteEvent.shiftKeyDown(modifiers)){			if (MesquiteInteger.isCombinable(ic)){				panel.setSecondTouchedOverall(ic);				chromatogramPanel.exportDeselectAll();				if (MesquiteInteger.isCombinable(panel.getFirstTouchedOverall())) {					if (panel.getFirstTouchedOverall()>ic){						for (int i = ic; i<=panel.getFirstTouchedOverall(); i++)							selectOverallBase(i);					}					else {						for (int i = panel.getFirstTouchedOverall(); i<=ic; i++)							selectOverallBase(i);					}				}				else {					selectOverallBase(ic);				}				//chromatogramPanel.synchTableToChrom(false);				panel.repaintPanels();			}		}		else if (MesquiteEvent.commandOrControlKeyDown(modifiers)){			if (MesquiteInteger.isCombinable(ic)){				selectOverallBase(ic);				panel.repaintPanels();			}		}		else {			if (MesquiteInteger.isCombinable(ic)){				panel.setFirstTouchedOverall(ic);				chromatogramPanel.exportDeselectAll();				selectOverallBase(ic);				if (clickCount>1)					panel.scrollToOverallBase(ic);				panel.repaintPanels();			}		}	}	public void mouseDrag (int modifiers, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		int ic = findOverallBaseNumber(x); 		boolean onRequiredSelection = chromTool.getWorksOnlyOnSelection() && !getSelected(ic);		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels() && !onRequiredSelection){			int cons = findConsensusBaseNumber(x);			((ChromatogramTool)tool).dragged(cons, cons, true, id, chromatogramPanel.getContigID(), modifiers);			return;		}		if (MesquiteInteger.isCombinable(ic)){			//deselectAll(); //this isn't correct behaviour!  If shift down should remember previously sleected pieces			if (MesquiteInteger.isCombinable(panel.getFirstTouchedOverall())) {				if (panel.getFirstTouchedOverall()>ic){					if (MesquiteInteger.isCombinable(panel.getSecondTouchedOverall()) && panel.getSecondTouchedOverall()<panel.getFirstTouchedOverall() && ic>panel.getSecondTouchedOverall()){ //retracting						for (int i = panel.getSecondTouchedOverall()+1; i<=ic; i++) 							deselectOverallBase(i);					}					else for (int i = ic; i<=panel.getFirstTouchedOverall(); i++) //adding						selectOverallBase(i);				}				else {					if (MesquiteInteger.isCombinable(panel.getSecondTouchedOverall()) && panel.getSecondTouchedOverall()>panel.getFirstTouchedOverall() && ic<panel.getSecondTouchedOverall()){ //retracting						for (int i = ic+1; i<=panel.getSecondTouchedOverall(); i++) 							deselectOverallBase(i);					}					else for (int i = panel.getFirstTouchedOverall(); i<=ic; i++)						selectOverallBase(i);				}			}			else {				selectOverallBase(ic);			}			//chromatogramPanel.synchTableToChrom(false);			panel.repaintPanels();			panel.setSecondTouchedOverall(ic);		}	}	/* to be used by subclasses to tell that panel touched */	public void mouseUp(int modifiers, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels()){			int cons = findConsensusBaseNumber(x);			((ChromatogramTool)tool).dropped(cons, cons, true, id, chromatogramPanel.getContigID(), modifiers);			return;		}		if (MesquiteInteger.isCombinable(panel.getFirstTouchedOverall())){			if (!MesquiteInteger.isCombinable(panel.getSecondTouchedOverall()))				panel.focusMatrixOn(panel.getConsensusBaseFromOverallBase(panel.getFirstTouchedOverall()), MesquiteInteger.unassigned);			else				panel.focusMatrixOn(panel.getConsensusBaseFromOverallBase(panel.getFirstTouchedOverall()), panel.getConsensusBaseFromOverallBase(panel.getSecondTouchedOverall()));		}		if (chromatogramPanel.getScrollToTouched()) {			int ic = findConsensusBaseNumber(x);			if (ic>=0) {				panel.scrollToConsensusBase(ic);		//		panel.deselectAllReads();			}		}		panel.setSecondTouchedOverall(MesquiteInteger.unassigned);	}	/*_________________________________________________*/	public void mouseMoved(int modifiers, int x, int y, MesquiteTool tool) {		int ic = findConsensusBaseNumber(x);		int readBaseNumber = read.getReadBaseFromConsensusBase(ic);		int quality = read.getPhdBaseQuality(readBaseNumber);		double averageQuality = read.getAverageQuality();		int numBasesHighQuality = read.getNumBasesHighQuality();		String s = "";		if (quality>=0)			s+= "Base quality: " + quality + ",   Peak heights: " + getPeakHeightsOfBase(readBaseNumber);		s+= "\n# Bases with Quality  " + read.getNumBasesHighQualityThreshold() + ": " + numBasesHighQuality + ",  Average Quality: " + averageQuality + "  ("+chromatogram.getTitle()+")";		panel.setExplanation( s);		if (tool == null)			return;		ChromatogramTool chromTool = (ChromatogramTool)tool;		if (chromTool.getWorksOnlyOnSelection())			if (!getSelected(findOverallBaseNumber(x)))				setCursor(Cursor.getDefaultCursor());			else				setCurrentCursor(modifiers, x, y, chromTool);	}	/*...............................................................................................................*/	public void mouseExited(int modifiers, int x, int y, MesquiteTool tool) {		setCursor(Cursor.getDefaultCursor());	}	/*...............................................................................................................*/	public void mouseEntered(int modifiers, int x, int y, MesquiteTool tool) {		if (tool == null)			return;		setCurrentCursor(modifiers, x, y, (ChromatogramTool)tool);	}}