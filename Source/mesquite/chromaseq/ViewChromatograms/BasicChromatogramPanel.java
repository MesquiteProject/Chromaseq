/* Mesquite Chromaseq source code.  Copyright 2005-2011 David Maddison and Wayne Maddison.Version 1.0   December 2011Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.ViewChromatograms; import java.awt.*;import java.awt.event.MouseEvent;import mesquite.align.lib.*;import mesquite.chromaseq.lib.*;import mesquite.lib.*;import mesquite.lib.ui.ClosablePanel;import mesquite.lib.ui.ClosablePanelContainer;import mesquite.lib.ui.ColorDistribution;import mesquite.lib.ui.GraphicsUtil;import mesquite.lib.ui.MesquiteWindow;import mesquite.categ.lib.*;public class BasicChromatogramPanel extends ChromatogramPanel {	protected BasicChromatogramCanvas chromCanvas;	protected ChromatogramCloseupPanel closeupPanel;	boolean colorByQuality = true;	boolean fadeLowQuality = false;	boolean showFades = true;	boolean fadeNonSourceRead = false;	boolean fadeNonSourceLowerQualityRead = true;	int fadeQualityThreshold = 30;	boolean showReadName = true;	boolean useStandardChromatogramColors = true;	boolean showBaseNumberWithinRead = true;	boolean showReadMatrixConflict = SHOWREADMATRIXCONFLICTDEFAULT;	boolean showA = true;	boolean showC = true;	boolean showG = true;	boolean showT = true;	boolean showBaseSource = true;	boolean showCodonPosition = false;	boolean simplerGraphics = true;	int standardHeight = ClosablePanel.MINHEIGHT;	int id;	int conflictLevelThreshold = 30;	boolean dimLowQualityConflicts = true;	boolean showMagPanel = false;	PairwiseAligner primerAligner;	String[] primerSequence = null; //primer	String[] primerNames = null; //primer	long[][][][] primerAlignment = null; //primer orientation site whichSequence	int[][][] primerMatch; //primer orientation position	int[][] lastPrimerDraw;  //primer orientation	boolean[][] showPrimer;	int numPrimers;	String[] orientName = new String[] {"", "(C)", " (R)", " (RC)"};	boolean useReadNameforPrimerName = true;	boolean ignorePrimerUsedForRead=true;	boolean showOnlySpecifiedPrimersForEachRead=false;	boolean[] primersSearched;	boolean[] primersMatched;	boolean primersSetup = false;	final static int READ=0;	final static int PRIMER=1;	//	boolean showSingleSpecifiedPrimer= true;	public BasicChromatogramPanel(ClosablePanelContainer container, Chromatogram myChrom, ContigDisplay panel, int id, int contigID) {		this.id = id;  // this is the read number		this.contigID = contigID;  //this is the taxon number or other id for contig		this.contigDisplay = panel;		open=true;		addKeyListener(panel);		chromatograms = new Chromatogram[1];		chromatograms[0] = myChrom;		chromatograms[0].setWindow(panel);		chromCanvas = new BasicChromatogramCanvas(this, id);		//this.setLayout(new BorderLayout(0,0));		chromCanvas.setBounds(0, 0, getWidth(), getHeight());		this.add("Center",chromCanvas);		if (chromatograms[0].getRead().getComplemented()) 			setBackground(ColorDistribution.veryVeryLightGray);		else			setBackground(Color.white);	}	public ChromatogramCloseupPanel getCloseupPanel() {		return closeupPanel;	}	public void setCloseupPanel(ChromatogramCloseupPanel closeupPanel) {		this.closeupPanel = closeupPanel;		chromCanvas.setCloseupPanel(closeupPanel);	}	/*.................................................................................................................*/	public boolean firstRead(){		return id==0;	}	/*.................................................................................................................*/	public int getCenterBase(){		return centerBase;	}	/*.................................................................................................................*/	private boolean primerOKToShow(long[][] alignment, double permittedMismatch){		int mismatches = 0;		int matches = 0;		for (int i = 0; i<alignment.length; i++){			if (alignment[i][READ] != CategoricalState.inapplicable && alignment[i][PRIMER] != CategoricalState.inapplicable ){				if (!CategoricalState.statesShared(alignment[i][READ] , alignment[i][1]))					mismatches++;				else					matches++;			}		}		return mismatches * 1.0 / (matches + mismatches) <= permittedMismatch;	}	/*.................................................................................................................*/	private boolean primerOKToShowBasedOnEndOfPrimer(long[][] alignment, boolean isReversed){		int mismatches = 0;		int matches = 0;		int primerBases = 0;		if (isReversed) {			for (int i = 0; i<alignment.length; i++){   // count from start				if (alignment[i][PRIMER] != CategoricalState.inapplicable ){					primerBases ++;				}				if (alignment[i][PRIMER] != CategoricalState.inapplicable)					if (!CategoricalState.statesShared(alignment[i][READ] , alignment[i][PRIMER]) )  //mismatch, and the primer has a base here						mismatches++;					else if (alignment[i][READ] != CategoricalState.inapplicable )						matches++;				if (primerBases>=5 && mismatches==0)					return true;				if (primerBases>=7 && mismatches<=1)					return true;				if (primerBases>=10 && mismatches<=2)					return true;				if (primerBases>=14 && mismatches<=3)					return true;			}		}		else {			for (int i = alignment.length-1; i>=0; i--){  // count from end				if (alignment[i][PRIMER] != CategoricalState.inapplicable ){					primerBases++;				}				if (alignment[i][PRIMER] != CategoricalState.inapplicable)					if (!CategoricalState.statesShared(alignment[i][READ] , alignment[i][PRIMER]) )  //mismatch, and the primer has a base here						mismatches++;					else if (alignment[i][READ] != CategoricalState.inapplicable )						matches++;				if (primerBases>=5 && mismatches==0)					return true;				if (primerBases>=7 && mismatches<=1)					return true;				if (primerBases>=10 && mismatches<=2)					return true;				if (primerBases>=14 && mismatches<=3)					return true;			}		}		return false;	}	/*.................................................................................................................*/	public boolean setUpPrimers(){		if (primersSetup)			return true;		Contig contig = contigDisplay.getContig();		ListableVector v = new ListableVector();		if (showOnlySpecifiedPrimersForEachRead || contigDisplay.getShowSinglePrimerMatch()) {			v.addElement(new Primer(getPrimerToShow()), false);		} 		else {			String s = contig.getRead(0).getPrimerName();			boolean primerNamesStored = ! StringUtil.blank(s);			for (int i = 0; i< contig.getNumReadsToShow(); i++){				if (primerNamesStored)					s = contig.getRead(i).getPrimerName();				else if (useReadNameforPrimerName) {  // we need to parse the chromatogram name					s = contig.getRead(i).getName();					s = StringUtil.getAllButLastItem(s, ".");					s = StringUtil.getLastItem(s, ".");				}				if (!v.nameAlreadyInList(s))					v.addElement(new Primer(s), false);			}		}		numPrimers = v.size();		primerSequence = new String[numPrimers];		primerNames = new String[numPrimers];		primersSearched = new boolean[numPrimers];		primersMatched = new boolean[numPrimers];		primerAlignment = new long[numPrimers][4][][];		primerMatch = new int[numPrimers][4][];		lastPrimerDraw = new int[numPrimers][4];		showPrimer = new boolean[numPrimers][4];		int alphabetLength = 4;		int subs[][] = AlignUtil.getDefaultSubstitutionCosts(alphabetLength);  		primerAligner = new PairwiseAligner (true, subs, 40, 20,  5, 5, alphabetLength);		primerAligner.setMaintainOrder(true);		String[][] primerSequences = contigDisplay.getPrimerSequences();		boolean onePrimerShown = false;		for(int primer = 0; primer < numPrimers; primer++){			primersMatched[primer] = false;			primersSearched[primer]=false;		}		for(int primer = 0; primer < numPrimers; primer++){			primerNames[primer] = v.nameOfElementAt(primer);			 if (searchForPrimerMatches(primer, primerSequences)){				onePrimerShown=true;				primersMatched[primer] = true;			 }			 primersSearched[primer]=true;		}				primersSetup = true;		return onePrimerShown;	}	/*--------------------------------------------------------*/	private void verboseLog(String s) {		MesquiteTrunk.mesquiteTrunk.logln(s);	}	/*--------------------------------------------------------*/	private boolean searchForPrimerMatches(int primer, String[][] primerSequences){				boolean atLeastOneOKToShow = false;		boolean doRevPrimer = false;  // search for reverse of primer		boolean doCompPrimer = false;  // search for complement of primer		String title = primerNames[primer];		if (ignorePrimerUsedForRead && title != null && title.equalsIgnoreCase(getPrimerName()))			return false;		if (!StringUtil.blank(title)){			if (primerSequences == null)				return false;			boolean found = false;			//find primer that this corresponds to			for (int i= 0; i<primerSequences.length; i++){				if (title.equalsIgnoreCase(primerSequences[i][0])){					primerSequence[primer] = primerSequences[i][1];					primerSequence[primer] = DNAData.collapseSymbol(primerSequence[primer], '*');					primerSequence[primer] = DNAData.collapseSymbol(primerSequence[primer], '-');					found = true;					break;				}			}			if (!found && primerSequences.length>0)				MesquiteMessage.warnProgrammer("Primer not found in primer list: " + title);		}		if (!StringUtil.blank(primerSequence[primer])){			try {				//getting long[] version of this sequence				String sequenceString = chromatograms[0].getRead().getSequence();				sequenceString = cleanSequenceString(sequenceString);				boolean verbose = false;				if (verbose) verboseLog("sequencesString length " + sequenceString.length());							long[] readSequence = DNAData.convertTerminalMissingToGaps(DNAData.sequenceLongsFromString(sequenceString));				if (verbose) verboseLog("readSequence length " + readSequence.length);							//getting long versions of the primer sequence				long[] asIs = DNAData.sequenceLongsFromString(primerSequence[primer], sequenceString.length());				if (verbose) verboseLog("asIs length " + asIs.length);							String complement = DNAData.complementString(primerSequence[primer]);				long[] comp=null;				if (doCompPrimer){					comp = DNAData.sequenceLongsFromString(complement, sequenceString.length());					if (verbose) verboseLog("comp length " + comp.length);					}				long[] rev =null;				if (doRevPrimer)					rev= DNAData.sequenceLongsFromString(DNAData.reverseString(primerSequence[primer]), sequenceString.length());				long[] revComp = DNAData.sequenceLongsFromString(DNAData.reverseString(complement), sequenceString.length());				if (verbose){					verboseLog("@@@@@@@@@@@@@@@@@ " + chromatograms[0].getTitle());					verboseLog("primer [" + DNAData.sequenceStringFromLongs(asIs) + "]");					if (doCompPrimer)						verboseLog("comp " + DNAData.sequenceStringFromLongs(comp));					if (doRevPrimer)						verboseLog("rev " + DNAData.sequenceStringFromLongs(rev));					verboseLog("revComp " + DNAData.sequenceStringFromLongs(revComp));					verboseLog("READunalligned [" + DNAData.sequenceStringFromLongs(readSequence, false) + "]");				}				MesquiteNumber scoreAsIs = new MesquiteNumber();				MesquiteNumber scoreComp = new MesquiteNumber();				MesquiteNumber scoreRev = new MesquiteNumber();				MesquiteNumber scoreRevComp = new MesquiteNumber();				MesquiteNumber bestScore;				int chosen = 0;				for (int i = 0; i<4; i++) {					showPrimer[primer][i]=false;					primerAlignment[primer][i] = new long[0][0];				}				//				OK, let's first try aligning the primer to the sequence				primerAlignment[primer][0] = primerAligner.alignSequences( readSequence, asIs, true, scoreAsIs);				showPrimer[primer][0] = primerOKToShow(primerAlignment[primer][0], 0.2);				if (!showPrimer[primer][0])					showPrimer[primer][0] = primerOKToShowBasedOnEndOfPrimer(primerAlignment[primer][0], false);				if (showPrimer[primer][0])					atLeastOneOKToShow = true;				bestScore = scoreAsIs;				int min = (sequenceString.length() - primerSequence[primer].length())*2;				if (verbose) verboseLog("$$$$$$$$ seq len " + sequenceString.length() + " primer " + primerSequence[primer].length() + " min " + min);				if (verbose) verboseLog("ASIS &&&&&&&&&&&&&&&&" + scoreAsIs);				if (verbose) verboseLog("PRIMER " + DNAData.sequenceStringFromLongs(asIs));				if (verbose) printPrimerAlignment(primerAlignment[primer][0]);				//				Now let's try aligning the complement of the primer to the sequence				long[][] align = null;				if (doCompPrimer) {					align = primerAligner.alignSequences( readSequence, comp, true, scoreComp);					if (verbose) verboseLog("comp &&&&&&&&&&&&&&&&" + scoreComp);					if (verbose) verboseLog("PRIMER " + DNAData.sequenceStringFromLongs(comp));					if (verbose) printPrimerAlignment(align);					primerAlignment[primer][1] = align;					showPrimer[primer][1] = primerOKToShow(align, 0.2);					if (!showPrimer[primer][1])						showPrimer[primer][1] = primerOKToShowBasedOnEndOfPrimer(align, true);					if (showPrimer[primer][1])						atLeastOneOKToShow = true;					if (scoreComp.isLessThan(bestScore)){						bestScore = scoreComp;						chosen = 1;					}				}				//				Aligning the reverse of the primer to the sequence				if (doRevPrimer) {					align = primerAligner.alignSequences( readSequence, rev, true, scoreRev);					if (verbose) verboseLog("rev &&&&&&&&&&&&&&&&" + scoreRev);					if (verbose) verboseLog("PRIMER " + DNAData.sequenceStringFromLongs(rev));					if (verbose) printPrimerAlignment(align);					primerAlignment[primer][2] = align;					showPrimer[primer][2] = primerOKToShow(align, 0.2);					if (!showPrimer[primer][2])						showPrimer[primer][2] = primerOKToShowBasedOnEndOfPrimer(align, false);					if (showPrimer[primer][2])						atLeastOneOKToShow = true;					if (scoreRev.isLessThan(bestScore)){						bestScore = scoreRev;						chosen = 2;					}				}				//				Aligning the reverse complement of the primer to the sequence				align = primerAligner.alignSequences( readSequence, revComp, true, scoreRevComp);				if (verbose) verboseLog("revComp &&&&&&&&&&&&&&&&" + scoreRevComp);				if (verbose) verboseLog("PRIMER " + DNAData.sequenceStringFromLongs(revComp));				if (verbose) printPrimerAlignment(align);				primerAlignment[primer][3] = align;				showPrimer[primer][3] = primerOKToShow(align, 0.2);				if (!showPrimer[primer][3])					showPrimer[primer][3] = primerOKToShowBasedOnEndOfPrimer(align, true);				if (showPrimer[primer][3])					atLeastOneOKToShow = true;				if (scoreRevComp.isLessThan(bestScore)){					bestScore = scoreRevComp;					chosen = 3;				}				//				Now we are done testing out the alignments				if (!showPrimer[primer][chosen]){					showPrimer[primer][chosen] = primerOKToShow(align, 0.33);					if (!showPrimer[primer][chosen])						for (int i = 0; i<4; i++)							if (showPrimer[primer][i]) {								chosen=i;								atLeastOneOKToShow = true;								break;							}				}				if (atLeastOneOKToShow)					MesquiteMessage.println("Primer (" + title + ") found to align with read " + chromatograms[0].getTitle() + ": " + primerSequence[primer]);				if (verbose) verboseLog("CHOSEN == " + chosen);				if (verbose) 					printPrimerAlignment(primerAlignment[primer][chosen]);				if (verbose){					verboseLog("    scoreAsIs " + scoreAsIs);					if (doCompPrimer) 						verboseLog("    scoreComplement " + scoreComp);					if (doRevPrimer) 						verboseLog("    scoreReverse " + scoreRev);					verboseLog("    scoreReverseComplement " + scoreRevComp);				}				if (verbose) 					verboseLog("bestScore == " + bestScore);				primerMatch[primer] = new int[4][];				for (int orientation = 0; orientation < 4; orientation++) {					primerMatch[primer][orientation] = new int[primerAlignment[primer][orientation].length];					if (verbose) verboseLog("orient " + orientation + "   lengthA " + primerMatch[primer][orientation].length);				}				for (int k = 0; k<4; k++)					for (int i=0; i< primerMatch[primer][k].length; i++)						primerMatch[primer][k][i] = -1;				if (verbose) System.out.println(">>>>>>>>>>>");				for (int orientation=0; orientation<4; orientation++){					int siteCount = -1;					int primerCount = -1;					boolean foundPrimer = false;					int startOfPrimer = -1;					for (int i=0; i<primerAlignment[primer][orientation].length; i++){						if (primerAlignment[primer][orientation][i][1] != MolecularState.inapplicable) {//primer has something 							primerCount++;							if (!foundPrimer)								startOfPrimer= i;							foundPrimer=true;						}						if (primerAlignment[primer][orientation][i][0] != MolecularState.inapplicable){ //sequence has something							siteCount++;							if (primerAlignment[primer][orientation][i][1]!= MolecularState.inapplicable){ // primer and sequence both have something								primerMatch[primer][orientation][siteCount] = i;								if (verbose) System.out.print("-" + siteCount);							}						}					}				}				if (verbose) System.out.println("<<<<<<<<<<<<<<<");			}			catch (Exception e){				for (int orientation = 0; orientation<4; orientation++){					primerMatch[primer][orientation] = null;					primerAlignment[primer][orientation] = null;				}				MesquiteMessage.warnProgrammer("Exception thrown in primer alignment");				e.printStackTrace();			}		}		return atLeastOneOKToShow;	}	/*--------------------------------------------------------*/	int[] primerAlignedSeqToOrigSeq;	private String cleanSequenceString( String seq){		primerAlignedSeqToOrigSeq = new int[seq.length()];		for (int i = 0; i < seq.length(); i++) 			primerAlignedSeqToOrigSeq[i] = -1;		StringBuffer s = new StringBuffer(seq.length());		String badString = "-N?*\r\n\t";		int count = -1;		for (int i = 0; i < seq.length(); i++) {			if (badString.indexOf(seq.charAt(i))<0){				count++;				s.append(seq.charAt(i));				primerAlignedSeqToOrigSeq[i] = count;			}		}		return s.toString();	}	private void printPrimerAlignment(long[][] alignment){		String sP = "";		String sR = "";		for (int i= 0; i<alignment.length; i++){			sP += DNAState.toCharStatic(alignment[i][1]);			sR += DNAState.toCharStatic(alignment[i][0]);		}		verboseLog("AlignedPRIM " + sP);		verboseLog("AlignedREAD " + sR);	}	public boolean isShownReversed(){		return contigDisplay.isShownReversed();	}	public boolean isShownComplemented(){		return contigDisplay.isShownComplemented();	}	public int getWidth() {		if (showMagPanel)			return getBounds().width-100;		else			return getBounds().width;	}	public int getHeight() {		return getBounds().height;	}	public int getRequestedHeight(int width){		if (open) {			return getStandardHeight();		}		else			return ClosablePanel.MINHEIGHT;	}	//uses index in consensus; this viewer must translate to index in the read	public boolean selectUniversalPositionInChrom(int universalBase, boolean sel, boolean repaint){		if (!listen)			return false;		if (chromCanvas != null)			return chromCanvas.setSelectedInChrom(universalBase, sel, repaint);		return false;	}	public void deselectAllChrom(int overallBase){		contigDisplay.deselectAllChrom(overallBase);	}	public void deselectAll(){		chromCanvas.deselectAll();	}	public void deselectAll(int overallBase){		chromCanvas.setSelected(overallBase,false);	}	public void synchChromToTable(boolean synchPosition){		contigDisplay.synchChromToTable(synchPosition);	}	public void synchTableToChrom(boolean synchPosition){		contigDisplay.synchTableToChrom(synchPosition);	}	public void repaintPanel(){		if (chromCanvas != null ) {			chromCanvas.repaint();		}	}	public void setMagnification(double mag){		if (chromCanvas != null ) {			chromCanvas.setMagnification(mag);		}	}	public void setShadowOffset(int o){		if (chromCanvas != null ) {			chromCanvas.setShadowOffset(o);		}	}	public void setShadowReduction(double mag){		if (chromCanvas != null ) {			chromCanvas.setShadowReduction(mag);		}	}	public Dimension minimumSize() {		return new Dimension(100,100);	}	/*.................................................................................................................*/	public Read getRead() {		if (chromatograms==null)			return null;		return chromatograms[0].getRead();	}	/*.................................................................................................................*/	public String getPrimerName() {		Read read = getRead();		if (read==null)			return null;		return read.getPrimerName();	}	/*.................................................................................................................*/	public String getPrimerToShow() {		if (contigDisplay.getShowSinglePrimerMatch()) {			return contigDisplay.getSinglePrimer();		} 		else {			Read read = getRead();			if (read==null)				return null;			return read.getPrimerToShow();		}	}	/*.................................................................................................................*/	public Contig getContig() {		return contigDisplay.getContig();	}	/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		this.fadeQualityThreshold = fadeQualityThreshold;	}	/*.................................................................................................................*/	public int getFadeQualityThreshold() {		return fadeQualityThreshold;	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		this.showBaseNumberWithinRead = showBaseNumberWithinRead;	}	/*.................................................................................................................*/	public boolean getShowBaseNumberWithinRead() {		return showBaseNumberWithinRead;	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		this.showReadName = showReadName;	}	/*.................................................................................................................*/	public boolean getShowReadName() {		return showReadName;	}	/*.................................................................................................................*/	public void setUseStandardChromatogramColors(boolean useStandardChromatogramColors) {		this.useStandardChromatogramColors = useStandardChromatogramColors;	}	/*.................................................................................................................*/	public boolean getUseStandardChromatogramColors() {		return useStandardChromatogramColors;	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean showReadMatrixConflict) {		this.showReadMatrixConflict = showReadMatrixConflict;	}	/*.................................................................................................................*/	public boolean getShowReadMatrixConflict() {		return showReadMatrixConflict;	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		this.fadeNonSourceRead = fadeNonSourceRead;	}	/*.................................................................................................................*/	public boolean getFadeNonSourceRead() {		return fadeNonSourceRead;	}	/*.................................................................................................................*/	public void setFadeNonSourceLowerQualityRead(boolean fadeNonSourceLowerQualityRead) {		this.fadeNonSourceLowerQualityRead = fadeNonSourceLowerQualityRead;	}	/*.................................................................................................................*/	public boolean getFadeNonSourceLowerQualityRead() {		return fadeNonSourceLowerQualityRead;	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		this.fadeLowQuality = fadeLowQuality;	}	/*.................................................................................................................*/	public boolean getShowFades() {		return showFades;	}	/*.................................................................................................................*/	public void setShowFades(boolean showFades) {		this.showFades = showFades;	}	/*.................................................................................................................*/	public boolean getFadeLowQuality() {		return fadeLowQuality;	}	/*.................................................................................................................*/	public  void setDimConflictMarkerThreshold (int conflictLevelThreshold){		this.conflictLevelThreshold = conflictLevelThreshold;	}	/*.................................................................................................................*/	public  int getDimConflictMarkerThreshold (){		return conflictLevelThreshold;	}	/*.................................................................................................................*/	public  void setDimLowQualityConflicts (boolean dimLowQualityConflicts){		this.dimLowQualityConflicts = dimLowQualityConflicts;	}	/*.................................................................................................................*/	public  boolean getDimLowQualityConflicts (){		return dimLowQualityConflicts;	}	/*.................................................................................................................*/	public void setColorByQuality(boolean colorByQuality) {		this.colorByQuality = colorByQuality;	}	/*.................................................................................................................*/	public boolean getColorByQuality() {		return colorByQuality;	}	/*.................................................................................................................*/	public void setShowA(boolean showA) {		this.showA = showA;	}	/*.................................................................................................................*/	public boolean getShowA() {		return showA;	}	/*.................................................................................................................*/	public void setShowC(boolean showC) {		this.showC = showC;	}	/*.................................................................................................................*/	public boolean getShowC() {		return showC;	}	/*.................................................................................................................*/	public void setShowG(boolean showG) {		this.showG = showG;	}	/*.................................................................................................................*/	public boolean getShowG() {		return showG;	}	/*.................................................................................................................*/	public void setShowT(boolean showT) {		this.showT = showT;	}	/*.................................................................................................................*/	public boolean getShowT() {		return showT;	}	/*.................................................................................................................*/	public void setShowCodonPosition(boolean showCodonPosition) {		this.showCodonPosition= showCodonPosition;	}	/*.................................................................................................................*/	public boolean getShowCodonPosition() {		return showCodonPosition;	}	public boolean getShowBaseSource() {		return showBaseSource;	}	public void setShowBaseSource(boolean showBaseSource) {		this.showBaseSource = showBaseSource;	}	public void shiftCloseupPanel(int universalBase) {		if (closeupPanel!=null){			closeupPanel.centerPanelAtOverallPosition(universalBase);		}	}	public void centerPanelAtUniversalBase(int i){		boolean shifted = centerBase!=i;		centerBase = i;		chromCanvas.repaint();		if (shifted){			shiftCloseupPanel(centerBase);		}	}	public void setVerticalPosition(int i){		verticalPosition = i;		chromCanvas.repaint();	}	public boolean getSelected(int overallBase) {		return chromCanvas.getSelected(overallBase);	}	public  int getTop() {		return top;	}	public  void setTop(int top) {		this.top = top;	}	public  void adjustTop(int adjustment) {		int x = getBounds().x;		int y = this.top-adjustment;		setBounds(x,y,width,height);		//chromArea.repaint();	}	public  void setBounds(int x, int y, int width, int height) {		super.setBounds(x,y,width,height);		this.width = width;		this.height = height;		chromCanvas.setBounds(0, 0, getWidth(), getHeight());		//chromArea.repaint();	}	public  void setSize( int width, int height) {		super.setSize(width,height);		this.width = width;		this.height = height;		chromCanvas.setBounds(0, 0, getWidth(), getHeight());		chromCanvas.repaint();	}	public int getStandardHeight() {		return standardHeight;	}	public void setStandardHeight(int standardHeight) {		this.standardHeight = standardHeight;	}}//=======================================================================================class BasicChromatogramCanvas extends ChromatogramCanvas {	BasicChromatogramPanel chromatogramPanel;	boolean darkBackground=false;	Color darkBackgroundColor = Color.gray;	boolean simplerGraphics=true;	static final double NONSOURCEDIMFRACTION = 0.2;	static final double NONSOURCELOWERQUALITYDIMFRACTION = 0.15;	/*..........................*/	public BasicChromatogramCanvas(BasicChromatogramPanel parentV, int id) {		super(parentV,  id);		chromatogramPanel = parentV;		addKeyListener(contigDisplay);	}	public static final int SINGLEREAD = 0;	/*...........................................................................*	public void setBackground(Color color) {		super.setBackground(color);	}	/*...........................................................................*/	public void paint(Graphics g) {			if (MesquiteWindow.checkDoomed(this)) 			return;		Graphics2D g2 = null;		if (g instanceof Graphics2D)			g2 = (Graphics2D)g;		int v = -verticalPosition;		Read read = chromatograms[SETREAD].getRead();		int cheight = getBounds().height;		int shadowHeight = 5;		int labelHeight = 18;		ChromaseqUniversalMapper universalMapper = contigDisplay.getUniversalMapper();		int labelBottom = v+cheight-shadowHeight;		int labelTop = labelBottom-labelHeight+1;		int cwidth = getBounds().width;		double scale = 1.0*maxValue / cheight / magnification;		int halfPeaks = contigDisplay.getApproximateNumberOfPeaksVisible()/2;		if (darkBackground)			setBackground(darkBackgroundColor);		else			setBackground(contigDisplay.getBackgroundColor());		boolean currentCloseup =  (closeupPanel.isCurrentChromatogram(chromatograms[SETREAD]));		/*		reCalcCenterBase();		int centerConsensusBase;		int centerReadBase;		if (contigDisplay.contigExists()) {					centerConsensusBase = contigDisplay.getContigBaseFromUniversalBase(centerBase);			//centerReadBase = getReadBaseFromConsensusBase(SINGLEREAD,centerConsensusBase);			centerReadBase = getReadBaseFromUniversalBase(SINGLEREAD,centerBase);			int universalBaseOfChromatogramStart = getUniversalBaseFromReadBase(SINGLEREAD,0);			int universalBaseOfChromatogramEnd = getUniversalBaseFromReadBase(SINGLEREAD,contigDisplay.getContig().getNumBases()-1);			if (MesquiteInteger.isCombinable(centerBase) && centerBase>=0 && (centerReadBase<0)) {  // find the nearest one that works				if (centerBase>=universalBaseOfChromatogramStart && centerBase<universalBaseOfChromatogramEnd) {					for (int i=centerBase-1; i>=0; i--) {						centerConsensusBase = contigDisplay.getContigBaseFromUniversalBase(i);						centerReadBase = getReadBaseFromConsensusBase(SINGLEREAD,centerConsensusBase);						if (centerConsensusBase>=0 && centerReadBase>=0) {							break;						}					}					if (centerConsensusBase<0 || centerReadBase<0)						for (int i=centerBase+1; i<contigDisplay.getTotalNumUniversalBases(); i++) {							centerConsensusBase = contigDisplay.getContigBaseFromUniversalBase(i);							centerReadBase = getReadBaseFromConsensusBase(SINGLEREAD,centerConsensusBase);							if (centerConsensusBase>=0 && centerReadBase>=0) {								break;							}						}				}			}		 */				reCalcCenterBase();		int centerReadBase;		//		int centerContigBase=0;		if (contigDisplay.contigExists()) {					centerReadBase = getReadBaseFromUniversalBase(SINGLEREAD,centerBase);			//			centerContigBase = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.ACEFILECONTIG, centerBase);			int universalBaseOfChromatogramStart = getUniversalBaseFromReadBase(SINGLEREAD,0);			int universalBaseOfChromatogramEnd = getUniversalBaseFromReadBase(SINGLEREAD,read.getBasesLength()-1);			//	int boundaryBaseStart = 			if (MesquiteInteger.isCombinable(centerBase) && centerBase>=0 && (!MesquiteInteger.isCombinable(centerReadBase) || centerReadBase<0)) {  // find the nearest one that works				if (centerBase>=universalBaseOfChromatogramStart && centerBase<universalBaseOfChromatogramEnd) {					for (int i=centerBase-1; i>=0; i--) {						centerReadBase = getReadBaseFromUniversalBase(SINGLEREAD,i);						if (centerReadBase>=0) {							break;						}					}					if (centerReadBase<0)						for (int i=centerBase+1; i<contigDisplay.getTotalNumUniversalBases(); i++) {							centerReadBase = getReadBaseFromUniversalBase(SINGLEREAD,i);							if (centerReadBase>=0) {								break;							}						}				}			}		} else{			centerReadBase = centerBase;		} 		int firstReadBase = centerReadBase - halfPeaks;		int lastReadBase = centerReadBase+halfPeaks;		int firstReadLocation = getPhdLocation(read, cwidth, centerReadBase,contigDisplay,true) - cwidth/2;		/*David: here a correction is introduced to discover what is actually the first and last read bases visible.  Previously		these bases were calcualted incorrectly if some reads were effectively compressed, and thus drawing didn't go all the way to the edges		A similar problem of compression was affecting findConsensusBaseNumber, hence some of this code is repeated there.		 */		int count = 0;		while (getPhdLocation(read, cwidth, firstReadBase,contigDisplay,true)  - firstReadLocation >0 && firstReadLocation>0 && count++<200)			firstReadBase--; //correcting for error in numpeaksvisible for this read		count = 0;		while (getPhdLocation(read, cwidth, lastReadBase,contigDisplay,true)  - firstReadLocation <cwidth && count++<200)			lastReadBase++; //correcting for error in numpeaksvisible for this read		firstReadBase--;		lastReadBase++;		int peakBottom = labelBottom - labelHeight; //+lines;		if (closeupPanel!=null && contigDisplay.getShowCloseupPanel()) {			int centerCloseupPosition = cwidth/2;			int w =  (int)contigDisplay.getAveragePeakDistance();			if (closeupPanel.getShowSourceBase()){				int contigBase = getContigBaseFromReadBase(SINGLEREAD,centerReadBase);				if (!closeupPanel.getShowTouchedBase() && chromatogramPanel.getContig().getBaseSource(contigBase)==id) {					g2.setColor(ChromaseqUtil.veryVeryLightBlue);					g2.fillRect(centerCloseupPosition-w*2, 0, w*4, peakBottom);					g2.setColor(ColorDistribution.veryLightBlue);					g2.drawRect(centerCloseupPosition-w*2, 0, w*4, peakBottom);					closeupPanel.setCloseupPanel(true,chromatograms[SINGLEREAD],true);				} else if (closeupPanel.getShowTouchedBase()) {					int readBaseNumber = closeupPanel.getReadBaseNumber();					if (readBaseNumber>centerReadBase)						centerCloseupPosition = centerCloseupPosition + (int)((closeupPanel.getReadBaseNumber()-centerReadBase)*contigDisplay.getAveragePeakDistance()-contigDisplay.getAveragePeakDistance()/2);					else						centerCloseupPosition = centerCloseupPosition + (int)((closeupPanel.getReadBaseNumber()-centerReadBase)*contigDisplay.getAveragePeakDistance()+contigDisplay.getAveragePeakDistance()/2);					g2.setColor(ChromaseqUtil.veryVeryLightBlue);					g2.fillRect(centerCloseupPosition-w*2, 0, w*4, peakBottom);					g2.setColor(ColorDistribution.veryLightBlue);					g2.drawRect(centerCloseupPosition-w*2, 0, w*4, peakBottom);				}			} else if (currentCloseup && closeupPanel.getShowCenterBase()){				g2.setColor(ChromaseqUtil.veryVeryLightBlue);				g2.fillRect(centerCloseupPosition-w*2, 0, w*4, peakBottom);				g2.setColor(ColorDistribution.veryLightBlue);				g2.drawRect(centerCloseupPosition-w*2, 0, w*4, peakBottom);			}		}		int i;		double fadeMax = 0.5;		//		int offsetForInserted = 0;		//		Now to show the read-matrix conflict marker		int firstSel = MesquiteInteger.unassigned;		Composite composite = ColorDistribution.getComposite(g);		ColorDistribution.setTransparentGraphics(g);				int cmid = 0;		for (i=firstReadBase-1; i<=lastReadBase+1;i++) {			if (i>=0 && i<read.getBasesLength()) {				int contigBase = getContigBaseFromReadBase(SINGLEREAD,i);				//offsetForInserted += contigDisplay.getSpaceInsertedBeforeDisplayBase(consensusBase);				//				int overallBase = contigDisplay.getUniversalBaseFromContigBase(consensusBase);				char c = read.getPhdBaseChar(i);				if (chromatogramPanel.getShowReadMatrixConflict()){					if (contigDisplay.isComplementedInEditedData())						c=DNAData.complementChar(c);					contigBase = getContigBaseFromReadBase(SINGLEREAD,i);					char contigChar = contigDisplay.getMatrixStateAtContigBase(contigBase);					if (contigChar != c) {						int quality = read.getPhdBaseQuality(i);						if (chromatogramPanel.getDimLowQualityConflicts()) {							if (quality==0)								continue;							else if (quality>=chromatogramPanel.getDimConflictMarkerThreshold())								g.setColor(ColorDistribution.burlyWood);							else								g.setColor(ColorDistribution.brighter(ColorDistribution.burlyWood, (float)(quality/(1.0*chromatogramPanel.getDimConflictMarkerThreshold()))));						}						else 							g.setColor(ColorDistribution.burlyWood);						int rightLoc = read.getPhdRightBoundary(i,contigDisplay,true);						int leftLoc = read.getPhdLeftBoundary(i,contigDisplay,true);						fillRect(g, cwidth, leftLoc - firstReadLocation, 0, rightLoc-leftLoc, labelTop-1);						g.setColor(Color.gray);					}				}			}		}		ColorDistribution.setComposite(g,composite);				//		=====================  COLOR THE CODON POSITIONS ==============================		if (chromatogramPanel.getShowCodonPosition()) {			composite = ColorDistribution.getComposite(g);			ColorDistribution.setTransparentGraphics(g,0.2f);					for (i=firstReadBase; i<=lastReadBase;i++) {				if (i>=0 && i<read.getBasesLength()) {					int consensusBase = getContigBaseFromReadBase(SINGLEREAD,i);					//offsetForInserted += contigDisplay.getSpaceInsertedBeforeDisplayBase(consensusBase);					int overallBase = contigDisplay.getUniversalBaseFromContigBase(consensusBase);					int codonPosition = contigDisplay.getCodonPositionOfOverallBase(overallBase);					if (codonPosition>0 && codonPosition<4) {						switch (codonPosition) {						case 1: g.setColor(Color.blue); break;						case 2: g.setColor(Color.green); break;						case 3: g.setColor(Color.red); break;						default: g.setColor(Color.white); break;						}						int w = read.getPhdRightBoundary(i,contigDisplay,true) - read.getPhdLeftBoundary(i,contigDisplay,true);						int hor = read.getPhdLeftBoundary(i, contigDisplay,true)- firstReadLocation;						fillRect(g, cwidth, hor, 16, w, 26);					}				}			}			ColorDistribution.setComposite(g,composite);				}		//		Drawing the center line		g.setColor(Color.lightGray);		g.drawLine(cwidth/2,0,cwidth/2,v+cheight);		Color inverseBlackColor = Color.white;		//		=====================  DRAWING THE PEAKS ==============================		int prevCons = 0;		int lostSpaceByInsert = 0;		int lastReadPos = MesquiteInteger.unassigned;		int nextReadPos = firstReadLocation;		int prevReadPos = firstReadLocation;		int start= 0;		int lastPixels = MesquiteInteger.unassigned;		int end = cwidth-2;		for (i=start;i < end;i+=2) {   //this goes through the pixels that are to be displayed, and sees if any from this read are in here			int readPos = i+firstReadLocation;  //this is pixels in the whole thing			int ic = findConsensusBaseNumber(SINGLEREAD,i, firstReadBase, lastReadBase, firstReadLocation);			if (MesquiteInteger.isCombinable(ic)&&MesquiteInteger.isCombinable(firstReadLocation)){				if (MesquiteInteger.isCombinable(lastReadPos))					lostSpaceByInsert += readPos - lastReadPos -2;				lastReadPos = readPos;				readPos -= lostSpaceByInsert;				if (MesquiteInteger.isCombinable(readPos) && (readPos>=0&&readPos+2<A.length )) {  //is it within bounds of read?					int minPeakHeightToDraw = 3;					if (A[readPos]>minPeakHeightToDraw || C[readPos]>minPeakHeightToDraw || G[readPos]>minPeakHeightToDraw || T[readPos]>minPeakHeightToDraw){						if (prevCons != ic) {							//	offsetForInserted += spaceFollows;							//	offsetForInserted += contigDisplay.getSpaceInsertedAfterDisplayBase(ic);							//offsetForInserted += space;						}						nextReadPos=readPos+2;						int readBaseNumber = read.getReadBaseFromContigBase(ic);						prevCons=ic;						int qual = read.getPhdBaseQuality(readBaseNumber);						if (chromatogramPanel.getShowFades()) {							if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())								if (qual==0)									continue;								else 									ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));							if (chromatogramPanel.getFadeNonSourceRead()) {								int consensusBase = getContigBaseFromReadBase(SINGLEREAD,readBaseNumber);								int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);								if (readUsed!=id) {									ColorDistribution.setTransparentGraphics(g,(float)NONSOURCEDIMFRACTION);								}							}							if (chromatogramPanel.getFadeNonSourceLowerQualityRead()) {								int consensusBase = getContigBaseFromReadBase(SINGLEREAD,readBaseNumber);								int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);								Read sourceRead = chromatogramPanel.getContig().getRead(readUsed);								int qualityOfSourceBase = 0;								if (sourceRead!=null)									qualityOfSourceBase = sourceRead.getPhdBaseQuality(sourceRead.getReadBaseFromContigBase(consensusBase));								if (readUsed!=id  && qual<qualityOfSourceBase)									if (qual==0)										continue;									else 										ColorDistribution.setTransparentGraphics(g,(float)NONSOURCELOWERQUALITYDIMFRACTION);							}						}						int pixels = contigDisplay.getHorizontalPixels(i);//+ offsetForInserted);  //returns scaled horizontal pixels						if (!MesquiteInteger.isCombinable(lastPixels))							lastPixels=pixels;						/*temporary; to illustrate what read base the curve thinks its on *					//char c = read.getPhdBaseChar(readBaseNumber);					char c = panel.getMatrixStateAtConsensusPosition(ic);					Color tempC = panel.getBaseColor(c);					g.setColor(tempC);					fillRect(g, cwidth, pixels, 0, 2, 1000);	/**/						//int shadowOffset = (int)(2*(scale-10));						//	shadowOffset = 0;						//shadowOffset = 0;						//scale = 3;						Color baseColor;						if (chromatogramPanel.getShowA()) {							if (isShownComplemented())								baseColor = contigDisplay.getBaseColor(DNAState.T, contigDisplay.getBackgroundColor());							else 								baseColor = contigDisplay.getBaseColor(DNAState.A,contigDisplay.getBackgroundColor());							if (baseColor.equals(Color.black) && darkBackground)								baseColor = inverseBlackColor;							g.setColor(baseColor);							//		drawCurve(g2, cwidth, prevReadPos, readPos ,nextReadPos,A,peakBottom, scale, 1.0, firstReadLocation);							if (shadowOffset != 0 && (readPos-shadowOffset>=0&&readPos+2-shadowOffset<A.length ))								drawLine(g, cwidth, pixels,peakBottom-(int)((A[readPos] - shadowReduction*A[readPos-shadowOffset]) / scale),pixels+2,peakBottom-(int)((A[readPos+2]- shadowReduction*A[readPos+2-shadowOffset] )/ scale));							else								drawLine(g, cwidth, pixels,peakBottom-(int)(A[readPos] / scale),pixels+2,peakBottom-(int)(A[readPos+2] / scale));						}						if (chromatogramPanel.getShowC()) {							if (isShownComplemented())								baseColor = contigDisplay.getBaseColor(DNAState.G,contigDisplay.getBackgroundColor());							else 								baseColor = contigDisplay.getBaseColor(DNAState.C,contigDisplay.getBackgroundColor());							if (baseColor.equals(Color.black) && darkBackground)								baseColor = inverseBlackColor;							g.setColor(baseColor);							if (shadowOffset != 0 && (readPos-shadowOffset>=0&&readPos+2-shadowOffset<A.length ))								drawLine(g, cwidth, pixels,peakBottom-(int)((C[readPos] - shadowReduction*C[readPos-shadowOffset]) / scale),pixels+2,peakBottom-(int)((C[readPos+2]- shadowReduction*C[readPos+2-shadowOffset] )/ scale));							else								drawLine(g, cwidth, pixels,peakBottom-(int)(C[readPos] / scale),pixels+2,peakBottom-(int)(C[readPos+2] / scale));						}						if (chromatogramPanel.getShowG()) {							if (isShownComplemented())								baseColor = contigDisplay.getBaseColor(DNAState.C,contigDisplay.getBackgroundColor());							else 								baseColor = contigDisplay.getBaseColor(DNAState.G,contigDisplay.getBackgroundColor());							if (baseColor.equals(Color.black) && darkBackground)								baseColor = inverseBlackColor;							g.setColor(baseColor);							if (shadowOffset != 0 && (readPos-shadowOffset>=0&&readPos+2-shadowOffset<A.length ))								drawLine(g, cwidth, pixels,peakBottom-(int)((G[readPos] - shadowReduction*G[readPos-shadowOffset]) / scale),pixels+2,peakBottom-(int)((G[readPos+2]- shadowReduction*G[readPos+2-shadowOffset] )/ scale));							else								drawLine(g, cwidth, pixels,peakBottom-(int)(G[readPos] / scale),pixels+2,peakBottom-(int)(G[readPos+2] / scale));						}						if (chromatogramPanel.getShowT()) {							if (isShownComplemented())								baseColor = contigDisplay.getBaseColor(DNAState.A,contigDisplay.getBackgroundColor());							else 								baseColor = contigDisplay.getBaseColor(DNAState.T,contigDisplay.getBackgroundColor());							if (baseColor.equals(Color.black) && darkBackground)								baseColor = inverseBlackColor;							g.setColor(baseColor);							if (shadowOffset != 0 && (readPos-shadowOffset>=0&&readPos+2-shadowOffset<A.length ))								drawLine(g, cwidth, pixels,peakBottom-(int)((T[readPos] - shadowReduction*T[readPos-shadowOffset]) / scale),pixels+2,peakBottom-(int)((T[readPos+2]- shadowReduction*T[readPos+2-shadowOffset] )/ scale));							else								drawLine(g, cwidth, pixels,peakBottom-(int)(T[readPos] / scale),pixels+2,peakBottom-(int)(T[readPos+2] / scale));						}						lastPixels = pixels;					}					if (chromatogramPanel.getShowFades() && (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead() || chromatogramPanel.getFadeNonSourceLowerQualityRead()))						ColorDistribution.setComposite(g,composite);						}			}			prevReadPos = readPos;		}		if (shadowOffset != 0){			g.setColor(Color.gray);			String s = "Shadow offset " + shadowOffset + "; reduction: " + MesquiteDouble.toString(shadowReduction);			g.drawString(s,cwidth/2+8,v+30);			if (shadowOffset <0)				g.fillRect(cwidth/2 + shadowOffset, v+40, -shadowOffset, 4);			else				g.fillRect(cwidth/2, v+40, shadowOffset, 4);		}		//		=====================  DRAWING THE READ NAME ==============================		if (!StringUtil.blank(chromatograms[SINGLEREAD].getTitle()) && chromatogramPanel.getShowReadName()) {			if (chromatograms[SINGLEREAD].getRead().getComplemented())				g.setColor(Color.red);			else				g.setColor(Color.black);			g.drawString(chromatograms[SINGLEREAD].getTitle(),10,v+30);		}		VChromWindow window = (VChromWindow)chromatogramPanel.getMesquiteWindow();		if (chromatogramPanel.firstRead() && window!=null && window.extraContigsShown()) {			g.setColor(Color.black);			String s = contigDisplay.getContig().getName();			int stringWidth = StringUtil.getStringDrawLength(g,s);			g.drawString(s,cwidth-stringWidth-20,v+30);		}		/*		 * if (isShownReversed())			g.drawImage(VChromWindow.leftArrow,10,36, this);		else			g.drawImage(VChromWindow.rightArrow,10,36, this);		 */		if (isShownComplemented())			g.drawString("COMPLEMENTED", 10,v+64);		//		=====================  COLOR THE BASES UNDER THE READ ==============================		for (i=firstReadBase; i<=lastReadBase;i++) {  //i < chromatograms[SINGLEREAD].getBaseNumber() &&			if (i>=0 && i<read.getBasesLength()) {				int contigBase = getContigBaseFromReadBase(SINGLEREAD,i);				//				int space = contigDisplay.getSpaceInsertedBeforeDisplayBase(consensusBase);				//	offsetForInserted += space;				int overallBase = contigDisplay.getUniversalBaseFromContigBase(contigBase);				char c = read.getPhdBaseChar(i);				int qual = read.getPhdBaseQuality(i);				if (chromatogramPanel.getShowFades()) {					if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())						if (qual==0)							continue;						else 							ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));					if (chromatogramPanel.getFadeNonSourceRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(contigBase);						if (readUsed!=id) {							ColorDistribution.setTransparentGraphics(g,(float)NONSOURCEDIMFRACTION);						}					}					if (chromatogramPanel.getFadeNonSourceLowerQualityRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(contigBase);						Read sourceRead = chromatogramPanel.getContig().getRead(readUsed);						int qualityOfSourceBase = 0;						if (sourceRead!=null)							qualityOfSourceBase = sourceRead.getPhdBaseQuality(sourceRead.getReadBaseFromContigBase(contigBase));						if (readUsed!=id  && qual<qualityOfSourceBase)							if (qual==0)								continue;							else 								ColorDistribution.setTransparentGraphics(g,(float)NONSOURCELOWERQUALITYDIMFRACTION);					}				}				cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				int w = 0;				if (i+1< chromatograms[SINGLEREAD].getBaseNumber())					//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;					w = getPhdLocation(read, cwidth, i+1, contigDisplay,true) - getPhdLocation(read, cwidth, i, contigDisplay,true) + 1;				else					w =  (int)contigDisplay.getAveragePeakDistance();				if (qual>=0 && contigDisplay.getColorReadCallsByQuality()) {					if (qual==0)						g.setColor(Color.white);					//g.setColor(ColorDistribution.brighter(AceFile.getColorOfQuality(qual),0.2));					else						g.setColor(ColorDistribution.brighter(AceFile.getColorOfQuality(qual),0.5));					/*	char cc= panel.getMatrixStateAtConsensusPosition(consensusBase);		Color tempC = panel.getBaseColor(cc);		g.setColor(tempC);*/					fillRect(g, cwidth, getPhdLocation(read, cwidth, i, contigDisplay,true)- firstReadLocation - cmid - 2, labelTop, w, labelHeight);				}				if (chromatogramPanel.getShowFades() && (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead() || chromatogramPanel.getFadeNonSourceLowerQualityRead()))					ColorDistribution.setComposite(g,composite);						if (overallBase>=0 && overallBase<selected.length && selected[overallBase]){					w = 0;					if (i+1< chromatograms[SINGLEREAD].getBaseNumber())						//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;						w = getPhdLocation(read, cwidth, i+1, contigDisplay,true) - getPhdLocation(read, cwidth, i, contigDisplay,true) + 1;					else						w =  (int)contigDisplay.getAveragePeakDistance();					g.setColor(Color.gray);					fillRect(g, cwidth, getPhdLocation(read, cwidth, i, contigDisplay,true)- firstReadLocation - cmid - 2, labelTop, w, labelHeight);				}			}		}		//		=====================  SHOW THE SELECTION ==============================		firstSel = MesquiteInteger.unassigned;		ColorDistribution.setTransparentGraphics(g);				g.setColor(Color.gray);		cmid = 0;		for (i=firstReadBase-1; i<=lastReadBase+1;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getContigBaseFromReadBase(SINGLEREAD,i);				//				offsetForInserted += contigDisplay.getSpaceInsertedBeforeDisplayBase(consensusBase);				int overallBase = contigDisplay.getUniversalBaseFromContigBase(consensusBase);				char c = read.getPhdBaseChar(i);				cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				if (overallBase>=0 && overallBase<selected.length && selected[overallBase]){					if (firstSel == MesquiteInteger.unassigned)						firstSel = getPhdLocation(read, cwidth, i, contigDisplay,true)- firstReadLocation - cmid - 2;				}				else if (firstSel != MesquiteInteger.unassigned){					int endOfSel = getPhdLocation(read, cwidth, i, contigDisplay,true)- firstReadLocation - cmid - 2;					fillRect(g, cwidth, firstSel, 0, endOfSel - firstSel, cheight);					firstSel = MesquiteInteger.unassigned;				}			}		}		if (firstSel != MesquiteInteger.unassigned){ //unfinished selection			int endOfSel = getPhdLocation(read, cwidth, lastReadBase+1, contigDisplay,true)- firstReadLocation - 2;			fillRect(g, cwidth, firstSel, 0, endOfSel - firstSel, cheight);			firstSel = MesquiteInteger.unassigned;		}		ColorDistribution.setComposite(g,composite);				//		=====================  DRAW THE BASES UNDER THE READ ==============================		for (int primer=0; primer<chromatogramPanel.numPrimers;primer++)			for (int k=0; k<4; k++)				chromatogramPanel.lastPrimerDraw[primer][k]= -1;		for (i=firstReadBase; i<=lastReadBase;i++) {  //i < chromatograms[SINGLEREAD].getBaseNumber() &&			if (i>=0 && i<read.getBasesLength()) {				int contigBase = getContigBaseFromReadBase(SINGLEREAD,i);				//				offsetForInserted += contigDisplay.getSpaceInsertedBeforeDisplayBase(consensusBase);				//				int overallBase = contigDisplay.getUniversalBaseFromContigBase(consensusBase);				char c = read.getPhdBaseChar(i);				int qual = read.getPhdBaseQuality(i);				if (chromatogramPanel.getShowFades()) {					if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())						ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));					if (chromatogramPanel.getFadeNonSourceRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(contigBase);						if (readUsed!=id) {							ColorDistribution.setTransparentGraphics(g,(float)NONSOURCEDIMFRACTION);						}					}					if (chromatogramPanel.getFadeNonSourceLowerQualityRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(contigBase);						Read sourceRead = chromatogramPanel.getContig().getRead(readUsed);						int qualityOfSourceBase = 0;						if (sourceRead!=null)							qualityOfSourceBase = sourceRead.getPhdBaseQuality(sourceRead.getReadBaseFromContigBase(contigBase));						if (readUsed!=id  && qual<qualityOfSourceBase)							if (qual==0)								continue;							else 								ColorDistribution.setTransparentGraphics(g,(float)NONSOURCELOWERQUALITYDIMFRACTION);					}				}				cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				if (isShownComplemented()){					c = DNAData.complementChar(c);				}
				Color textC = contigDisplay.getBaseColor(c,contigDisplay.getBackgroundColor());				int pixels = contigDisplay.getHorizontalPixels(getPhdLocation(read, cwidth, i, contigDisplay,true) - firstReadLocation);				if (c=='N') 					g.setColor(Color.lightGray);				else {					if (textC.equals(Color.black) && darkBackground)						g.setColor(inverseBlackColor);					else						g.setColor(textC);					GraphicsUtil.setFontStyle(Font.BOLD,g);				}				GraphicsUtil.setFontSize(12,g);				drawString(g, cwidth, ""+c,pixels - cmid, labelBottom-3);				String aaa = chromatograms[SINGLEREAD].getTitle();				//					Drawing primers									if (contigDisplay.showPrimers()){					g.setColor(Color.gray);					for (int primer = 0; primer < chromatogramPanel.numPrimers; primer++)						for (int orientation = 0; orientation<4; orientation++){							if (chromatogramPanel.showPrimer[primer][orientation]){								//									Wayne!!  note that I have commented out two conditions in the next three lines, involving i and k relative to  chromatogramPanel.primerMatch[primer][orientation].length								//									If these two pieces are left in the code, then they prevent the primer wg578F from being drawn on the chromatogram								if (chromatogramPanel.primerMatch[primer][orientation] != null && i>=0 ){//&& i< chromatogramPanel.primerMatch[primer][orientation].length){									int k = chromatogramPanel.primerAlignedSeqToOrigSeq[i];									if (k>=0 ){//&& k< chromatogramPanel.primerMatch[primer][orientation].length){										int primerBase = chromatogramPanel.primerMatch[primer][orientation][k];										if (primerBase >=0 && primerBase < chromatogramPanel.primerAlignment[primer][orientation].length){											long primerState = chromatogramPanel.primerAlignment[primer][orientation][primerBase][1];											if (!DNAState.isInapplicable(primerState)){												String primerChar = "" + DNAState.toCharStatic(primerState);												drawString(g, cwidth, primerChar, pixels-cmid, labelBottom-30); 												chromatogramPanel.lastPrimerDraw[primer][orientation] = pixels-cmid;											}										}									}								}							}						}				}				GraphicsUtil.setFontStyle(Font.PLAIN,g);				if ((i+1) % 10 == 0 && chromatogramPanel.getShowBaseNumberWithinRead()) {					g.setColor(Color.lightGray);					GraphicsUtil.setFontSize(10,g);					int nmid = getFontMetrics(g.getFont()).stringWidth(String.valueOf(i+1)) / 2;					//int universalBase = getUniversalBaseFromReadBase(SINGLEREAD,i);					//drawString(g, cwidth, String.valueOf(universalBase),pixels - nmid,v+12);					drawString(g, cwidth, String.valueOf(i+1),pixels - nmid,v+12);				}				if (chromatogramPanel.getShowFades() && (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead() || chromatogramPanel.getFadeNonSourceLowerQualityRead()))					ColorDistribution.setComposite(g,composite);						if (chromatogramPanel.getShowBaseSource()) {					contigBase = getContigBaseFromReadBase(SINGLEREAD,i);					int readUsed = chromatogramPanel.getContig().getBaseSource(contigBase);					if (readUsed==id) {						g.setColor(ColorDistribution.sienna);						int rightLoc = read.getPhdRightBoundary(i,contigDisplay,true);						int leftLoc = read.getPhdLeftBoundary(i,contigDisplay,true);						fillRect(g, cwidth, leftLoc - firstReadLocation, labelTop, rightLoc-leftLoc, 3);					}				}			}		}		for (int primer=0; primer<chromatogramPanel.numPrimers;primer++)			for (int orientation = 0; orientation<4; orientation++)				if (chromatogramPanel.showPrimer[primer][orientation])					if (chromatogramPanel.lastPrimerDraw[primer][orientation]!= -1)						drawString(g, cwidth, chromatogramPanel.primerNames[primer] + chromatogramPanel.orientName[orientation], chromatogramPanel.lastPrimerDraw[primer][orientation], labelBottom-45);		//		=====================  DRAW THE BOTTOM LINES ==============================		if (!simplerGraphics) {			g.setColor(Color.black);			g.drawLine(0,cheight-5,cwidth,v+cheight-5);			g.drawLine(0,cheight-4,cwidth,v+cheight-4);			g.setColor(Color.gray);			g.drawLine(0,cheight-3,cwidth,v+cheight-3);			g.setColor(Color.lightGray);			g.drawLine(0,cheight-2,cwidth,v+cheight-2);			g.setColor(ColorDistribution.veryLightGray);			g.drawLine(0,cheight-1,cwidth,v+cheight-1);		}		MesquiteWindow.uncheckDoomed(this);	}	/*_________________________________________________*/	public void drawCloseupBox(int center, int base) {		if (MesquiteInteger.isCombinable(center)&&MesquiteInteger.isCombinable(base)) {			Graphics g = getGraphics();			g.setColor(Color.gray);			g.setXORMode(Color.white);			int width = (int)(contigDisplay.getAveragePeakDistance()*4);			g.drawRect(center-width/2,0,width,getBounds().height);			g.setPaintMode();		}	}	/*_________________________________________________*/	public void setCloseupPanel(boolean showCenterBase) {		if (closeupPanel!=null) {			if (!closeupPanel.getShowCenterBase() && closeupPanel.getChromatogram()!=null)				closeupPanel.setChromatogram(null);			closeupPanel.setShowCenterBase(showCenterBase);			Chromatogram chromatogram = closeupPanel.getChromatogram();			if (!chromatograms[SETREAD].equals(chromatogram)) {				BasicChromatogramPanel oldChromatogramPanel = contigDisplay.getChromatogramPanel(chromatogram);				//repaint previous one				closeupPanel.setChromatogram(chromatograms[SETREAD]);				if (oldChromatogramPanel!=null)					oldChromatogramPanel.repaint();				closeupPanel.centerPanelAtOverallPosition(centerBase);				chromatogramPanel.repaint();			}		}	}	int localFirstTouched = MesquiteInteger.unassigned;	/*----------------------------------------------------------------------------------*/	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		if (closeupPanel!=null && !closeupPanel.getShowSourceBase())			closeupPanel.setCloseupPanel(true, chromatograms[SETREAD], true);		//setCloseupPanel(true);		ChromatogramTool chromTool = (ChromatogramTool)tool;		int ic = findUniversalBaseNumber(SINGLEREAD,x); 		localFirstTouched = findConsensusBaseNumber(SINGLEREAD,x);		boolean onRequiredSelection = chromTool.getWorksOnlyOnSelection() && !getSelected(ic);		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels() &&!onRequiredSelection){			int cons = findConsensusBaseNumber(SINGLEREAD,x);			((ChromatogramTool)tool).touched(cons, cons, true, id, chromatogramPanel.getContigID(), modifiers);
			/*		MesquiteWindow w = chromatogramPanel.getMesquiteWindow();		if (w!=null)			w.showQuickMessage(chromatogramPanel,null,x,y,"testing");			 */
			return;		}		if (MesquiteEvent.shiftKeyDown(modifiers) && MesquiteEvent.commandOrControlKeyDown(modifiers)){				String traceHeights = chromatograms[SINGLEREAD].getTraceValuesStringAllRows(true);				MesquiteFile.putFileContentsQuery("Save chromatogram text details", traceHeights, true);		}		else if (MesquiteEvent.shiftKeyDown(modifiers)){			if (MesquiteInteger.isCombinable(ic)){				contigDisplay.setSecondTouchedOverall(ic);				chromatogramPanel.exportDeselectAll();				if (MesquiteInteger.isCombinable(contigDisplay.getFirstTouchedOverall())) {					if (contigDisplay.getFirstTouchedOverall()>ic){						for (int i = ic; i<=contigDisplay.getFirstTouchedOverall(); i++)							selectOverallBase(i);					}					else {						for (int i = contigDisplay.getFirstTouchedOverall(); i<=ic; i++)							selectOverallBase(i);					}				}				else {					selectOverallBase(ic);				}				//chromatogramPanel.synchTableToChrom(false);				contigDisplay.repaintPanels();			}		}		else if (MesquiteEvent.commandOrControlKeyDown(modifiers)){			if (MesquiteInteger.isCombinable(ic)){				selectOverallBase(ic);				contigDisplay.repaintPanels();			}		}		else {			if (MesquiteInteger.isCombinable(ic)){				if (closeupPanel!=null && closeupPanel.getShowSourceBase()) {					closeupPanel.setShowTouchedBase(true);					int readBaseNumber = reads[SINGLEREAD].getReadBaseFromContigBase(localFirstTouched);					closeupPanel.setReadBaseNumber(readBaseNumber);					closeupPanel.setCloseupPanel(true,chromatograms[SINGLEREAD], false);				}				contigDisplay.setFirstTouchedOverall(ic);				chromatogramPanel.exportDeselectAll();				selectOverallBase(ic);				if (clickCount>1)					contigDisplay.scrollToUniversalBase(ic);				contigDisplay.repaintPanels();			}		}	}	/*----------------------------------------------------------------------------------*/	public void mouseDrag (int modifiers, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		int ic = findUniversalBaseNumber(SINGLEREAD,x); 		boolean onRequiredSelection = chromTool.getWorksOnlyOnSelection() && !getSelected(ic);		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels() && !onRequiredSelection){			int cons = findConsensusBaseNumber(SINGLEREAD,x);			((ChromatogramTool)tool).dragged(cons, cons, true, id, chromatogramPanel.getContigID(), modifiers);			return;		}		if (MesquiteInteger.isCombinable(ic)){			//deselectAll(); //this isn't correct behaviour!  If shift down should remember previously sleected pieces			if (MesquiteInteger.isCombinable(contigDisplay.getFirstTouchedOverall())) {				if (contigDisplay.getFirstTouchedOverall()>ic){					if (MesquiteInteger.isCombinable(contigDisplay.getSecondTouchedOverall()) && contigDisplay.getSecondTouchedOverall()<contigDisplay.getFirstTouchedOverall() && ic>contigDisplay.getSecondTouchedOverall()){ //retracting						for (int i = contigDisplay.getSecondTouchedOverall(); i<=ic; i++) 							deselectOverallBase(SINGLEREAD,i);					}					else for (int i = ic; i<=contigDisplay.getFirstTouchedOverall(); i++) //adding						selectOverallBase(i);				}				else {					if (MesquiteInteger.isCombinable(contigDisplay.getSecondTouchedOverall()) && contigDisplay.getSecondTouchedOverall()>contigDisplay.getFirstTouchedOverall() && ic<contigDisplay.getSecondTouchedOverall()){ //retracting						for (int i = ic+1; i<=contigDisplay.getSecondTouchedOverall(); i++) 							deselectOverallBase(SINGLEREAD,i);					}					else for (int i = contigDisplay.getFirstTouchedOverall(); i<=ic; i++)						selectOverallBase(i);				}			}			else {				selectOverallBase(ic);			}			//chromatogramPanel.synchTableToChrom(false);			contigDisplay.repaintPanels();			contigDisplay.setSecondTouchedOverall(ic);		}	}	/*----------------------------------------------------------------------------------*/	/* to be used by subclasses to tell that panel touched */	public void mouseUp(int modifiers, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels()){			int cons = findConsensusBaseNumber(SINGLEREAD,x);			((ChromatogramTool)tool).dropped(cons, cons, true, id, chromatogramPanel.getContigID(), modifiers);			return;		}		if (MesquiteInteger.isCombinable(contigDisplay.getFirstTouchedOverall())){			if (!MesquiteInteger.isCombinable(contigDisplay.getSecondTouchedOverall()))				contigDisplay.focusMatrixOnUniversalBases(contigDisplay.getFirstTouchedOverall(), MesquiteInteger.unassigned);			else				contigDisplay.focusMatrixOnUniversalBases(contigDisplay.getFirstTouchedOverall(), contigDisplay.getSecondTouchedConsensus());		}		if (chromatogramPanel.getScrollToTouched()) {			int ic = findConsensusBaseNumber(SINGLEREAD,x);			if (ic>=0 && localFirstTouched == ic) {				contigDisplay.scrollToConsensusBase(ic);				//		panel.deselectAllReads();			}		}		contigDisplay.setSecondTouchedOverall(MesquiteInteger.unassigned);		if (closeupPanel!=null && closeupPanel.getShowSourceBase()) {			closeupPanel.setShowTouchedBase(false);			closeupPanel.setChromatogram(null);			contigDisplay.repaintPanels();		}	}	int prevReadBaseNumber = MesquiteInteger.unassigned;	int prevX = MesquiteInteger.unassigned;	/*_________________________________________________*/	public void mouseMoved(int modifiers, int x, int y, MesquiteTool tool) {		int ic = findConsensusBaseNumber(SINGLEREAD,x);		int readBaseNumber = reads[SINGLEREAD].getReadBaseFromContigBase(ic);		contigDisplay.getUniversalBaseFromContigBase(0);		int quality = reads[SINGLEREAD].getPhdBaseQuality(readBaseNumber);		double averageQuality = reads[SINGLEREAD].getAverageQuality();		int numBasesHighQuality = reads[SINGLEREAD].getNumBasesHighQuality();		String s = "";		if (quality>=0)			s+= "Base quality: " + quality + ",   Peak heights: " + getPeakHeightsOfBase(SINGLEREAD,readBaseNumber);		s+= "\n# Bases with Quality � " + reads[SINGLEREAD].getNumBasesHighQualityThreshold() + ": " + numBasesHighQuality + ",  Average Quality: " + averageQuality + "  ("+chromatograms[SINGLEREAD].getTitle()+")";		if (closeupPanel!=null && !closeupPanel.getShowCenterBase() && !closeupPanel.getShowSourceBase()){   // if option key is down, then switch closeup panel so shows mouse moved spot			closeupPanel.setChromatogram(chromatograms[SETREAD]);			if (readBaseNumber!=prevReadBaseNumber){				//				drawCloseupBox(prevX, prevReadBaseNumber);				closeupPanel.setReadBaseNumber(readBaseNumber);				//				drawCloseupBox(x, readBaseNumber);			}			prevReadBaseNumber = readBaseNumber;			prevX = x;			contigDisplay.repaintPanels();		} else if (closeupPanel!=null && closeupPanel.getShowSourceBase()) {			if (MesquiteEvent.optionKeyDown(modifiers)) {				closeupPanel.setShowTouchedBase(true);				closeupPanel.setReadBaseNumber(readBaseNumber);				closeupPanel.setCloseupPanel(true,chromatograms[SINGLEREAD], false);				contigDisplay.repaintPanels();			} else if (closeupPanel.getShowTouchedBase()) {				closeupPanel.setShowTouchedBase(false);				closeupPanel.setChromatogram(null);				contigDisplay.repaintPanels();			}		}		contigDisplay.setExplanation( s);		if (tool == null)			return;		ChromatogramTool chromTool = (ChromatogramTool)tool;		if (chromTool.getWorksOnlyOnSelection())			if (!getSelected(findUniversalBaseNumber(SINGLEREAD,x)))				setCursor(Cursor.getDefaultCursor());			else				setCurrentCursor(modifiers, x, y, chromTool);	}	/*...............................................................................................................*/	public void mouseExited(int modifiers, int x, int y, MesquiteTool tool) {		setCursor(Cursor.getDefaultCursor());		if (closeupPanel!=null && !closeupPanel.getShowCenterBase()&& !closeupPanel.getShowSourceBase()){			closeupPanel.setChromatogram(null);			closeupPanel.setReadBaseNumber(MesquiteInteger.unassigned);			prevReadBaseNumber = MesquiteInteger.unassigned;			prevX = MesquiteInteger.unassigned;		}		/*		if (closeupPanel!=null){			closeupPanel.setChromatogram(null);			closeupPanel.setReadBaseNumber(MesquiteInteger.unassigned);			prevReadBaseNumber = MesquiteInteger.unassigned;			prevX = MesquiteInteger.unassigned;		}		 */	}	/*...............................................................................................................*/	public void mouseEntered(int modifiers, int x, int y, MesquiteTool tool) {		if (tool == null)			return;		setCurrentCursor(modifiers, x, y, (ChromatogramTool)tool);	}}