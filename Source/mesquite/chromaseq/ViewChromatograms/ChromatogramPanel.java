/* Mesquite chromaseq source code.  Copyright 2005-2007 D. Maddison and W. Maddison.Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.ViewChromatograms; import java.awt.*;import mesquite.align.lib.*;import mesquite.chromaseq.lib.*;import mesquite.lib.*;import mesquite.categ.lib.*;class ChromatogramPanel extends MesquitePanel {	ChromatogramCanvas chromArea;	Chromatogram chromatogram;	int centerBase = 0;	int centerPixel = 0;	ContigDisplay panel;	int width = 0;	int height = 0;		static final boolean THICKTRACEDEFAULT = true;	static final boolean SHOWREADMATRIXCONFLICTDEFAULT = false;		boolean colorByQuality = true;	boolean fadeLowQuality = false;	boolean showFades = true;	boolean fadeNonSourceRead = false;	boolean fadeNonSourceLowerQualityRead = true;	int fadeQualityThreshold = 30;	boolean showReadName = true;	boolean thickTrace = THICKTRACEDEFAULT;	boolean showBaseNumberWithinRead = true;	boolean showReadMatrixConflict = SHOWREADMATRIXCONFLICTDEFAULT;	boolean showA = true;	boolean showC = true;	boolean showG = true;	boolean showT = true;	boolean scrollToTouched = false;	boolean showBaseSource = true;	boolean showCodonPosition = false;		int id;	int contigID;	int conflictLevelThreshold = 30;	boolean dimLowQualityConflicts = true;	boolean showMagPanel = false;	PairwiseAligner primerAligner;	String[] primerSequence = null; //primer	String[] primerNames = null; //primer	long[][][][] primerAlignment = null; //primer orientation site whichSequence	int[][][] primerMatch; //primer orientation position	int[][] lastPrimerDraw;  //primer orientation	boolean[][] showPrimer;	int numPrimers;	String[] orientName = new String[] {"", "(C)", " (R)", " (RC)"};	boolean useReadNameforPrimerName = true;	boolean ignorePrimerUsedForRead=true;	boolean showOnlySpecifiedPrimersForEachRead=false;	final static int READ=0;	final static int PRIMER=1;//	boolean showSingleSpecifiedPrimer= true;	public ChromatogramPanel(Chromatogram myChrom, ContigDisplay panel, int id, int contigID) {		super();		this.id = id;  // this is the read number		this.contigID = contigID;  //this is the taxon number or other id for contig		this.panel = panel;		addKeyListener(panel);		chromatogram = myChrom;		chromatogram.setWindow(panel);		chromArea = new ChromatogramCanvas(this, id);		//this.setLayout(new BorderLayout(0,0));		chromArea.setBounds(0, 0, getWidth(), getHeight());		this.add("Center",chromArea);		if (chromatogram.getRead().getComplemented()) 			setBackground(ColorDistribution.veryVeryLightGray);		else			setBackground(Color.white);	}	/*.................................................................................................................*/	private boolean primerOKToShow(long[][] alignment, double permittedMismatch){		int mismatches = 0;		int matches = 0;		for (int i = 0; i<alignment.length; i++){			if (alignment[i][READ] != CategoricalState.inapplicable && alignment[i][PRIMER] != CategoricalState.inapplicable ){				if (!CategoricalState.statesShared(alignment[i][READ] , alignment[i][1]))					mismatches++;				else					matches++;			}		}		return mismatches * 1.0 / (matches + mismatches) <= permittedMismatch;	}	/*.................................................................................................................*/	private boolean primerOKToShowBasedOnEndOfPrimer(long[][] alignment, boolean isReversed){		int mismatches = 0;		int matches = 0;		int primerBases = 0;		if (isReversed) {			for (int i = 0; i<alignment.length; i++){   // count from start				if (alignment[i][PRIMER] != CategoricalState.inapplicable ){					primerBases ++;				}				if (alignment[i][PRIMER] != CategoricalState.inapplicable)					if (!CategoricalState.statesShared(alignment[i][READ] , alignment[i][PRIMER]) )  //mismatch, and the primer has a base here						mismatches++;					else if (alignment[i][READ] != CategoricalState.inapplicable )						matches++;				if (primerBases>=5 && mismatches==0)					return true;				if (primerBases>=7 && mismatches<=1)					return true;				if (primerBases>=10 && mismatches<=2)					return true;				if (primerBases>=14 && mismatches<=3)					return true;			}		}		else {			for (int i = alignment.length-1; i>=0; i--){  // count from end				if (alignment[i][PRIMER] != CategoricalState.inapplicable ){					primerBases++;				}				if (alignment[i][PRIMER] != CategoricalState.inapplicable)					if (!CategoricalState.statesShared(alignment[i][READ] , alignment[i][PRIMER]) )  //mismatch, and the primer has a base here						mismatches++;					else if (alignment[i][READ] != CategoricalState.inapplicable )						matches++;				if (primerBases>=5 && mismatches==0)					return true;				if (primerBases>=7 && mismatches<=1)					return true;				if (primerBases>=10 && mismatches<=2)					return true;				if (primerBases>=14 && mismatches<=3)					return true;			}		}		return false;	}	/*.................................................................................................................*/	public void setUpPrimers(){		Contig contig = panel.getContig();		ListableVector v = new ListableVector();		if (showOnlySpecifiedPrimersForEachRead || panel.getShowSinglePrimerMatch()) {			v.addElement(new Primer(getPrimerToShow()), false);		} 		else {			String s = contig.getRead(0).getPrimerName();			boolean primerNamesStored = ! StringUtil.blank(s);			for (int i = 0; i< contig.getNumReadsToShow(); i++){				if (primerNamesStored)					s = contig.getRead(i).getPrimerName();				else if (useReadNameforPrimerName) {  // we need to parse the chromatogram name					s = contig.getRead(i).getName();					s = StringUtil.getAllButLastItem(s, ".");					s = StringUtil.getLastItem(s, ".");				}				if (!v.nameAlreadyInList(s))					v.addElement(new Primer(s), false);			}		}		numPrimers = v.size();		primerSequence = new String[numPrimers];		primerNames = new String[numPrimers];		primerAlignment = new long[numPrimers][4][][];		primerMatch = new int[numPrimers][4][];		lastPrimerDraw = new int[numPrimers][4];		showPrimer = new boolean[numPrimers][4];		int alphabetLength = 4;		int subs[][] = AlignUtil.getDefaultSubstitutionCosts(alphabetLength);  		primerAligner = new PairwiseAligner (true, subs, 40, 20,  5, 5, alphabetLength);		String[][] primerSequences = panel.getPrimerSequences();		for(int primer = 0; primer < numPrimers; primer++){			primerNames[primer] = v.nameOfElementAt(primer);			setUpPrimer(primer, primerSequences);		}	}	private void setUpPrimer(int primer, String[][] primerSequences){		boolean doRevPrimer = false;  // search for reverse of primer		boolean doCompPrimer = false;  // search for complement of primer				String title = primerNames[primer];		if (ignorePrimerUsedForRead && title != null && title.equalsIgnoreCase(getPrimerName()))			return;		if (!StringUtil.blank(title)){						if (primerSequences == null)				return;			boolean found = false;			//find primer that this corresponds to			for (int i= 0; i<primerSequences.length; i++){				if (title.equalsIgnoreCase(primerSequences[i][0])){					primerSequence[primer] = primerSequences[i][1];					primerSequence[primer] = DNAData.collapseSymbol(primerSequence[primer], '*');					primerSequence[primer] = DNAData.collapseSymbol(primerSequence[primer], '-');					found = true;					break;				}			}			if (!found)				MesquiteMessage.warnProgrammer("Primer not found in primer list: " + title);		}		if (!StringUtil.blank(primerSequence[primer])){			try {				//getting long[] version of this sequence				String sequenceString = chromatogram.getRead().getSequence();				sequenceString = cleanSequenceString(sequenceString);				boolean verbose = false;				if (verbose) Debugg.println("sequencesString length " + sequenceString.length());							long[] readSequence = DNAData.convertTerminalMissingToGaps(DNAData.sequenceLongsFromString(sequenceString));								if (verbose) Debugg.println("readSequence length " + readSequence.length);							//getting long versions of the primer sequence				long[] asIs = DNAData.sequenceLongsFromString(primerSequence[primer], sequenceString.length());				if (verbose) Debugg.println("asIs length " + asIs.length);							String complement = DNAData.complementString(primerSequence[primer]);				long[] comp=null;				if (doCompPrimer)					comp = DNAData.sequenceLongsFromString(complement, sequenceString.length());				if (verbose) Debugg.println("comp length " + comp.length);							long[] rev =null;				if (doRevPrimer)					rev= DNAData.sequenceLongsFromString(DNAData.reverseString(primerSequence[primer]), sequenceString.length());				long[] revComp = DNAData.sequenceLongsFromString(DNAData.reverseString(complement), sequenceString.length());				if (verbose){					Debugg.println("@@@@@@@@@@@@@@@@@ " + chromatogram.getTitle());					Debugg.println("primer [" + DNAData.sequenceStringFromLongs(asIs) + "]");					if (doCompPrimer)						Debugg.println("comp " + DNAData.sequenceStringFromLongs(comp));					if (doRevPrimer)						Debugg.println("rev " + DNAData.sequenceStringFromLongs(rev));					Debugg.println("revComp " + DNAData.sequenceStringFromLongs(revComp));					Debugg.println("READunalligned [" + DNAData.sequenceStringFromLongs(readSequence, false) + "]");				}				MesquiteNumber scoreAsIs = new MesquiteNumber();				MesquiteNumber scoreComp = new MesquiteNumber();				MesquiteNumber scoreRev = new MesquiteNumber();				MesquiteNumber scoreRevComp = new MesquiteNumber();				MesquiteNumber bestScore;				int chosen = 0;				for (int i = 0; i<4; i++) {					showPrimer[primer][i]=false;					primerAlignment[primer][i] = new long[0][0];				}//				OK, let's first try aligning the primer to the sequence				primerAlignment[primer][0] = primerAligner.alignSequences( readSequence, asIs, true, scoreAsIs);				showPrimer[primer][0] = primerOKToShow(primerAlignment[primer][0], 0.2);				if (!showPrimer[primer][0])					showPrimer[primer][0] = primerOKToShowBasedOnEndOfPrimer(primerAlignment[primer][0], false);				bestScore = scoreAsIs;				int min = (sequenceString.length() - primerSequence[primer].length())*2;				if (verbose) Debugg.println("$$$$$$$$ seq len " + sequenceString.length() + " primer " + primerSequence[primer].length() + " min " + min);				if (verbose) Debugg.println("ASIS &&&&&&&&&&&&&&&&" + scoreAsIs);				if (verbose) Debugg.println("PRIMER " + DNAData.sequenceStringFromLongs(asIs));				if (verbose) printPrimerAlignment(primerAlignment[primer][0]);//				Now let's try aligning the complement of the primer to the sequence				long[][] align = null;				if (doCompPrimer) {					align = primerAligner.alignSequences( readSequence, comp, true, scoreComp);					if (verbose) Debugg.println("comp &&&&&&&&&&&&&&&&" + scoreComp);					if (verbose) Debugg.println("PRIMER " + DNAData.sequenceStringFromLongs(comp));					if (verbose) printPrimerAlignment(align);					primerAlignment[primer][1] = align;					showPrimer[primer][1] = primerOKToShow(align, 0.2);					if (!showPrimer[primer][1])						showPrimer[primer][1] = primerOKToShowBasedOnEndOfPrimer(align, true);					if (scoreComp.isLessThan(bestScore)){						bestScore = scoreComp;						chosen = 1;					}				}//				Aligning the reverse of the primer to the sequence				if (doRevPrimer) {					align = primerAligner.alignSequences( readSequence, rev, true, scoreRev);					if (verbose) Debugg.println("rev &&&&&&&&&&&&&&&&" + scoreRev);					if (verbose) Debugg.println("PRIMER " + DNAData.sequenceStringFromLongs(rev));					if (verbose) printPrimerAlignment(align);					primerAlignment[primer][2] = align;					showPrimer[primer][2] = primerOKToShow(align, 0.2);					if (!showPrimer[primer][2])						showPrimer[primer][2] = primerOKToShowBasedOnEndOfPrimer(align, false);					if (scoreRev.isLessThan(bestScore)){						bestScore = scoreRev;						chosen = 2;					}				}//				Aligning the reverse complement of the primer to the sequence				align = primerAligner.alignSequences( readSequence, revComp, true, scoreRevComp);				if (verbose) Debugg.println("revComp &&&&&&&&&&&&&&&&" + scoreRevComp);				if (verbose) Debugg.println("PRIMER " + DNAData.sequenceStringFromLongs(revComp));				if (verbose) printPrimerAlignment(align);				primerAlignment[primer][3] = align;				showPrimer[primer][3] = primerOKToShow(align, 0.2);				if (!showPrimer[primer][3])					showPrimer[primer][3] = primerOKToShowBasedOnEndOfPrimer(align, true);				if (scoreRevComp.isLessThan(bestScore)){					bestScore = scoreRevComp;					chosen = 3;				}//				Now we are done testing out the alignments				if (!showPrimer[primer][chosen]){					showPrimer[primer][chosen] = primerOKToShow(align, 0.33);					if (!showPrimer[primer][chosen])						for (int i = 0; i<4; i++)							if (showPrimer[primer][i]) {								chosen=i;								break;							}				}				MesquiteMessage.println("Primer (" + title + ") found to align with read " + chromatogram.getTitle() + ": " + primerSequence[primer]);				if (verbose) Debugg.println("CHOSEN == " + chosen);				if (verbose) printPrimerAlignment(primerAlignment[primer][chosen]);				primerMatch[primer] = new int[4][];				for (int orientation = 0; orientation < 4; orientation++) {					primerMatch[primer][orientation] = new int[primerAlignment[primer][orientation].length];					if (verbose) Debugg.println("orient " + orientation + "   lengthA " + primerMatch[primer][orientation].length);				}				for (int k = 0; k<4; k++)					for (int i=0; i< primerMatch[primer][k].length; i++)						primerMatch[primer][k][i] = -1;				if (verbose) System.out.println(">>>>>>>>>>>");				for (int orientation=0; orientation<4; orientation++){					int siteCount = -1;					int primerCount = -1;					boolean foundPrimer = false;					int startOfPrimer = -1;					for (int i=0; i<primerAlignment[primer][orientation].length; i++){						if (primerAlignment[primer][orientation][i][1] != MolecularState.inapplicable) {//primer has something 							primerCount++;							if (!foundPrimer)								startOfPrimer= i;							foundPrimer=true;						}						if (primerAlignment[primer][orientation][i][0] != MolecularState.inapplicable){ //sequence has something							siteCount++;							if (primerAlignment[primer][orientation][i][1]!= MolecularState.inapplicable){ // primer and sequence both have something//								Debugg.println("lengthB " + siteCount);								primerMatch[primer][orientation][siteCount] = i;								if (verbose) System.out.print("-" + siteCount);							}						}					}//Debugg.println("primer: " + title + ", orientation: " + orientation + "(" + chosen + "), primerCount: " + primerCount + ", siteCount: " + siteCount+ ", startOfPrimer: " + startOfPrimer);//Debugg.println("            showPrimer[primer][orientation]: " + showPrimer[primer][orientation]);				}				if (verbose) System.out.println("<<<<<<<<<<<<<<<");			}			catch (Exception e){				for (int orientation = 0; orientation<4; orientation++){					primerMatch[primer][orientation] = null;					primerAlignment[primer][orientation] = null;				}				MesquiteMessage.warnProgrammer("Exception thrown in primer alignment");				e.printStackTrace();			}		}	}	int[] primerAlignedSeqToOrigSeq;	private String cleanSequenceString( String seq){		primerAlignedSeqToOrigSeq = new int[seq.length()];		for (int i = 0; i < seq.length(); i++) 			primerAlignedSeqToOrigSeq[i] = -1;		StringBuffer s = new StringBuffer(seq.length());		String badString = "-N?*\r\n\t";		int count = -1;		for (int i = 0; i < seq.length(); i++) {			if (badString.indexOf(seq.charAt(i))<0){				count++;				s.append(seq.charAt(i));				primerAlignedSeqToOrigSeq[i] = count;			}		}		return s.toString();	}	private void printPrimerAlignment(long[][] alignment){		String sP = "";		String sR = "";		for (int i= 0; i<alignment.length; i++){			sP += DNAState.toCharStatic(alignment[i][1]);			sR += DNAState.toCharStatic(alignment[i][0]);		}		Debugg.println("AlignedPRIM " + sP);		Debugg.println("AlignedREAD " + sR);	}	public boolean isShownReversed(){		return panel.isShownReversed();	}	public boolean isShownComplemented(){		return panel.isShownComplemented();	}	public int getWidth() {		if (showMagPanel)			return getBounds().width-100;		else			return getBounds().width;	}	public int getHeight() {		return getBounds().height;	}	boolean listen = true;	//uses index in consensus; this viewer must translate to index in the read	public boolean selectConsensusPositionInChrom(int i, boolean sel, boolean repaint){		if (!listen)			return false;		if (chromArea != null)			return chromArea.setSelectedInChrom(panel.getOverallBaseFromConsensusBase(i), sel, repaint);		return false;	}	//this is consensus position	public void exportSelectConsensusPosition(int i){		listen = false;		panel.selectConsensusPositionInTable(i);		panel.setSelectedConsensusPositionInChrom(i, true, true);		listen = true;	}	//this is consensus position	public void exportDeselectConsensusPosition(int i){		listen = false;		panel.deselectConsensusPositionInTable(i);		panel.setSelectedConsensusPositionInChrom(i, false, true);		listen = true;	}	public void exportDeselectAll(){		listen = false;		panel.deselectAllInTable();		panel.deselectAllInPanels();		listen = true;	}	public void deselectAllChrom(int overallBase){		panel.deselectAllChrom(overallBase);	}	public void deselectAll(){		chromArea.deselectAll();	}	public void deselectAll(int overallBase){		chromArea.setSelected(overallBase,false);	}	public void synchChromToTable(boolean synchPosition){		panel.synchChromToTable(synchPosition);	}	public void synchTableToChrom(boolean synchPosition){		panel.synchTableToChrom(synchPosition);	}	public void repaintPanel(){		if (chromArea != null ) {			chromArea.repaint();		}	}	public void setMagnification(double mag){		if (chromArea != null ) {			chromArea.setMagnification(mag);		}	}	public Dimension minimumSize() {		return new Dimension(100,100);	}	/*.................................................................................................................*/	public Read getRead() {		if (chromatogram==null)			return null;		return chromatogram.getRead();	}	/*.................................................................................................................*/	public String getPrimerName() {		Read read = getRead();		if (read==null)			return null;		return read.getPrimerName();	}	/*.................................................................................................................*/	public String getPrimerToShow() {		if (panel.getShowSinglePrimerMatch()) {			return panel.getSinglePrimer();		} 		else {			Read read = getRead();			if (read==null)				return null;			return read.getPrimerToShow();		}	}	/*.................................................................................................................*/	public Contig getContig() {		return panel.getContig();	}	/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		this.fadeQualityThreshold = fadeQualityThreshold;	}	/*.................................................................................................................*/	public int getFadeQualityThreshold() {		return fadeQualityThreshold;	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		this.showBaseNumberWithinRead = showBaseNumberWithinRead;	}	/*.................................................................................................................*/	public boolean getShowBaseNumberWithinRead() {		return showBaseNumberWithinRead;	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		this.showReadName = showReadName;	}	/*.................................................................................................................*/	public boolean getShowReadName() {		return showReadName;	}	/*.................................................................................................................*/	public void setThickTrace(boolean thickTrace) {		this.thickTrace = thickTrace;	}	/*.................................................................................................................*/	public boolean getThickTrace() {		return thickTrace;	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean showReadMatrixConflict) {		this.showReadMatrixConflict = showReadMatrixConflict;	}	/*.................................................................................................................*/	public boolean getShowReadMatrixConflict() {		return showReadMatrixConflict;	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		this.fadeNonSourceRead = fadeNonSourceRead;	}	/*.................................................................................................................*/	public boolean getFadeNonSourceRead() {		return fadeNonSourceRead;	}	/*.................................................................................................................*/	public void setFadeNonSourceLowerQualityRead(boolean fadeNonSourceLowerQualityRead) {		this.fadeNonSourceLowerQualityRead = fadeNonSourceLowerQualityRead;	}	/*.................................................................................................................*/	public boolean getFadeNonSourceLowerQualityRead() {		return fadeNonSourceLowerQualityRead;	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		this.fadeLowQuality = fadeLowQuality;	}	/*.................................................................................................................*/	public boolean getShowFades() {		return showFades;	}	/*.................................................................................................................*/	public void setShowFades(boolean showFades) {		this.showFades = showFades;	}	/*.................................................................................................................*/	public boolean getFadeLowQuality() {		return fadeLowQuality;	}	/*.................................................................................................................*/	public  void setDimConflictMarkerThreshold (int conflictLevelThreshold){		this.conflictLevelThreshold = conflictLevelThreshold;	}	/*.................................................................................................................*/	public  int getDimConflictMarkerThreshold (){		return conflictLevelThreshold;	}	/*.................................................................................................................*/	public  void setDimLowQualityConflicts (boolean dimLowQualityConflicts){		this.dimLowQualityConflicts = dimLowQualityConflicts;	}	/*.................................................................................................................*/	public  boolean getDimLowQualityConflicts (){		return dimLowQualityConflicts;	}	/*.................................................................................................................*/	public void setColorByQuality(boolean colorByQuality) {		this.colorByQuality = colorByQuality;	}	/*.................................................................................................................*/	public boolean getColorByQuality() {		return colorByQuality;	}	/*.................................................................................................................*/	public void setShowA(boolean showA) {		this.showA = showA;	}	/*.................................................................................................................*/	public boolean getShowA() {		return showA;	}	/*.................................................................................................................*/	public void setShowC(boolean showC) {		this.showC = showC;	}	/*.................................................................................................................*/	public boolean getShowC() {		return showC;	}	/*.................................................................................................................*/	public void setShowG(boolean showG) {		this.showG = showG;	}	/*.................................................................................................................*/	public boolean getShowG() {		return showG;	}	/*.................................................................................................................*/	public void setShowT(boolean showT) {		this.showT = showT;	}	/*.................................................................................................................*/	public boolean getShowT() {		return showT;	}	/*.................................................................................................................*/	public void setShowCodonPosition(boolean showCodonPosition) {		this.showCodonPosition= showCodonPosition;	}	/*.................................................................................................................*/	public boolean getShowCodonPosition() {		return showCodonPosition;	}	/*.................................................................................................................*/	public void setScrollToTouched(boolean scrollToTouched) {		this.scrollToTouched = scrollToTouched;	}	/*.................................................................................................................*/	public boolean getScrollToTouched() {		return scrollToTouched;	}	public boolean getShowBaseSource() {		return showBaseSource;	}	public void setShowBaseSource(boolean showBaseSource) {		this.showBaseSource = showBaseSource;	}	public void centerPanelAtOverallPosition(int i){		centerBase = i;		chromArea.repaint();	}	public boolean getSelected(int overallBase) {		return chromArea.getSelected(overallBase);	}	public  void setBounds(int x, int y, int width, int height) {		super.setBounds(x,y,width,height);		this.width = width;		this.height = height;		chromArea.setBounds(0, 0, getWidth(), getHeight());		chromArea.repaint();	}	public  void setSize( int width, int height) {		super.setSize(width,height);		this.width = width;		this.height = height;		chromArea.setBounds(0, 0, getWidth(), getHeight());		chromArea.repaint();	}}class ChromatogramCanvas extends MousePanel {	ChromatogramPanel chromatogramPanel;	ContigDisplay panel;	Chromatogram chromatogram; 	Read read;	int[] A,C,G,T;	int maxValue;	int centerPixel;	int leftPixel;	int centerBase;	boolean blackBackground=false;	private boolean[] selected;  // uses local read as index	int id;	static final double NONSOURCEDIMFRACTION = 0.2;	static final double NONSOURCELOWERQUALITYDIMFRACTION = 0.15;	/*..........................*/	public ChromatogramCanvas(ChromatogramPanel parentV, int id) {		super();		this.id = id;		chromatogramPanel = parentV;		panel = chromatogramPanel.panel;		addKeyListener(panel);		chromatogram = parentV.chromatogram;//		setBackground(Color.white);		read = chromatogram.getRead();		if (read.getComplemented()) 			setBackground(ColorDistribution.veryVeryLightGray);		A = chromatogram.getATrace();		C = chromatogram.getCTrace();		G = chromatogram.getGTrace();		T = chromatogram.getTTrace();		int i;		maxValue = 0;		selected = new boolean[panel.getTotalNumPeaks()];   // uses local read as index		for (i=0;i<panel.getTotalNumPeaks();i++) {			selected[i] = false;		}		for (i=0;i<chromatogram.getTraceLength();i++) {			if (A[i] > maxValue) maxValue = A[i];			if (C[i] > maxValue) maxValue = C[i];			if (G[i] > maxValue) maxValue = G[i];			if (T[i] > maxValue) maxValue = T[i];		}	}	public boolean isShownReversed(){		return panel.isShownReversed();	}	public boolean isShownComplemented(){		return panel.isShownComplemented();	}	/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point *	public int OLDfindConsensusPosition(int xPixel){ //this needs to return consensus position!		reCalcCenterBase();		for (int i=0;i < chromatogram.getBaseNumber();i++) {			if (xPixel < chromatogram.getReadBaseLocationAligned(i) - leftPixel - 5)				return getConsensusBaseFromReadBase(i-1);		}		if (xPixel < chromatogram.getReadBaseLocationAligned(chromatogram.getBaseNumber()-1) - leftPixel - 5+30)			return getConsensusBaseFromReadBase(chromatogram.getBaseNumber()-1);		return -1;	}	/*...........................................................................*/	private void reCalcCenterBase(){		centerBase = chromatogramPanel.centerBase;   //number of centered base		centerPixel = panel.getCenterPixelFromCenterBase(centerBase);   //number of pixels over this scrolled base is		leftPixel=centerPixel-getBounds().width/2;	}	double magnification = 1.0;	public void setMagnification(double mag){		this.magnification = mag;		repaint();	}	/*...........................................................................*/	public int leftEdgeOfConsensusBase(Graphics g, int i) {			return 0;	}	/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point. This is not the overall consensus position, zero-based,	 * but instead the position from the start of the main contig. Thus,  positions to the left of the main contig are -ve */	public int findOverallBaseNumber(int xPixel){ //this needs to return consensus position!		int cons = findConsensusBaseNumber(xPixel);		int overall = panel.getOverallBaseFromConsensusBase(cons);		return overall;	}	/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point. This is not the overall consensus position, zero-based,	 * but instead the position from the start of the main contig. Thus,  positions to the left of the main contig are -ve *	public int OLDfindConsensusBaseNumber(int xPixel){ //this needs to return consensus position!		//David: 		/* this isn't finding the consensus base number properly in the first read of lapsiines.nex.  Click to awar from the midline on the	 * read, and it will select too far away from the midline	 *		Graphics g = getGraphics();		Font f = null;		if (g != null)			f = g.getFont();		reCalcCenterBase();		//int firstReadLocation = (chromatogram.getReadBaseLocation(getReadBaseFromConsensusBase(centerBase-panel.getContig().getReadExcessAtStart()))-getBounds().width/2);		int firstReadLocation = getFirstReadLocation();		int offsetForInserted = 0;		for (int i=0;i < chromatogram.getBaseNumber();i++) {			int cmid = 10;			int consensusBase = getConsensusBaseFromReadBase(i);			offsetForInserted += panel.getSpaceInsertedBeforeConsensusBase(consensusBase);			if (f != null)				cmid = getFontMetrics(f).charWidth(chromatogram.getBase(i)) / 2;			if (xPixel < chromatogram.getReadBaseLocation(i) - firstReadLocation - cmid + offsetForInserted) {				int cons = getConsensusBaseFromReadBase(i-1);//Debugg.println("findConsensusPosition i  " + i  + chromatogram.getBase(i) + "  " + cons);				return cons;			}		}		if (xPixel < chromatogram.getReadBaseLocation(chromatogram.getBaseNumber()-1) - firstReadLocation - leftPixel - 5+30)			return getConsensusBaseFromReadBase(chromatogram.getBaseNumber()-1);		return -panel.getOverallBaseFromConsensusBase(0)-1;	}	/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point. This is not the overall consensus position, zero-based,	 * but instead the position from the start of the main contig. Thus,  positions to the left of the main contig are -ve */	public int findConsensusBaseNumber(int xPixel){ //this needs to return consensus position!		reCalcCenterBase();		int cwidth = getBounds().width;		int halfPeaks = panel.getApproximateNumberOfPeaksVisible()/2;		int centerConsensusBase = centerBase-panel.getContig().getReadExcessAtStart();		int centerReadBase = getReadBaseFromConsensusBase(centerConsensusBase);		int firstReadBase = centerReadBase - halfPeaks;		int lastReadBase = centerReadBase+halfPeaks;		int firstReadLocation = getPhdLocation(read, cwidth, centerReadBase,panel,true) - cwidth/2;		int count = 0;		while (getPhdLocation(read, cwidth, firstReadBase,panel,true)  - firstReadLocation >0 && firstReadLocation>0 && count++<200)			firstReadBase--; //correcting for error in numpeaksvisible for this read		count = 0;		while (getPhdLocation(read, cwidth, lastReadBase,panel,true)  - firstReadLocation <cwidth && count++<200)			lastReadBase++; //correcting for error in numpeaksvisible for this read		firstReadBase--;		lastReadBase++;		return findConsensusBaseNumber(xPixel, firstReadBase, lastReadBase, firstReadLocation);	}	/*...........................................................................*/	/** Given a pixel offset from left, returns the consensus position at that point. This is not the overall consensus position, zero-based,	 * but instead the position from the start of the main contig. Thus,  positions to the left of the main contig are -ve */	public int findConsensusBaseNumber(int xPixel, int firstReadBase, int lastReadBase, int firstReadLocation){ //this needs to return consensus position!		Graphics g = getGraphics();		Font f = null;		if (g != null)			f = g.getFont();		FontMetrics fm = null;		if (f != null)			fm = getFontMetrics(f);		int offsetForInserted = 0;		int cwidth = getBounds().width;		if (isShownReversed()) {			xPixel = cwidth - xPixel;			for (int i=firstReadBase;i < chromatogram.getBaseNumber() && i<=lastReadBase;i++) {				if (i>=0 && i<read.getBasesLength()) {					int consensusBase = getConsensusBaseFromReadBase(i);					int space = panel.getSpaceInsertedBeforeConsensusBase(consensusBase);					offsetForInserted += space;					int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);					int cmid = 10;					if (fm != null)						cmid = fm.charWidth(chromatogram.getBase(i)) / 2;					int w = 0;					if (i+1< chromatogram.getBaseNumber())						//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;						w = getPhdLocation(read, cwidth, i+1, panel,true) - getPhdLocation(read, cwidth, i, panel,true) + 1;					else						w =  (int)panel.getAveragePeakDistance();					int h = getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted;					/*if (reversed){						w = cwidth-w;						h = cwidth-h;				}*/					if (xPixel >= h && xPixel < h + w) {						int cons = getConsensusBaseFromReadBase(i);						return cons;					}					if (xPixel < h + w){						int cons = getConsensusBaseFromReadBase(i);						if (cons>=0 && MesquiteInteger.isCombinable(cons))							return cons;						return MesquiteInteger.unassigned;					}				}			}		}		else			for (int i=firstReadBase;i < chromatogram.getBaseNumber() && i<=lastReadBase;i++) {				if (i>=0 && i<read.getBasesLength()) {					int consensusBase = getConsensusBaseFromReadBase(i);					int space = panel.getSpaceInsertedBeforeConsensusBase(consensusBase);					offsetForInserted += space;					int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);					int cmid = 10;					if (fm != null)						cmid = fm.charWidth(chromatogram.getBase(i)) / 2;					int w = 0;					if (i+1< chromatogram.getBaseNumber())						//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;						w = getPhdLocation(read, cwidth, i+1, panel,true) - getPhdLocation(read, cwidth, i, panel,true) + 1;					else						w =  (int)panel.getAveragePeakDistance();					int h = getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted;					/*if (reversed){					w = cwidth-w;					h = cwidth-h;			}*/					if (xPixel >= h && xPixel < h + w) {						int cons = getConsensusBaseFromReadBase(i);						return cons;					}					if (xPixel < h + w){						int cons = getConsensusBaseFromReadBase(i);						//	Debugg.println("xPixel " + xPixel + " cons " + cons);						return MesquiteInteger.unassigned;					}				}			}		if (xPixel < chromatogram.getReadBaseLocation(chromatogram.getBaseNumber()-1) - firstReadLocation - leftPixel - 5+30)			return getConsensusBaseFromReadBase(chromatogram.getBaseNumber()-1);		return -panel.getOverallBaseFromConsensusBase(0)-1;	}	private void fillRect(Graphics g, int width, int x, int y, int w, int h){		if (isShownReversed()){			g.fillRect(width-(x+w), y, w, h);		}		else {			g.fillRect(x, y, w, h);		}	}	private void drawRect(Graphics g, int width, int x, int y, int w, int h){		if (isShownReversed()){			g.drawRect(width-(x+w), y, w, h);		}		else {			g.drawRect(x, y, w, h);		}	}	private void drawLine(Graphics g, int width, int x, int y, int x2, int y2){		if (isShownReversed()){			g.drawLine(width-x, y, width-x2, y2);			if (chromatogramPanel.getThickTrace())				g.drawLine(width-x, y-1, width-x2, y2-1);		}		else {			g.drawLine(x, y, x2, y2);			if (chromatogramPanel.getThickTrace())				g.drawLine(x+1, y, x2+1, y2);		}	}	private void drawString(Graphics g, int width, String s, int x, int y){		if (isShownReversed()){			int sw = StringUtil.getStringDrawLength(g, s);			g.drawString(s, width-(x+sw), y);		}		else {			g.drawString(s, x, y);		}	}	private int getPhdLocation(Read read, int width, int center, ContigDisplay panel, boolean calcAverageIfZero){		return read.getPhdLocation(center,panel,calcAverageIfZero);	}	/*...........................................................................*/	public void paint(Graphics g) {			Read read = chromatogram.getRead();		int cheight = getBounds().height;		int shadowHeight = 5;		int labelHeight = 18;		int labelBottom = cheight-shadowHeight;		int labelTop = labelBottom-labelHeight+1;		int cwidth = getBounds().width;		double scale = 1.0*maxValue / cheight / magnification;		int halfPeaks = panel.getApproximateNumberOfPeaksVisible()/2;		setBackground(panel.getBackgroundColor());	//	else	//		setBackground(Color.gray);		reCalcCenterBase();		int centerConsensusBase = centerBase-panel.getContig().getReadExcessAtStart();		int centerReadBase = getReadBaseFromConsensusBase(centerConsensusBase);		int firstReadBase = centerReadBase - halfPeaks;		int lastReadBase = centerReadBase+halfPeaks;		int firstReadLocation = getPhdLocation(read, cwidth, centerReadBase,panel,true) - cwidth/2;		/*David: here a correction is introduced to discover what is actually the first and last read bases visible.  Previously		these bases were calcualted incorrectly if some reads were effectively compressed, and thus drawing didn't go all the way to the edges		A similar problem of compression was affecting findConsensusBaseNumber, hence some of this code is repeated there.		 */		int count = 0;		while (getPhdLocation(read, cwidth, firstReadBase,panel,true)  - firstReadLocation >0 && firstReadLocation>0 && count++<200)			firstReadBase--; //correcting for error in numpeaksvisible for this read		count = 0;		while (getPhdLocation(read, cwidth, lastReadBase,panel,true)  - firstReadLocation <cwidth && count++<200)			lastReadBase++; //correcting for error in numpeaksvisible for this read		firstReadBase--;		lastReadBase++;		int i;		double fadeMax = 0.5;		int offsetForInserted = 0;//		Now to show the read-matrix conflict marker		if (MesquiteWindow.Java2Davailable){			int firstSel = MesquiteInteger.unassigned;			ColorDistribution.setTransparentGraphics(g);					int cmid = 0;			for (i=firstReadBase-1; i<=lastReadBase+1;i++) {				if (i>=0 && i<read.getBasesLength()) {					int consensusBase = getConsensusBaseFromReadBase(i);					offsetForInserted += panel.getSpaceInsertedBeforeConsensusBase(consensusBase);					int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);					char c = read.getPhdBaseChar(i);					if (chromatogramPanel.getShowReadMatrixConflict()){						consensusBase = getConsensusBaseFromReadBase(i);						char contigBase = panel.getMatrixStateAtConsensusPosition(consensusBase);						if (contigBase != c) {							int quality = read.getPhdBaseQuality(i);							if (chromatogramPanel.getDimLowQualityConflicts()) {								if (quality==0)									continue;								else if (quality>=chromatogramPanel.getDimConflictMarkerThreshold())									g.setColor(ColorDistribution.burlyWood);								else									g.setColor(ColorDistribution.brighter(ColorDistribution.burlyWood, (float)(quality/(1.0*chromatogramPanel.getDimConflictMarkerThreshold()))));							}							else 								g.setColor(ColorDistribution.burlyWood);							int rightLoc = read.getPhdRightBoundary(i,panel,true);							int leftLoc = read.getPhdLeftBoundary(i,panel,true);							fillRect(g, cwidth, leftLoc - firstReadLocation + offsetForInserted, 0, rightLoc-leftLoc, labelTop-1);							g.setColor(Color.gray);						}					}				}			}			ColorDistribution.setOpaqueGraphics(g);				}		offsetForInserted = 0;//		Color the codon position		if (chromatogramPanel.getShowCodonPosition()) {			if (MesquiteWindow.Java2Davailable){				ColorDistribution.setTransparentGraphics(g,0.2f);						for (i=firstReadBase; i<=lastReadBase;i++) {					if (i>=0 && i<read.getBasesLength()) {						int consensusBase = getConsensusBaseFromReadBase(i);						offsetForInserted += panel.getSpaceInsertedBeforeConsensusBase(consensusBase);						int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);						int codonPosition = panel.getCodonPositionOfOverallBase(overallBase);						if (codonPosition>0 && codonPosition<4) {							switch (codonPosition) {							case 1: g.setColor(Color.blue); break;							case 2: g.setColor(Color.green); break;							case 3: g.setColor(Color.red); break;							default: g.setColor(Color.white); break;							}							int w = read.getPhdRightBoundary(i,panel,true) - read.getPhdLeftBoundary(i,panel,true);							int hor = read.getPhdLeftBoundary(i, panel,true)- firstReadLocation + offsetForInserted;							fillRect(g, cwidth, hor, 16, w, 26);						}					}				}				ColorDistribution.setOpaqueGraphics(g);					}		}		offsetForInserted =0;//		Drawing the center line		g.setColor(Color.lightGray);		g.drawLine(cwidth/2,0,cwidth/2,cheight);//		Drawing the peaks					int peakBottom = labelBottom - labelHeight; //+lines;			int prevCons = 0;			int lostSpaceByInsert = 0;			int lastReadPos = MesquiteInteger.unassigned;			int start= 0;			int end = cwidth-2;			for (i=start;i < end;i+=2) {   //this goes through the pixels that are to be displayed, and sees if any from this read are in here				int readPos = i+firstReadLocation;  //this is pixels in the whole thing				int ic = findConsensusBaseNumber(i, firstReadBase, lastReadBase, firstReadLocation);//				if (!MesquiteInteger.isCombinable(ic)) Debugg.println("! ic " + ic);				if (MesquiteInteger.isCombinable(ic)){					if (MesquiteInteger.isCombinable(lastReadPos))						lostSpaceByInsert += readPos - lastReadPos -2;					lastReadPos = readPos;					readPos -= lostSpaceByInsert;//					if (!(readPos>=0&&readPos+2<A.length )) Debugg.println("! ic " + ic + "  " + readPos + "  " + A.length + " firstReadLocation " + firstReadLocation);					if ((readPos>=0&&readPos+2<A.length )) {  //is it within bounds of read?						if (prevCons != ic) {							//	offsetForInserted += spaceFollows;							offsetForInserted += panel.getSpaceInsertedAfterConsensusBase(ic);							//offsetForInserted += space;						}						int readBaseNumber = read.getReadBaseFromConsensusBase(ic);						prevCons=ic;						int qual = read.getPhdBaseQuality(readBaseNumber);						if (chromatogramPanel.getShowFades()) {							if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())								if (qual==0)									continue;								else 									ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));							if (chromatogramPanel.getFadeNonSourceRead()) {								int consensusBase = getConsensusBaseFromReadBase(readBaseNumber);								int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);								if (readUsed!=id) {									ColorDistribution.setTransparentGraphics(g,(float)NONSOURCEDIMFRACTION);								}							}							if (chromatogramPanel.getFadeNonSourceLowerQualityRead()) {								int consensusBase = getConsensusBaseFromReadBase(readBaseNumber);								int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);								Read sourceRead = chromatogramPanel.getContig().getRead(readUsed);								int qualityOfSourceBase = 0;								if (sourceRead!=null)									qualityOfSourceBase = sourceRead.getPhdBaseQuality(sourceRead.getReadBaseFromConsensusBase(consensusBase));								if (readUsed!=id  && qual<qualityOfSourceBase)									if (qual==0)										continue;									else 										ColorDistribution.setTransparentGraphics(g,(float)NONSOURCELOWERQUALITYDIMFRACTION);							}						}						int pixels = panel.getHorizontalPixels(i);//+ offsetForInserted);  //returns scaled horizontal pixels						/*temporary; to illustrate what read base the curve thinks its on *					//char c = read.getPhdBaseChar(readBaseNumber);					char c = panel.getMatrixStateAtConsensusPosition(ic);					Color tempC = panel.getBaseColor(c);					g.setColor(tempC);					fillRect(g, cwidth, pixels, 0, 2, 1000);	/**/						if (chromatogramPanel.getShowA()) {							if (isShownComplemented())								g.setColor(panel.getBaseColor(DNAState.T, panel.getBackgroundColor()));							else 								g.setColor(panel.getBaseColor(DNAState.A,panel.getBackgroundColor()));							drawLine(g, cwidth, pixels,peakBottom-(int)(A[readPos] / scale),pixels+2,peakBottom-(int)(A[readPos+2] / scale));						}						if (chromatogramPanel.getShowC()) {							if (isShownComplemented()) {								g.setColor(panel.getBaseColor(DNAState.G,panel.getBackgroundColor()));							}							else 								g.setColor(panel.getBaseColor(DNAState.C,panel.getBackgroundColor()));							drawLine(g, cwidth, pixels,peakBottom-(int)(C[readPos] / scale),pixels+2,peakBottom-(int)(C[readPos+2] / scale));						}						if (chromatogramPanel.getShowG()) {							if (isShownComplemented())								g.setColor(panel.getBaseColor(DNAState.C,panel.getBackgroundColor()));							else  {								g.setColor(panel.getBaseColor(DNAState.G,panel.getBackgroundColor()));							}							drawLine(g, cwidth, pixels,peakBottom-(int)(G[readPos] / scale),pixels+2,peakBottom-(int)(G[readPos+2] / scale));						}						if (chromatogramPanel.getShowT()) {							if (isShownComplemented())								g.setColor(panel.getBaseColor(DNAState.A,panel.getBackgroundColor()));							else 								g.setColor(panel.getBaseColor(DNAState.T,panel.getBackgroundColor()));							drawLine(g, cwidth, pixels,peakBottom-(int)(T[readPos] / scale),pixels+2,peakBottom-(int)(T[readPos+2] / scale));						}						if (chromatogramPanel.getShowFades() && (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead() || chromatogramPanel.getFadeNonSourceLowerQualityRead()))							ColorDistribution.setOpaqueGraphics(g);					}				}			}		//		Drawing the read name				if (!StringUtil.blank(chromatogram.getTitle()) && chromatogramPanel.getShowReadName()) {			if (chromatogram.getRead().getComplemented())				g.setColor(Color.red);			else				g.setColor(Color.black);			g.drawString(chromatogram.getTitle(),10,30);		}		/*		 * if (isShownReversed())			g.drawImage(VChromWindow.leftArrow,10,36, this);		else			g.drawImage(VChromWindow.rightArrow,10,36, this);		 */		if (isShownComplemented())			g.drawString("COMPLEMENTED", 10,64);		offsetForInserted = 0;//		Now to color the base letters under the peaks		for (i=firstReadBase;i < chromatogram.getBaseNumber() && i<=lastReadBase;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getConsensusBaseFromReadBase(i);				int space = panel.getSpaceInsertedBeforeConsensusBase(consensusBase);				offsetForInserted += space;				int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);				char c = read.getPhdBaseChar(i);				int qual = read.getPhdBaseQuality(i);				if (chromatogramPanel.getShowFades()) {					if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())						if (qual==0)							continue;						else 							ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));					if (chromatogramPanel.getFadeNonSourceRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);						if (readUsed!=id) {							ColorDistribution.setTransparentGraphics(g,(float)NONSOURCEDIMFRACTION);						}					}					if (chromatogramPanel.getFadeNonSourceLowerQualityRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);						Read sourceRead = chromatogramPanel.getContig().getRead(readUsed);						int qualityOfSourceBase = 0;						if (sourceRead!=null)							qualityOfSourceBase = sourceRead.getPhdBaseQuality(sourceRead.getReadBaseFromConsensusBase(consensusBase));						if (readUsed!=id  && qual<qualityOfSourceBase)							if (qual==0)								continue;							else 								ColorDistribution.setTransparentGraphics(g,(float)NONSOURCELOWERQUALITYDIMFRACTION);					}				}				int cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				int w = 0;				if (i+1< chromatogram.getBaseNumber())					//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;					w = getPhdLocation(read, cwidth, i+1, panel,true) - getPhdLocation(read, cwidth, i, panel,true) + 1;				else					w =  (int)panel.getAveragePeakDistance();				if (qual>=0 && panel.getColorByQuality()) {					if (qual==0)						g.setColor(ColorDistribution.brighter(AceFile.getColorOfQuality(qual),0.2));					else						g.setColor(ColorDistribution.brighter(AceFile.getColorOfQuality(qual),0.5));					/*	char cc= panel.getMatrixStateAtConsensusPosition(consensusBase);		Color tempC = panel.getBaseColor(cc);		g.setColor(tempC);*/					fillRect(g, cwidth, getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted, labelTop, w, labelHeight);				}				if (chromatogramPanel.getShowFades() && (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead() || chromatogramPanel.getFadeNonSourceLowerQualityRead()))					ColorDistribution.setOpaqueGraphics(g);				if (!MesquiteWindow.Java2Davailable){					if (selected[overallBase]){						w = 0;						if (i+1< chromatogram.getBaseNumber())							//w = chromatogram.getReadBaseLocationAligned(i+1) - chromatogram.getReadBaseLocationAligned(i) + 1;							w = getPhdLocation(read, cwidth, i+1, panel,true) - getPhdLocation(read, cwidth, i, panel,true) + 1;						else							w =  (int)panel.getAveragePeakDistance();						g.setColor(Color.gray);						fillRect(g, cwidth, getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted, labelTop, w, labelHeight);					}				}			}		}		offsetForInserted = 0;//		Now to show the selection		if (MesquiteWindow.Java2Davailable){			int firstSel = MesquiteInteger.unassigned;			ColorDistribution.setTransparentGraphics(g);					g.setColor(Color.gray);			int cmid = 0;			for (i=firstReadBase-1; i<=lastReadBase+1;i++) {				if (i>=0 && i<read.getBasesLength()) {					int consensusBase = getConsensusBaseFromReadBase(i);					offsetForInserted += panel.getSpaceInsertedBeforeConsensusBase(consensusBase);					int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);					char c = read.getPhdBaseChar(i);					cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;					if (selected[overallBase]){						if (firstSel == MesquiteInteger.unassigned)							firstSel = getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted;					}					else if (firstSel != MesquiteInteger.unassigned){						int endOfSel = getPhdLocation(read, cwidth, i, panel,true)- firstReadLocation - cmid - 2 + offsetForInserted;						fillRect(g, cwidth, firstSel, 0, endOfSel - firstSel, cheight);						firstSel = MesquiteInteger.unassigned;					}				}			}			if (firstSel != MesquiteInteger.unassigned){ //unfinished selection				int endOfSel = getPhdLocation(read, cwidth, lastReadBase+1, panel,true)- firstReadLocation - 2 + offsetForInserted;				fillRect(g, cwidth, firstSel, 0, endOfSel - firstSel, cheight);				firstSel = MesquiteInteger.unassigned;			}			ColorDistribution.setOpaqueGraphics(g);				}		offsetForInserted = 0;//		Now to write the bases below the peaks		for (int primer=0; primer<chromatogramPanel.numPrimers;primer++)			for (int k=0; k<4; k++)				chromatogramPanel.lastPrimerDraw[primer][k]= -1;		for (i=firstReadBase;i < chromatogram.getBaseNumber() && i<=lastReadBase;i++) {			if (i>=0 && i<read.getBasesLength()) {				int consensusBase = getConsensusBaseFromReadBase(i);				offsetForInserted += panel.getSpaceInsertedBeforeConsensusBase(consensusBase);				int overallBase = panel.getOverallBaseFromConsensusBase(consensusBase);				char c = read.getPhdBaseChar(i);				int qual = read.getPhdBaseQuality(i);				if (chromatogramPanel.getShowFades()) {					if (chromatogramPanel.getFadeLowQuality() && qual<chromatogramPanel.getFadeQualityThreshold())						ColorDistribution.setTransparentGraphics(g,(float)((fadeMax*qual)/chromatogramPanel.getFadeQualityThreshold()));					if (chromatogramPanel.getFadeNonSourceRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);						if (readUsed!=id) {							ColorDistribution.setTransparentGraphics(g,(float)NONSOURCEDIMFRACTION);						}					}					if (chromatogramPanel.getFadeNonSourceLowerQualityRead()) {						int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);						Read sourceRead = chromatogramPanel.getContig().getRead(readUsed);						int qualityOfSourceBase = 0;						if (sourceRead!=null)							qualityOfSourceBase = sourceRead.getPhdBaseQuality(sourceRead.getReadBaseFromConsensusBase(consensusBase));						if (readUsed!=id  && qual<qualityOfSourceBase)							if (qual==0)								continue;							else 								ColorDistribution.setTransparentGraphics(g,(float)NONSOURCELOWERQUALITYDIMFRACTION);					}				}				int cmid = getFontMetrics(g.getFont()).charWidth(c) / 2;				if (isShownComplemented()){					c = DNAData.complementChar(c);				}
				Color textC = panel.getBaseColor(c,panel.getBackgroundColor());				int pixels = panel.getHorizontalPixels(getPhdLocation(read, cwidth, i, panel,true) - firstReadLocation) + offsetForInserted;				if (!MesquiteWindow.Java2Davailable && selected[overallBase]){					StringUtil.highlightString(g, String.valueOf(c), pixels - cmid, labelBottom-3, textC, Color.white);				}				else {					g.setColor(textC);					GraphicsUtil.setFontStyle(Font.BOLD,g);					GraphicsUtil.setFontSize(12,g);					drawString(g, cwidth, ""+c,pixels - cmid, labelBottom-3);					String aaa = chromatogram.getTitle();//					Drawing primers										if (panel.showPrimers()){						g.setColor(Color.gray);						for (int primer = 0; primer < chromatogramPanel.numPrimers; primer++)							for (int orientation = 0; orientation<4; orientation++){								if (chromatogramPanel.showPrimer[primer][orientation]){//									Wayne!!  note that I have commented out two conditions in the next three lines, involving i and k relative to  chromatogramPanel.primerMatch[primer][orientation].length//									If these two pieces are left in the code, then they prevent the primer wg578F from being drawn on the chromatogram									if (chromatogramPanel.primerMatch[primer][orientation] != null && i>=0 ){//&& i< chromatogramPanel.primerMatch[primer][orientation].length){										int k = chromatogramPanel.primerAlignedSeqToOrigSeq[i];										if (k>=0 ){//&& k< chromatogramPanel.primerMatch[primer][orientation].length){											int primerBase = chromatogramPanel.primerMatch[primer][orientation][k];											if (primerBase >=0 && primerBase < chromatogramPanel.primerAlignment[primer][orientation].length){												long primerState = chromatogramPanel.primerAlignment[primer][orientation][primerBase][1];												if (!DNAState.isInapplicable(primerState)){													String primerChar = "" + DNAState.toCharStatic(primerState);													drawString(g, cwidth, primerChar, pixels-cmid, labelBottom-30); 													chromatogramPanel.lastPrimerDraw[primer][orientation] = pixels-cmid;												}											}										}									}								}							}					}					GraphicsUtil.setFontStyle(Font.PLAIN,g);				}				if ((i+1) % 10 == 0 && chromatogramPanel.getShowBaseNumberWithinRead()) {					g.setColor(Color.gray);					GraphicsUtil.setFontSize(10,g);					int nmid = getFontMetrics(g.getFont()).stringWidth(String.valueOf(i+1)) / 2;					drawString(g, cwidth, String.valueOf(i+1),pixels - nmid,12);				}				if (chromatogramPanel.getShowFades() && (chromatogramPanel.getFadeLowQuality() || chromatogramPanel.getFadeNonSourceRead() || chromatogramPanel.getFadeNonSourceLowerQualityRead()))					ColorDistribution.setOpaqueGraphics(g);				if (chromatogramPanel.getShowBaseSource()) {					consensusBase = getConsensusBaseFromReadBase(i);					int readUsed = chromatogramPanel.getContig().getBaseSource(consensusBase);					if (readUsed==id) {						g.setColor(ColorDistribution.sienna);						int rightLoc = read.getPhdRightBoundary(i,panel,true);						int leftLoc = read.getPhdLeftBoundary(i,panel,true);						fillRect(g, cwidth, leftLoc - firstReadLocation + offsetForInserted, labelTop, rightLoc-leftLoc, 3);					}				}			}		}		for (int primer=0; primer<chromatogramPanel.numPrimers;primer++)			for (int orientation = 0; orientation<4; orientation++)				if (chromatogramPanel.showPrimer[primer][orientation])					if (chromatogramPanel.lastPrimerDraw[primer][orientation]!= -1)						drawString(g, cwidth, chromatogramPanel.primerNames[primer] + chromatogramPanel.orientName[orientation], chromatogramPanel.lastPrimerDraw[primer][orientation], labelBottom-45);//		Drawing the bottom line		g.setColor(Color.black);		g.drawLine(0,cheight-5,cwidth,cheight-5);		g.drawLine(0,cheight-4,cwidth,cheight-4);		g.setColor(Color.gray);		g.drawLine(0,cheight-3,cwidth,cheight-3);		g.setColor(Color.lightGray);		g.drawLine(0,cheight-2,cwidth,cheight-2);		g.setColor(ColorDistribution.veryLightGray);		g.drawLine(0,cheight-1,cwidth,cheight-1);//		Debugg.println("end of paint, "+chromatogram.getTitle());	}	/*...........................................................................*/	public int getFirstReadLocation() {			int cwidth = getBounds().width;		reCalcCenterBase();		int centerConsensusBase = centerBase-panel.getContig().getReadExcessAtStart();		int centerReadBase = getReadBaseFromConsensusBase(centerConsensusBase);//		int firstReadLocation = read.getPhdLocation(centerReadBase,panel,true) - cwidth/2;		int firstReadLocation = chromatogram.getReadBaseLocation(centerReadBase) - cwidth/2;		return firstReadLocation;		//int firstReadLocation = (chromatogram.getReadBaseLocation(getReadBaseFromConsensusBase(centerBase-panel.getContig().getReadExcessAtStart()))-getBounds().width/2);	}	/*--------------------------------------*/	/*This returns for read position i, what is the position in the consensus. */	public int getConsensusBaseFromReadBase(int i){		Read read = chromatogram.getRead();		if (read!=null)			return read.getConsensusBaseFromReadBase(i);		else 			return i;	}	public void deselectAll(){		for (int i = 0; i<selected.length; i++)			selected[i]=false;	}	/*--------------------------------------*/	public void setSelected(int overallBase, boolean sel){		if (overallBase>=0||overallBase<selected.length)			selected[overallBase]= sel;	}	/*--------------------------------------*/	public boolean getSelected(int overallBase){		if (overallBase<0||overallBase>=selected.length)			return false;		return selected[overallBase];	}	/*--------------------------------------*/	/*This returns for consensus position i, what is the position in the read. */	public int getReadBaseFromConsensusBase(int i){		Read read = chromatogram.getRead();		if (read!=null)			return read.getReadBaseFromConsensusBase(i);  		else			return i;	}	/*--------------------------------------*/	/** Given the overall base number overallBase, this method selects that base within this chromatogram.	 * Note that it does NOT translate to the base number within the read, as selection can now happen even if 	 * there is no read there */	public boolean setSelectedInChrom(int overallBase, boolean sel, boolean repaint){//		why is this called an absurd number of times  Debugg.println("1");		if (selected != null && overallBase >= 0 && overallBase<selected.length) {			if (selected[overallBase] == sel)				return false;			selected[overallBase] = sel;  //selected uses index in consensus			if (repaint)				repaint();			return true;		}		return false;//		Debugg.println("2");	}	/*--------------------------------------*/	/** Given the overall base numbering, as given in overallBase, this method selects that base within this contig*/	public void selectOverallBase(int overallBase){		int consensusBase = panel.getConsensusBaseFromOverallBase(overallBase);//		int readBase = getReadBaseFromConsensusBase(consensusBase);//		if (j <0 || j>= chromatogram.getTraceLength())//		return;		if (overallBase <0 || overallBase> selected.length)			return;		selected[overallBase] = true;//		Debugg.println("selectOverallBase " + overallBase + " consensusBase " + consensusBase + " readbase " + readBase);		chromatogramPanel.exportSelectConsensusPosition(consensusBase);	}	//this is consensus position	public void deselectOverallBase(int overallBase){		int consensusBase = panel.getConsensusBaseFromOverallBase(overallBase);		int readBase = getReadBaseFromConsensusBase(consensusBase);		selected[overallBase] = false;		chromatogramPanel.exportDeselectConsensusPosition(consensusBase);	}	/*--------------------------------------*/	/* to be used by subclasses to tell that panel touched */	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		int ic = findOverallBaseNumber(x); 		boolean onRequiredSelection = chromTool.getWorksOnlyOnSelection() && !getSelected(ic);		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels() &&!onRequiredSelection){			int cons = findConsensusBaseNumber(x);			((ChromatogramTool)tool).touched(cons, cons, true, id, chromatogramPanel.contigID, modifiers);
			/*		MesquiteWindow w = chromatogramPanel.getMesquiteWindow();		if (w!=null)			w.showQuickMessage(chromatogramPanel,null,x,y,"testing");			 */
			return;		}		if (MesquiteEvent.shiftKeyDown(modifiers)){			if (MesquiteInteger.isCombinable(ic)){				panel.setSecondTouchedOverall(ic);				chromatogramPanel.exportDeselectAll();				if (MesquiteInteger.isCombinable(panel.getFirstTouchedOverall())) {					if (panel.getFirstTouchedOverall()>ic){						for (int i = ic; i<=panel.getFirstTouchedOverall(); i++)							selectOverallBase(i);					}					else {						for (int i = panel.getFirstTouchedOverall(); i<=ic; i++)							selectOverallBase(i);					}				}				else {					selectOverallBase(ic);				}				//chromatogramPanel.synchTableToChrom(false);				panel.repaintPanels();			}		}		else if (MesquiteEvent.commandOrControlKeyDown(modifiers)){			if (MesquiteInteger.isCombinable(ic)){				selectOverallBase(ic);				panel.repaintPanels();			}		}		else {			if (MesquiteInteger.isCombinable(ic)){				panel.setFirstTouchedOverall(ic);				chromatogramPanel.exportDeselectAll();				selectOverallBase(ic);				if (clickCount>1)					panel.scrollToOverallBase(ic);				panel.repaintPanels();			}		}	}	public void mouseDrag (int modifiers, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		int ic = findOverallBaseNumber(x); 		boolean onRequiredSelection = chromTool.getWorksOnlyOnSelection() && !getSelected(ic);		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels() && !onRequiredSelection){			int cons = findConsensusBaseNumber(x);			((ChromatogramTool)tool).dragged(cons, cons, true, id, chromatogramPanel.contigID, modifiers);			return;		}		if (MesquiteInteger.isCombinable(ic)){			//deselectAll(); //this isn't correct behaviour!  If shift down should remember previously sleected pieces			if (MesquiteInteger.isCombinable(panel.getFirstTouchedOverall())) {				if (panel.getFirstTouchedOverall()>ic){					if (MesquiteInteger.isCombinable(panel.getSecondTouchedOverall()) && panel.getSecondTouchedOverall()<panel.getFirstTouchedOverall() && ic>panel.getSecondTouchedOverall()){ //retracting						for (int i = panel.getSecondTouchedOverall()+1; i<=ic; i++) 							deselectOverallBase(i);					}					else for (int i = ic; i<=panel.getFirstTouchedOverall(); i++) //adding						selectOverallBase(i);				}				else {					if (MesquiteInteger.isCombinable(panel.getSecondTouchedOverall()) && panel.getSecondTouchedOverall()>panel.getFirstTouchedOverall() && ic<panel.getSecondTouchedOverall()){ //retracting						for (int i = ic+1; i<=panel.getSecondTouchedOverall(); i++) 							deselectOverallBase(i);					}					else for (int i = panel.getFirstTouchedOverall(); i<=ic; i++)						selectOverallBase(i);				}			}			else {				selectOverallBase(ic);			}			//chromatogramPanel.synchTableToChrom(false);			panel.repaintPanels();			panel.setSecondTouchedOverall(ic);		}	}	/* to be used by subclasses to tell that panel touched */	public void mouseUp(int modifiers, int x, int y, MesquiteTool tool) {		ChromatogramTool chromTool = (ChromatogramTool)tool;		if (!tool.isArrowTool() && chromTool.getWorksOnChromatogramPanels()){			int cons = findConsensusBaseNumber(x);			((ChromatogramTool)tool).dropped(cons, cons, true, id, chromatogramPanel.contigID, modifiers);			return;		}		if (MesquiteInteger.isCombinable(panel.getFirstTouchedOverall())){			if (!MesquiteInteger.isCombinable(panel.getSecondTouchedOverall()))				panel.focusMatrixOn(panel.getConsensusBaseFromOverallBase(panel.getFirstTouchedOverall()), MesquiteInteger.unassigned);			else				panel.focusMatrixOn(panel.getConsensusBaseFromOverallBase(panel.getFirstTouchedOverall()), panel.getConsensusBaseFromOverallBase(panel.getSecondTouchedOverall()));		}		if (chromatogramPanel.getScrollToTouched()) {			int ic = findConsensusBaseNumber(x);			if (ic>=0)				panel.scrollToConsensusBase(ic);		}		panel.setSecondTouchedOverall(MesquiteInteger.unassigned);	}	/*.................................................................................................................*/	public String getPeakHeightsOfBase(int readBaseNumber) {   // i is the position, zero-based, in the padded consensus sequence; returns location		if (readBaseNumber<0)			return "";		else {			int[] traceArray = new int[5];			int location = getPhdLocation(read, getBounds().width, readBaseNumber,panel,true);			String[] baseArray = new String[5];			traceArray[0] = chromatogram.getATrace(location);			baseArray[0]="A";			traceArray[1] = chromatogram.getCTrace(location);			baseArray[1]="C";			traceArray[2] = chromatogram.getGTrace(location);			baseArray[2]="G";			traceArray[3] = chromatogram.getTTrace(location);			baseArray[3]="T";			for (int i = 0; i<4; i++){				int max = IntegerArray.indexOfMaximum(traceArray);				traceArray[4] = traceArray[i];  //store this here temporarily				baseArray[4] = baseArray[i];  //store this here temporarily				traceArray[i] =  traceArray[max];				baseArray[i] = baseArray[max];				traceArray[max] = traceArray[4];				baseArray[max] = baseArray[4];				traceArray[i] = - traceArray[i];				traceArray[4]=0;			}			for (int i = 0; i<4; i++){				if (traceArray[i]<0)					traceArray[i] = -traceArray[i];			}			StringBuffer sb = new StringBuffer();			for (int i = 0; i<4; i++){				if (traceArray[i]>0) {					sb.append(baseArray[i] + ": " + traceArray[i]);					if (i<3 && traceArray[i+1]>0)						sb.append(", ");				}			}			return sb.toString();		}	}	/*...............................................................................................................*/	public void setCurrentCursor(int modifiers, int x, int y, ChromatogramTool tool) {		if (tool == null)			setCursor(getDisabledCursor());		else 	if (tool.getWorksOnChromatogramPanels()) 			setCursor(tool.getCursor());		else			setCursor(getDisabledCursor());	}	/*_________________________________________________*/	public void mouseMoved(int modifiers, int x, int y, MesquiteTool tool) {		int ic = findConsensusBaseNumber(x);		int readBaseNumber = read.getReadBaseFromConsensusBase(ic);		int quality = read.getPhdBaseQuality(readBaseNumber);		double averageQuality = read.getAverageQuality();		int numBasesHighQuality = read.getNumBasesHighQuality();		String s = "";		if (quality>=0)			s+= "Base quality: " + quality + ",   Peak heights: " + getPeakHeightsOfBase(readBaseNumber);		s+= "\n# Bases with Quality  " + read.getNumBasesHighQualityThreshold() + ": " + numBasesHighQuality + ",  Average Quality: " + averageQuality + "  ("+chromatogram.getTitle()+")";		panel.setExplanation( s);		if (tool == null)			return;		ChromatogramTool chromTool = (ChromatogramTool)tool;		if (chromTool.getWorksOnlyOnSelection())			if (!getSelected(findOverallBaseNumber(x)))				setCursor(Cursor.getDefaultCursor());			else				setCurrentCursor(modifiers, x, y, chromTool);	}	/*...............................................................................................................*/	public void mouseExited(int modifiers, int x, int y, MesquiteTool tool) {		setCursor(Cursor.getDefaultCursor());	}	/*...............................................................................................................*/	public void mouseEntered(int modifiers, int x, int y, MesquiteTool tool) {		if (tool == null)			return;		setCurrentCursor(modifiers, x, y, (ChromatogramTool)tool);	}}