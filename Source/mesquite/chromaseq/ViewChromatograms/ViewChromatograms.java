/* Mesquite Chromaseq source code.  Copyright 2005-2011 David Maddison and Wayne Maddison.Version 1.0   December 2011Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.ViewChromatograms; import java.awt.event.KeyEvent;import java.util.Vector;import mesquite.categ.lib.DNAData;import mesquite.chromaseq.lib.AceFile;import mesquite.chromaseq.lib.ChromaseqUtil;import mesquite.chromaseq.lib.ChromatWindow;import mesquite.chromaseq.lib.ChromatogramViewer;import mesquite.chromaseq.lib.Contig;import mesquite.chromaseq.lib.ContigDisplay;import mesquite.chromaseq.lib.PrimerInfoSource;import mesquite.lib.Associable;import mesquite.lib.MesquiteBoolean;import mesquite.lib.MesquiteFile;import mesquite.lib.MesquiteMessage;import mesquite.lib.MesquiteModule;import mesquite.lib.MesquiteString;import mesquite.lib.StringUtil;import mesquite.lib.characters.CharacterData;import mesquite.lib.duties.WindowHolder;import mesquite.lib.table.CMTable;import mesquite.lib.table.MesquiteTable;import mesquite.lib.taxa.Taxon;import mesquite.lib.ui.MesquiteMenuItemSpec;import mesquite.lib.ui.MesquiteMenuSpec;/* ======================================================================== */public class ViewChromatograms extends ChromatogramViewer {	CMTable table;	CharacterData  data;	//ChromatogramWindow window;	double polyThreshold =0.5;	MesquiteMenuItemSpec mms;	MesquiteMenuSpec chromM;	Vector windows;		PrimerInfoSource primerInfoTask;//	String primerSeqPath;//	String primerDatabaseURL="http://btol.tolweb.org";	String[][] primerSequences;  // will be [numPrimers][2]	boolean showPrimers = false;	boolean showSinglePrimerMatch = false;	boolean triedPrimerSequences = false;//	boolean lastPrimersFromDatabase = false;//	MesquiteBoolean primerInfoFromDatabase =new MesquiteBoolean(false);	String singlePrimer;	MesquiteString xmlPrefs= new MesquiteString();	String xmlPrefsString = null;	boolean openInNewWindow = false;		//MesquiteBoolean chromatogramsOnTop = new MesquiteBoolean(true);	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName) {		loadPreferences(xmlPrefs);		xmlPrefsString = xmlPrefs.getValue();		windows = new Vector();		return true;	}	public String preparePreferencesForXML () {		StringBuffer buffer = new StringBuffer();		StringUtil.appendXMLTag(buffer, 2, "showPrimers", showPrimers);   		VChromWindow cw = (VChromWindow)getWindow();		if (cw!=null){			String s = cw.preparePreferencesForXML(); 			if (StringUtil.notEmpty(s))				buffer.append(s);		}		return buffer.toString();	}	public void processSingleXMLPreference (String tag, String content) {		if ("showPrimers".equalsIgnoreCase(tag))			showPrimers = MesquiteBoolean.fromTrueFalseString(content);	}	////	public String[][] getPrimerSequences(){		if (primerInfoTask==null)			return null;		if (primerSequences == null){			primerSequences = primerInfoTask.getPrimerSequences();		}		return primerSequences;	}	/*	  	public String[][] getPrimerSequences(){		if (primerSequences == null || lastPrimersFromDatabase!=primerInfoFromDatabase.getValue()){			if (primerInfoFromDatabase.getValue()) {				logln("Reading primer sequences from: " + primerDatabaseURL);				PrimerList primers = new PrimerList(true, MesquiteXMLToLUtilities.getTOLPageDatabaseURL(primerDatabaseURL));				primers.readPrimerInfoFromDatabase();				primerSequences= primers.getPrimerSequences();				lastPrimersFromDatabase = true;			} else {				if (primerSeqPath == null && !triedPrimerSequences)					resetPrimersFile();				if (primerSeqPath == null)					return null;				if (!MesquiteFile.fileExists(primerSeqPath)){					return null;				}				triedPrimerSequences = true;				logln("Reading primer sequences from: " + primerSeqPath);				String primerFile = MesquiteFile.getFileContentsAsString(primerSeqPath);				PrimerList primers = new PrimerList(primerFile);				primerSequences = primers.getPrimerArray();				//primerSequences = MesquiteFile.getTabDelimitedTextFile(primerSeqPath, false);				lastPrimersFromDatabase = false;			}		//	storePreferences();  this CANNOT be done here, for this needs to be done 		}		return primerSequences;	}	public void resetPrimersFile(){		primerSeqPath = null;		triedPrimerSequences = false;		primerSequences = null;		if (!MesquiteThread.isScripting()){			primerSeqPath = MesquiteFile.openFileDialog("Choose primer sequence file", null, null);			logln("Set primer sequences file to: " + primerSeqPath);		}	}	*/		public PrimerInfoSource getPrimerInfoSource() {		return primerInfoTask;	}	public void setPrimerInfoSource(PrimerInfoSource primerInfoTask) {		this.primerInfoTask = primerInfoTask;		primerSequences = null;	}	public void setShowPrimers(boolean show){		showPrimers = show;		//storePreferences();	}	public void setShowSinglePrimerMatch(boolean show){		showSinglePrimerMatch = show;		//storePreferences();	}	public void setSinglePrimer(String s){		singlePrimer = s;		//storePreferences();	}	/*.................................................................................................................*/	public ChromatWindow getWindow(){		if (windows == null || windows.size() == 0)			return null;		return (ChromatWindow)windows.elementAt(0);  //Wayne:	}	public Taxon getTaxon(){		if (getWindow() == null)			return null;		return getWindow().getTaxon();	}	public void centerPanelAtOverallPosition(int ic){		if (getWindow() == null)			return;		getWindow().centerPanelAtOverallPosition(ic);	}	public int getHomePositionInMatrix(){		if (getWindow() == null)			return 0;		return getWindow().getHomePositionInMatrix();	}	public int getCenterBase(){		if (getWindow() == null)			return 0;		return getWindow().getCenterBase();	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return false;	}	/*.................................................................................................................*/	public void tableSelectionChanged(){		synchSelection(true);	}	public void matrixChanged(boolean syncPosition){		if (data == null)			return;		for (int i = 0; i< windows.size(); i++){			ChromatWindow w = (ChromatWindow)windows.elementAt(i);			ContigDisplay p = w.getContigDisplay();			p.matrixChanged(syncPosition);		}	}	public void showContigs(int it, MesquiteTable table, DNAData data){		double polyThreshold =0.5;		Taxon taxon = data.getTaxa().getTaxon(it);		Associable tInfo = data.getTaxaInfo(false);		String path = null;		long whichContig = -1;		if (tInfo != null) {			path = ChromaseqUtil.getStringAssociated(tInfo, ChromaseqUtil.aceRef, it);			whichContig = ChromaseqUtil.getLongAssociated(tInfo,ChromaseqUtil.whichContigRef, it);		}		if (StringUtil.blank(path)) {			iQuit();			return;		}		path = MesquiteFile.composePath(getProject().getHomeFile().getDirectoryName(), path);		if (!MesquiteFile.fileExists(path)){			iQuit();			return;		}		AceFile ace = new AceFile(path, path, null, null, this,  true, polyThreshold, false);		this.table = (CMTable)table;		this.data = (DNAData)data;		if (whichContig >= 0 && whichContig < ace.getNumContigs()){			VChromWindow w =showContig(taxon, ace.getContig((int)whichContig));  //NEED TO indicate which contig if more than one!!!!			if (w != null) {				windows.addElement(w);				if (showPrimers)					w.setShowPrimerMatches(true, true);			}		}		else {			for (int i = 0; i< ace.getNumContigs(); i++) {				VChromWindow w =showContig(taxon, ace.getContig(i));  //NEED TO indicate which contig if more than one!!!!				if (w != null) {					windows.addElement(w);					if (showPrimers)						w.setShowPrimerMatches(true, true);				}			}		}	}	public void homeContigsAtMatrixPosition(int ic){		for (int i = 0; i< windows.size(); i++){			ContigDisplay w = (ContigDisplay)windows.elementAt(i);			w.scrollToUniversalBase(w.getUniversalBaseOfMatrixBase(ic));		}	}	/*.................................................................................................................*/	private VChromWindow showContig(Taxon taxon, Contig contig){		/*int count = 0;		for (int i=0; i<contig.getNumReadsToShow(); i++) {			if (!StringUtil.blank(contig.getRead(i).getABIFile()) && !StringUtil.blank(contig.getRead(i).getABIFilePath()))				count++;		}		if (count == 0)			return null;		String[] fileNames = new String[count];		String[] paths = new String[count];		Read[] reads = new Read[count];		count = 0;		for (int i=0; i<contig.getNumReadsToShow(); i++) {			String abiFile = contig.getRead(i).getABIFile();			String abiFilePath = contig.getRead(i).getABIFilePath();			reads[count] = contig.getRead(i);			if (!StringUtil.blank(abiFile) && !StringUtil.blank(abiFilePath)) {				fileNames[count] = abiFile;				paths[count] = abiFilePath;				count++;			}		}*/		MesquiteModule windowServer = hireNamedEmployee(WindowHolder.class, "#WindowBabysitter");		windowServer.makeMenu("Chromatograms");		loadPreferences(xmlPrefs);		xmlPrefsString = xmlPrefs.getValue();		if (contig.getNumBases()<=0) {			MesquiteMessage.warnProgrammer("/nContig cannot be shown as it is empty.");			return null;		}		VChromWindow window = VChromWindow.showChromatogram(contig, table, (DNAData)data, taxon, null, windowServer,this, xmlPrefsString);//		MesquiteMenuItemSpec mm = windowServer.addMenuItem("Untrim Ends", makeCommand("untrimEnds", window));		MesquiteMenuItemSpec mm = windowServer.addMenuItem("Clear Selected Bases", makeCommand("selectedToGaps", window));		mm.setShortcut(KeyEvent.VK_MINUS); 		mm = windowServer.addMenuItem("Convert Trimmable to Gaps", makeCommand("trimmableToGaps", window));		mm = windowServer.addMenuItem("Revert Selected to Original Bases", makeCommand("selectedToCalled", window));		mm.setShortcut(KeyEvent.VK_R); 		windowServer.resetContainingMenuBar();		return window;	}	/*.................................................................................................................*/	public void synchSelection(boolean syncPosition){		if (data == null)			return;		for (int i = 0; i< windows.size(); i++){			VChromWindow w = (VChromWindow)windows.elementAt(i);			w.synchChromToTable(syncPosition);		}	}	/*.................................................................................................................*/	public void employeeQuit(MesquiteModule employee){		if (employee instanceof WindowHolder){			windows.removeAllElements();			iQuit();			resetAllWindowsMenus();		}	}	/*.................................................................................................................*/	public String getName() {		return "View Chromatograms";	}	/*.................................................................................................................*/	/** returns an explanation of what the module does.*/	public String getExplanation() {		return "Displays chromatograms for sequence in a separate window." ;	}	/*.................................................................................................................*/	public boolean showCitation(){		return true;	}	public boolean getOpenInNewWindow() {		return openInNewWindow;	}	public void setOpenInNewWindow(boolean openInNewWindow) {		this.openInNewWindow = openInNewWindow;	}}