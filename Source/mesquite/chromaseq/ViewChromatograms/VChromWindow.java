/* Mesquite chromaseq source code.  Copyright 2005-2009 D. Maddison and W. Maddison. Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code.  The commenting leaves much to be desired. Please approach this source code with the spirit of helping out. Perhaps with your help we can be more than a few, and make Mesquite better. Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY. Mesquite's web site is http://mesquiteproject.org This source code and its compiled class files are free and modifiable under the terms of  GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.ViewChromatograms;import java.io.*;import java.util.*;import java.net.*;import java.awt.*;import java.awt.event.*;import mesquite.lib.*;import mesquite.lib.table.*;import mesquite.lib.characters.*;import mesquite.align.lib.*;import mesquite.categ.lib.*;import mesquite.cont.lib.*;import mesquite.meristic.lib.*;import mesquite.chromaseq.lib.*;//Todo: This and contained panels should be within ViewChromatograms as they are designed to be used by only that one module/* ======================================================================== */public class VChromWindow extends ChromatWindow implements MesquiteListener, XMLPreferencesProcessor {	String title;	int vMargin = 20;	MesquiteTable table; //data matrix table	DNAData data;	DNAData originalData;	ContinuousData qualityData;	MeristicData registryData;	int defaultWidth = 1000;	int defaultHeight = 400;	String xmlPrefsString = null;	static boolean preferencesProcessed=false;	public static MesquiteBoolean ignoreFileSettings = new MesquiteBoolean(false);	ChromatogramViewer viewModule;	MesquiteBoolean showControls;	private Cursor handCursor;	static Image leftArrow, rightArrow;	ContigPanel contigPanel;	Vector extraContigs;	MesquiteModule windowServer;	MesquiteBoolean sequencesLocked = new MesquiteBoolean(false);	Color backgroundColor = Color.white;	MesquiteString singlePrimer = new MesquiteString("");	MesquiteMenuItemSpec	showFadesMenuItem;	static Color AColorSequencher =  new Color((float)0.1, (float)0.95, (float)0.1);	static Color CColorSequencher = Color.blue;	static Color GColorSequencher = Color.black;	static Color TColorSequencher = Color.red;	static Color AColorStandard = DNAData.dnaRed;	static Color CColorStandard  = DNAData.dnaGreen;	static Color GColorStandard  = DNAData.dnaYellow;	static Color TColorStandard = DNAData.dnaBlue;	//	============ USER OPTION boolean	public static final int SHOWBASESOURCE = 0;	public static final int FADENONSOURCEREAD = 1;	public static final int SHOWORIGINALUNTRIMMEDPANEL = 2;	public static final int SHOWORIGINALTRIMMEDPANEL=3;	public static final int CHROMATOGRAMSONTOP=4;	public static final int SHOWMULTIREADCALLSPANEL=5;	public static final int SHOWOVERVIEWPANEL=6;	public static final int FIXEDCHROMATOHEIGHT=7;	public static final int COLORIMPORTEDBYQUALITY=8;	public static final int COLORMULTIREADCALLSBYQUALITY=9;	public static final int COLOREDITEDINMATRIXBYQUALITY=10;	public static final int COLOROVERVIEWBYQUALITY=11;	public static final int USESEQUENCHERCOLORS = 12;	public static final int  FADENONSOURCELOWERQUALITYREADS = 13;	public static final int COLORREADCALLSBYQUALITY=14;	public static final int THICKTRACE = 15;	public static final int FADELOWQUALITY=16;	public static final int SHOWREADMATRIXCONFLICT=17;	public static final int SHOWREADREADCONFLICT=18;	public static final int SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD=19;	public static final int SHOWREADNAME=20;	public static final int DIMLOWQUALITYCONFLICTS=21;	public static final int SHOWCODONPOSITION=22;	public static final int SHOWFADES=23;	public static final int SCROLLTOTOUCHED=24;	public static final int TURNOFFEDITONMOVE=25;	public static final int IGNOREPROBLEMIFBASECALLED=26;	public static final int JUMPTONEXTBASE = 27;	public static final int JUMPTONEXTREADREADCONFLICT =28;	public static final int JUMPTONEXTREADMATRIXCONFLICT =29;	public static final int JUMPTONEXTLOWQUALITY =30;	public static final int JUMPTONEXTAMBIGUITY =31;	public static final int JUMPTONEXTBADSOURCEREAD=32;	public static final int SHOWPRIMERMATCHES = 33;	public static final int SHOWSINGLEPRIMERMATCH = 34;	public static final int ENABLESHADOWREDUCTION = 35;	public static final int numChromBooleans = 36;	static boolean[] factoryDefaultChromBoolean =new boolean[numChromBooleans];	static boolean[] defaultChromBoolean =new boolean[numChromBooleans];	MesquiteBoolean[] chromBoolean = new MesquiteBoolean[numChromBooleans];	static { 		for (int i=0;i<numChromBooleans;i++)			factoryDefaultChromBoolean[i] = true;   // turn them all true, then only turn off the ones that are needed		factoryDefaultChromBoolean[JUMPTONEXTBASE] = false;		factoryDefaultChromBoolean[SHOWORIGINALTRIMMEDPANEL] = false;		factoryDefaultChromBoolean[SHOWMULTIREADCALLSPANEL] = false;		factoryDefaultChromBoolean[FADENONSOURCEREAD] = false;		factoryDefaultChromBoolean[FADENONSOURCELOWERQUALITYREADS] = false;		factoryDefaultChromBoolean[THICKTRACE] = ChromatogramPanel.THICKTRACEDEFAULT;		factoryDefaultChromBoolean[FADELOWQUALITY] = false;		factoryDefaultChromBoolean[SHOWCODONPOSITION] = false;		factoryDefaultChromBoolean[SHOWREADMATRIXCONFLICT] = ChromatogramPanel.SHOWREADMATRIXCONFLICTDEFAULT;		factoryDefaultChromBoolean[SCROLLTOTOUCHED] = false;		factoryDefaultChromBoolean[SHOWPRIMERMATCHES] = false;		factoryDefaultChromBoolean[SHOWSINGLEPRIMERMATCH] = false;		factoryDefaultChromBoolean[ENABLESHADOWREDUCTION] = false;		for (int i=0;i<numChromBooleans;i++){			defaultChromBoolean[i] = factoryDefaultChromBoolean[i];		}	}	//	============ USER OPTION integers	public static final int FADELOWQUALITYTHRESHOLD = 0;	public static final int DIMCONFLICTMARKERTHRESHOLD = 1;	public static final int JUMPQUALITYTHRESHOLD = 2;	public static final int JUMPCONFLICTTHRESHOLD=3;	public static final int numChromInts = 4;	static int[] factoryDefaultChromInt =new int[numChromInts];	static int[] defaultChromInt =new int[numChromInts];	MesquiteInteger[] chromInt = new MesquiteInteger[numChromInts];	static { 		for (int i=0;i<numChromInts;i++)			factoryDefaultChromInt[i] = 0;   // turn them all true, then only turn off the ones that are needed		factoryDefaultChromInt[FADELOWQUALITYTHRESHOLD] = 20;		factoryDefaultChromInt[DIMCONFLICTMARKERTHRESHOLD] = 30;		factoryDefaultChromInt[JUMPQUALITYTHRESHOLD] = 30;		factoryDefaultChromInt[JUMPCONFLICTTHRESHOLD] = 30;		for (int i=0;i<numChromInts;i++){			defaultChromInt[i] = factoryDefaultChromInt[i];		}	}	//	=============	MesquiteBoolean showA;	MesquiteBoolean showC;	MesquiteBoolean showG;	MesquiteBoolean showT;	MesquiteBoolean useBTOLDatabase = new MesquiteBoolean(false);	MesquiteBoolean matrixSequenceIsReverseComplemented = new MesquiteBoolean(false);	//MesquiteBoolean showPrimerMatches = new MesquiteBoolean(ChromatWindow.DEFAULTSHOWPRIMERS);	//	MesquiteBoolean showSinglePrimerMatch = new MesquiteBoolean(ChromatWindow.DEFAULTSHOWSINGLEPRIMERMATCH);	//MesquiteBoolean enableShadowReduction = new MesquiteBoolean(false);	/* ======================================================================== */	public VChromWindow(ChromatogramViewer module, MesquiteModule windowServer, MesquiteTable table, CharacterData data, Taxon taxon, String title, Chromatogram[] chroms, Contig contig, Read[] reads, String xmlPrefsString) {			super(windowServer, xmlPrefsString, true);		this.xmlPrefsString = xmlPrefsString;		this.windowServer = windowServer;		this.viewModule = module;		extraContigs = new Vector();		handCursor = new Cursor(Cursor.HAND_CURSOR);		for (int i=0;i<numChromBooleans; i++)			chromBoolean[i]= new MesquiteBoolean(factoryDefaultChromBoolean[i]);		for (int i=0;i<numChromInts; i++) 			chromInt[i]= new MesquiteInteger(factoryDefaultChromInt[i]);		setWindowSize(defaultWidth, defaultHeight + 16+36);		if (leftArrow == null){			leftArrow = MesquiteImage.getImage(module.getPath()+"arrowLeft.gif");			rightArrow = MesquiteImage.getImage(module.getPath()+"arrowRight.gif");		}
		//windowServer.addMenuItem(null, "Reverse Complement", MesquiteModule.makeCommand("reverseComplement", this));
		showControls = new MesquiteBoolean(true);		windowServer.addMenuItem("Show Matrix", MesquiteModule.makeCommand("showMatrix", this));
		MesquiteSubmenuSpec mss3 = windowServer.addSubmenu(null, "Styles");		windowServer.addItemToSubmenu(null,mss3,"Standard", MesquiteModule.makeCommand("styleStandard", this));		windowServer.addItemToSubmenu(null,mss3,"Corvallis Style", MesquiteModule.makeCommand("styleCorvallis", this));		windowServer.addItemToSubmenu(null,mss3,"Vancouver Style", MesquiteModule.makeCommand("styleVancouver", this));		windowServer.addItemToSubmenu(null,mss3,"Phoenix Style", MesquiteModule.makeCommand("stylePhoenix", this));		windowServer.addMenuItem("Save Current Settings as Defaults", MesquiteModule.makeCommand("saveDefaults", this));		windowServer.addCheckMenuItem(null, "Ignore File Settings; Use Defaults", MesquiteModule.makeCommand("toggleIgnoreFileSettings", this), ignoreFileSettings);		windowServer.addMenuLine();		//-----------------		MesquiteSubmenuSpec viewSubmenu = windowServer.addSubmenu(null, "View");		windowServer.addCheckMenuItemToSubmenu(null, viewSubmenu, "Chromatograms on Top", MesquiteModule.makeCommand("toggleChromatogramsOnTop",  this), chromBoolean[CHROMATOGRAMSONTOP]);		windowServer.addCheckMenuItemToSubmenu(null, viewSubmenu, "Fixed-height Chromatograms", MesquiteModule.makeCommand("toggleFixedChromatoHeight",  this), chromBoolean[FIXEDCHROMATOHEIGHT]);		MesquiteSubmenuSpec mss = windowServer.addSubmenu(null, "Show");		showA = new MesquiteBoolean(true);		showC = new MesquiteBoolean(true);		showG = new MesquiteBoolean(true);		showT = new MesquiteBoolean(true);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Overview Panel", MesquiteModule.makeCommand("toggleShowOverviewPanel",  this), chromBoolean[SHOWOVERVIEWPANEL]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Multi-Read Panel", MesquiteModule.makeCommand("toggleShowMultiReadCallsPanel",  this), chromBoolean[SHOWMULTIREADCALLSPANEL]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Original Untrimmed Sequence", MesquiteModule.makeCommand("toggleShowAceContigPanel",  this), chromBoolean[SHOWORIGINALUNTRIMMEDPANEL]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Original Trimmed Sequence", MesquiteModule.makeCommand("toggleShowOriginalImportPanel",  this), chromBoolean[SHOWORIGINALTRIMMEDPANEL]);		windowServer.addLineToSubmenu(null,mss);		windowServer.addCheckMenuItemToSubmenu(null, mss, "A Trace", MesquiteModule.makeCommand("toggleShowA",  this), showA);		windowServer.addCheckMenuItemToSubmenu(null, mss, "C Trace", MesquiteModule.makeCommand("toggleShowC",  this), showC);		windowServer.addCheckMenuItemToSubmenu(null, mss, "G Trace", MesquiteModule.makeCommand("toggleShowG",  this), showG);		windowServer.addCheckMenuItemToSubmenu(null, mss, "T Trace", MesquiteModule.makeCommand("toggleShowT",  this), showT);		windowServer.addLineToSubmenu(null,mss);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Base Source", MesquiteModule.makeCommand("toggleShowBaseSource", this), chromBoolean[SHOWBASESOURCE]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Codon Position", MesquiteModule.makeCommand("toggleShowCodonPosition", this), chromBoolean[SHOWCODONPOSITION]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Read Name", MesquiteModule.makeCommand("toggleShowReadName", this), chromBoolean[SHOWREADNAME]);		windowServer.addCheckMenuItemToSubmenu(null, mss, "Control Bar", MesquiteModule.makeCommand("showControls", this), showControls);		MesquiteSubmenuSpec mss2 = windowServer.addSubmenu(null, "Color Calls by Quality Scores");		windowServer.addCheckMenuItemToSubmenu(null, mss2,"Individual Reads", MesquiteModule.makeCommand("toggleColorReadCallsByQuality", this), chromBoolean[COLORREADCALLSBYQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null,mss2, "Edited in Matrix Sequence", MesquiteModule.makeCommand("toggleColorEditedInMatrixByQuality", this), chromBoolean[COLOREDITEDINMATRIXBYQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null, mss2,"Imported Sequences", MesquiteModule.makeCommand("toggleColorImportedByQuality", this), chromBoolean[COLORIMPORTEDBYQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null,mss2, "Multi-Read Panel", MesquiteModule.makeCommand("toggleColorMultiReadByQuality", this), chromBoolean[COLORMULTIREADCALLSBYQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null,mss2, "Overview", MesquiteModule.makeCommand("toggleColorOverviewByQuality", this), chromBoolean[COLOROVERVIEWBYQUALITY]);		windowServer.addCheckMenuItem(null, "Thick Trace Lines", MesquiteModule.makeCommand("toggleThickTrace", this), chromBoolean[THICKTRACE]);		windowServer.addCheckMenuItem(null, "Use Sequencher Colors", MesquiteModule.makeCommand("toggleUseSequencherColors", this), chromBoolean[USESEQUENCHERCOLORS]);		windowServer.addMenuLine();		//-----------------		windowServer.addCheckMenuItem(null, "Enable Shadow Reduction", MesquiteModule.makeCommand("toggleShadowReduction", this), chromBoolean[ENABLESHADOWREDUCTION]);		windowServer.addCheckMenuItem(null, "Center Where Touched", MesquiteModule.makeCommand("toggleScrollToTouched", this), chromBoolean[SCROLLTOTOUCHED]);		windowServer.addCheckMenuItem(null, "Deselect Single Selection on Scroll", MesquiteModule.makeCommand("toggleTurnOffEditOnMove", this), chromBoolean[TURNOFFEDITONMOVE]);		MesquiteSubmenuSpec navSubmenu = windowServer.addSubmenu(null, "Arrow Keys");		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Move To Next Base", MesquiteModule.makeCommand("toggleJumpToNextBase",  this), chromBoolean[JUMPTONEXTBASE]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Source Read Conflicts with Higher Quality Read", MesquiteModule.makeCommand("toggleJumpToNextBadSourceRead",  this), chromBoolean[JUMPTONEXTBADSOURCEREAD]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Read-Matrix Conflict", MesquiteModule.makeCommand("toggleJumpToNextReadMatrixConflict",  this), chromBoolean[JUMPTONEXTREADMATRIXCONFLICT]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Read-Read Conflict", MesquiteModule.makeCommand("toggleJumpToNextReadReadConflict",  this), chromBoolean[JUMPTONEXTREADREADCONFLICT]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Low Quality", MesquiteModule.makeCommand("toggleJumpToNextLowQuality",  this), chromBoolean[JUMPTONEXTLOWQUALITY]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Jump To Next Ambiguity", MesquiteModule.makeCommand("toggleJumpToNextAmbiguity",  this), chromBoolean[JUMPTONEXTAMBIGUITY]);		windowServer.addCheckMenuItemToSubmenu(null, navSubmenu, "Ignore Problem if Base Called", MesquiteModule.makeCommand("toggleIgnoreProblemIfBaseCalled",  this), chromBoolean[IGNOREPROBLEMIFBASECALLED]);		windowServer.addLineToSubmenu(null,navSubmenu);		windowServer.addItemToSubmenu(null, navSubmenu, "Jump Conflict Threshold...", MesquiteModule.makeCommand("setJumpConflictThreshold",  this));		windowServer.addItemToSubmenu(null, navSubmenu, "Jump Quality Threshold...", MesquiteModule.makeCommand("setJumpQualityThreshold",  this));		windowServer.addCheckMenuItem(null, "Sequence in Matrix is Reverse Complemented", MesquiteModule.makeCommand("toggleIsReverseComplemented", this), matrixSequenceIsReverseComplemented);		windowServer.addMenuLine();		windowServer.addMenuItem( "Force Reregistration of Contig", MesquiteModule.makeCommand("forceRegistrationContig",  this));		windowServer.addMenuItem( "Force Reregistration of Entire Matrix", MesquiteModule.makeCommand("forceRegistrationMatrix",  this));		windowServer.addMenuItem( "Recalculate Mappers (Recalc)", MesquiteModule.makeCommand("recalculateMappers",  this));		windowServer.addMenuItem( "Recalculate Mappers (Infer Contig)", MesquiteModule.makeCommand("recalculateMappersInfer",  this));		windowServer.addMenuItem( "Dump Mappers", MesquiteModule.makeCommand("dumpMappers",  this));		windowServer.addMenuLine();		//-----------------		MesquiteSubmenuSpec primerSubmenu = windowServer.addSubmenu(null, "Primers");		windowServer.addCheckMenuItemToSubmenu( null, primerSubmenu,"Show Primer Matches", MesquiteModule.makeCommand("showPrimerMatches",  this), chromBoolean[SHOWPRIMERMATCHES]);		windowServer.addItemToSubmenu(null, primerSubmenu, "Set Primer File ...", MesquiteModule.makeCommand("setPrimerSequenceFile",  this));		windowServer.addCheckMenuItemToSubmenu( null, primerSubmenu,"Use BTOL Database", MesquiteModule.makeCommand("useBTOLDatabase",  this), useBTOLDatabase);		windowServer.addCheckMenuItemToSubmenu( null, primerSubmenu, "Show Single Primer Match", MesquiteModule.makeCommand("showSinglePrimerMatch",  this), chromBoolean[SHOWSINGLEPRIMERMATCH]);		windowServer.addItemToSubmenu(null, primerSubmenu, "Specify Single Primer ...", MesquiteModule.makeCommand("setSinglePrimer",  this));		windowServer.addMenuItem( "Show Extra Sequence...", MesquiteModule.makeCommand("showExtraContig",  this));		windowServer.addCheckMenuItem( null, "Lock Extra sequences", MesquiteModule.makeCommand("lockSequences",  this), sequencesLocked);		windowServer.addMenuLine();		//-----------------		windowServer.addCheckMenuItem(null, "Show Source Read Conflicts with Higher Quality Read", MesquiteModule.makeCommand("toggleShowLowerQualSourceConflictsWithHigherQualRead", this), chromBoolean[SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD]);		windowServer.addCheckMenuItem(null, "Show Read-Matrix Conflict", MesquiteModule.makeCommand("toggleShowReadMatrixConflict", this), chromBoolean[SHOWREADMATRIXCONFLICT]);		windowServer.addCheckMenuItem(null, "Show Read-Read Conflict", MesquiteModule.makeCommand("toggleShowReadReadConflict", this), chromBoolean[SHOWREADREADCONFLICT]);		windowServer.addCheckMenuItem(null, "Dim Conflict Markers if Low Quality", MesquiteModule.makeCommand("toggleDimLowQualityConflicts", this), chromBoolean[DIMLOWQUALITYCONFLICTS]);		windowServer.addMenuItem( "Dim Conflict Marker Threshold...", MesquiteModule.makeCommand("setDimConflictMarkerTheshold",  this));		windowServer.addMenuLine();		//-----------------		showFadesMenuItem = windowServer.addMenuItem("Show Fades", MesquiteModule.makeCommand("toggleShowFades", this));		showFadesMenuItem.setShortcut(KeyEvent.VK_D); 		windowServer.addCheckMenuItem(null, "Fade Low Quality", MesquiteModule.makeCommand("toggleFadeLowQuality", this), chromBoolean[FADELOWQUALITY]);		windowServer.addMenuItem( "Fade Quality Threshold...", MesquiteModule.makeCommand("setFadeThreshold",  this));		windowServer.addCheckMenuItem(null, "Fade Non-Source Read", MesquiteModule.makeCommand("toggleFadeNonSourceRead", this), chromBoolean[FADENONSOURCEREAD]);		windowServer.addCheckMenuItem(null, "Fade Non-Source Lower-Quality Read", MesquiteModule.makeCommand("toggleFadeNonSourceLowerQualityRead", this), chromBoolean[FADENONSOURCELOWERQUALITYREADS]);		windowServer.addMenuLine();		//-----------------		this.title = title;		this.table = table;		this.data = (DNAData)data;		setAnnotation(taxon.getName() + " (in matrix " + data.getName() + ")", null);		originalData = ChromaseqUtil.getOriginalData(data);		qualityData = ChromaseqUtil.getQualityData(data);		registryData = ChromaseqUtil.getRegistryData(data);		if (originalData == null) {			originalData = (DNAData)data;		}		if (data != null)			data.addListener(this);		if (originalData != null)			originalData.addListener(this);		if (qualityData != null)			qualityData.addListener(this);		if (registryData==null) {			registryData = ChromaseqUtil.createRegistryData(data, windowServer, false);					}		contigPanel = new ContigPanel( this, (DNAData)data, originalData, qualityData, table, taxon, chroms,  contig, true);		//	if (totalCreated<=1)   // only do it first time		XMLUtil.readXMLPreferences(viewModule,this, xmlPrefsString);		for (int i=0;i<numChromBooleans; i++) {			chromBoolean[i].setValue(defaultChromBoolean[i]);		}		for (int i=0;i<numChromInts; i++) {			chromInt[i].setValue(defaultChromInt[i]);		}		preferencesProcessed = true;		initializeContigPanelSettings(contigPanel);		addToWindow(contigPanel);		//infoPanel = new InfoPanel(taxon.getName());		//addToWindow(infoPanel);		//		sizeDisplays()		ChromatogramTool arrowTool = new ChromatogramTool(this, "arrow", MesquiteModule.getRootImageDirectoryPath(),"arrow.gif", 4,2,"Select", "Selection tool", MesquiteModule.makeCommand("arrowTouch",  this) , MesquiteModule.makeCommand("arrowDrop",  this), null);		arrowTool.setIsArrowTool(true);		addTool(arrowTool);		setCurrentTool(arrowTool);		arrowTool.setInUse(true);		setShowAnnotation(true);		setShowExplanation(true);		resetTitle();		sizeDisplays();		SequencePanel[] sequences = new SequencePanel[]{contigPanel.originalUntrimmedPanel, contigPanel.originalTrimmedPanel, contigPanel.matrixSeqPanel};		for (int i=0; i< viewModule.getEmployeeVector().size(); i++){			Object e = viewModule.getEmployeeVector().elementAt(i);			if (e instanceof ChromInit){				((ChromInit)e).setWindow(this);				((ChromInit)e).addContext(taxon, contig, contigPanel, reads, sequences, (DNAData)data, getOriginalData(), getQualityData(), table, contigPanel.getID());			}		}		adjustChromInitsIfPositionChanges();		matrixSequenceIsReverseComplemented.setValue(contigPanel.isReversedInEditedData() && contigPanel.isComplementedInEditedData());		contigPanel.requestFocusInWindow();	}	/*.................................................................................................................*/	private void setChromInt(int i,int value) {		setChromInt(i, value, false);	}	/*.................................................................................................................*/	private void setChromInt(int i,int value, boolean setDefault) {		chromInt[i].setValue(value);		if (setDefault)			defaultChromInt[i] =value;		switch(i) {		case FADELOWQUALITYTHRESHOLD:			setFadeQualityThreshold(value);			break;		case DIMCONFLICTMARKERTHRESHOLD:			setDimConflictMarkerThreshold(value);			break;		default: ;		}	}	/*.................................................................................................................*/	private void setChromBoolean(int i, boolean b) {		setChromBoolean( i, b, false);	}	/*.................................................................................................................*/	private void setChromBoolean(int i, boolean b, boolean setDefault) {		chromBoolean[i].setValue(b);		if (setDefault)			defaultChromBoolean[i] =b;		switch (i) {		case SHOWBASESOURCE: 			setShowBaseSource(b);			break;		case FADENONSOURCEREAD:			setFadeNonSourceRead(b);			break;		case SHOWORIGINALUNTRIMMEDPANEL:			contigPanel.setShowAceContigPanel(b);			break;		case SHOWORIGINALTRIMMEDPANEL:			contigPanel.setShowOriginalImportPanel(b);			break;		case CHROMATOGRAMSONTOP: 			contigPanel.setChromatogramsOnTop(b);			adjustChromInitsIfPositionChanges();			break;		case SHOWMULTIREADCALLSPANEL:			contigPanel.setShowMultiReadCallsPanel(b);			break;		case SHOWOVERVIEWPANEL:			contigPanel.setShowOverviewPanel(b);			break;		case FIXEDCHROMATOHEIGHT:			contigPanel.setFixedChromatoHeight(b);			break;		case COLORIMPORTEDBYQUALITY:			setColorImportedByQuality(b);			break;		case COLORREADCALLSBYQUALITY:			setColorReadCallsByQuality(b);			break;		case COLORMULTIREADCALLSBYQUALITY:			setColorMultiReadByQuality(b);			break;		case COLOREDITEDINMATRIXBYQUALITY:			setColorEditedInMatrixByQuality(b);			break;		case COLOROVERVIEWBYQUALITY:			setColorOverviewByQuality(b);			break;		case USESEQUENCHERCOLORS: 			setUseSequencherColors(b);			break;		case FADENONSOURCELOWERQUALITYREADS: 			setFadeNonSourceLowerQualityRead(b);			break;		case THICKTRACE:			setThickTrace(b);			break;		case FADELOWQUALITY:			setFadeLowQuality(b);			break;		case SHOWREADMATRIXCONFLICT:			setShowReadMatrixConflict(b);			break;		case SHOWREADREADCONFLICT:			setShowReadReadConflict(b);			break;		case SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD:			setShowLowerQualSourceConflictsWithHigherQualRead(b);			break;		case SHOWREADNAME:			setShowReadName(b);			break;		case DIMLOWQUALITYCONFLICTS:			setDimLowQualityConflicts(b);			break;		case SHOWCODONPOSITION:			setShowCodonPosition(b);			break;		case SHOWFADES:			setShowFades(b);			break;		case SCROLLTOTOUCHED:			setScrollToTouched(b);			break;		case SHOWPRIMERMATCHES:			setShowPrimerMatches(b);			break;		case SHOWSINGLEPRIMERMATCH:			setShowSinglePrimerMatch(b);			break;		case JUMPTONEXTBASE:			recheckJumps(i);			break;		case JUMPTONEXTREADREADCONFLICT:			recheckJumps(i);			break;		case JUMPTONEXTREADMATRIXCONFLICT:			recheckJumps(i);			break;		case JUMPTONEXTLOWQUALITY:			recheckJumps(i);			break;		case JUMPTONEXTAMBIGUITY:			recheckJumps(i);			break;		case JUMPTONEXTBADSOURCEREAD:			recheckJumps(i);			break;		default: ;		}	}	/*.................................................................................................................*/	public void recheckJumps(int i) {		switch(i) {		case JUMPTONEXTBASE:			if (chromBoolean[JUMPTONEXTBASE].getValue()) {				chromBoolean[JUMPTONEXTREADREADCONFLICT].setValue(false);				chromBoolean[JUMPTONEXTLOWQUALITY].setValue(false);				chromBoolean[JUMPTONEXTREADMATRIXCONFLICT].setValue(false);				chromBoolean[JUMPTONEXTAMBIGUITY].setValue(false);				chromBoolean[JUMPTONEXTBADSOURCEREAD].setValue(false);			}			break;		case JUMPTONEXTREADREADCONFLICT:			if (chromBoolean[JUMPTONEXTREADREADCONFLICT].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		case JUMPTONEXTREADMATRIXCONFLICT:			if (chromBoolean[JUMPTONEXTREADMATRIXCONFLICT].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		case JUMPTONEXTLOWQUALITY:			if (chromBoolean[JUMPTONEXTLOWQUALITY].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		case JUMPTONEXTAMBIGUITY:			if (chromBoolean[JUMPTONEXTAMBIGUITY].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		case JUMPTONEXTBADSOURCEREAD:			if (chromBoolean[JUMPTONEXTBADSOURCEREAD].getValue()) {				chromBoolean[JUMPTONEXTBASE].setValue(false);			}			break;		}	}	/*.................................................................................................................*/	private void setChromBoolean(int i, String toggleString) {		chromBoolean[i].toggleValue(toggleString);		setChromBoolean(i,chromBoolean[i].getValue());	}	/*.................................................................................................................*/	public void processSingleXMLPreference (String tag, String content) {		if ("ignoreFileSettings".equalsIgnoreCase(tag))			ignoreFileSettings.setValue(MesquiteBoolean.fromTrueFalseString(content));		else if (!preferencesProcessed) {   //only process these ones first time through			if ("showAceContigPanel".equalsIgnoreCase(tag))				setChromBoolean(SHOWORIGINALUNTRIMMEDPANEL, MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showOriginalImportPanel".equalsIgnoreCase(tag)) 				setChromBoolean(SHOWORIGINALTRIMMEDPANEL, MesquiteBoolean.fromTrueFalseString(content), true);			else if ("chromatogramsOnTop".equalsIgnoreCase(tag))				setChromBoolean(CHROMATOGRAMSONTOP, MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showMultiReadCallsPanel".equalsIgnoreCase(tag))				setChromBoolean(SHOWMULTIREADCALLSPANEL, MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showOverviewPanel".equalsIgnoreCase(tag))				setChromBoolean(SHOWOVERVIEWPANEL, MesquiteBoolean.fromTrueFalseString(content), true);			else if ("fixedChromatoHeight".equalsIgnoreCase(tag))				setChromBoolean(FIXEDCHROMATOHEIGHT, MesquiteBoolean.fromTrueFalseString(content), true);			else if ("fadeNonSourceRead".equalsIgnoreCase(tag))				setChromBoolean(FADENONSOURCEREAD, MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showBaseSource".equalsIgnoreCase(tag))				setChromBoolean(SHOWBASESOURCE, MesquiteBoolean.fromTrueFalseString(content), true);			else if ("colorImportedByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLORIMPORTEDBYQUALITY,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("colorReadCallsByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLORREADCALLSBYQUALITY,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("colorMultiReadByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLORMULTIREADCALLSBYQUALITY,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("colorOverviewByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLOROVERVIEWBYQUALITY,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("colorEditedInMatrixByQuality".equalsIgnoreCase(tag))				setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("useSequencherColors".equalsIgnoreCase(tag))				setChromBoolean(USESEQUENCHERCOLORS,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("fadeNonSourceLowerQualityRead".equalsIgnoreCase(tag))				setChromBoolean(FADENONSOURCELOWERQUALITYREADS,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("thickTrace".equalsIgnoreCase(tag))				setChromBoolean(THICKTRACE,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("fadeLowQuality".equalsIgnoreCase(tag))				setChromBoolean(FADELOWQUALITY,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showReadMatrixConflict".equalsIgnoreCase(tag))				setChromBoolean(SHOWREADMATRIXCONFLICT,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showReadReadConflict".equalsIgnoreCase(tag))				setChromBoolean(SHOWREADREADCONFLICT,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showLowerQualSourceConflictsWithHigherQualRead".equalsIgnoreCase(tag))				setChromBoolean(SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showReadName".equalsIgnoreCase(tag))				setChromBoolean(SHOWREADNAME,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("dimLowQualityConflicts".equalsIgnoreCase(tag))				setChromBoolean(DIMLOWQUALITYCONFLICTS,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showCodonPosition".equalsIgnoreCase(tag))				setChromBoolean(SHOWCODONPOSITION,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showFades".equalsIgnoreCase(tag))				setChromBoolean(SHOWFADES,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("scrollToTouched".equalsIgnoreCase(tag))				setChromBoolean(SCROLLTOTOUCHED,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("turnOffEditOnMove".equalsIgnoreCase(tag))				setChromBoolean(TURNOFFEDITONMOVE,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("jumpToNextBase".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTBASE,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("jumpToNextReadReadConflict".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTREADREADCONFLICT,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("jumpToNextReadMatrixConflict".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTREADMATRIXCONFLICT,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("jumpToNextLowQuality".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTLOWQUALITY,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("jumpToNextAmbiguity".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTAMBIGUITY,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("ignoreProblemIfBaseCalled".equalsIgnoreCase(tag))				setChromBoolean(IGNOREPROBLEMIFBASECALLED,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("jumpToNextBadSourceRead".equalsIgnoreCase(tag))				setChromBoolean(JUMPTONEXTBADSOURCEREAD,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("fadeLowQualityThreshold".equalsIgnoreCase(tag))				setChromInt(FADELOWQUALITYTHRESHOLD,MesquiteInteger.fromString(content), true);			else if ("dimConflictMarkerThreshold".equalsIgnoreCase(tag))				setChromInt(DIMCONFLICTMARKERTHRESHOLD,MesquiteInteger.fromString(content), true);			else if ("jumpQualityThreshold".equalsIgnoreCase(tag))				setChromInt(JUMPQUALITYTHRESHOLD,MesquiteInteger.fromString(content), true);			else if ("jumpConflictThreshold".equalsIgnoreCase(tag))				setChromInt(JUMPCONFLICTTHRESHOLD,MesquiteInteger.fromString(content), true);			else if ("showSinglePrimerMatch".equalsIgnoreCase(tag)) 				setChromBoolean(SHOWSINGLEPRIMERMATCH,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("enableShadowReduction".equalsIgnoreCase(tag))				setChromBoolean(ENABLESHADOWREDUCTION,MesquiteBoolean.fromTrueFalseString(content), true);			else if ("showPrimerMatches".equalsIgnoreCase(tag))				setChromBoolean(SHOWPRIMERMATCHES,MesquiteBoolean.fromTrueFalseString(content), true);		}		else if ("useBTOLDatabase".equalsIgnoreCase(tag))			useBTOLDatabase.setFromTrueFalseString(content);		else if ("showA".equalsIgnoreCase(tag))			showA.setFromTrueFalseString(content);		else if ("showC".equalsIgnoreCase(tag))			showC.setFromTrueFalseString(content);		else if ("showG".equalsIgnoreCase(tag))			showG.setFromTrueFalseString(content);		else if ("showT".equalsIgnoreCase(tag))			showT.setFromTrueFalseString(content);	}	/*.................................................................................................................*/	public String preparePreferencesForXML () {		StringBuffer buffer = new StringBuffer(60);			StringUtil.appendXMLTag(buffer, 2, "chromatogramsOnTop", defaultChromBoolean[CHROMATOGRAMSONTOP]);  		StringUtil.appendXMLTag(buffer, 2, "fixedChromatoHeight", defaultChromBoolean[FIXEDCHROMATOHEIGHT]);  		StringUtil.appendXMLTag(buffer, 2, "showAceContigPanel",defaultChromBoolean[SHOWORIGINALUNTRIMMEDPANEL]);		StringUtil.appendXMLTag(buffer, 2, "showMultiReadCallsPanel",defaultChromBoolean[SHOWMULTIREADCALLSPANEL]);		StringUtil.appendXMLTag(buffer, 2, "showOverviewPanel",defaultChromBoolean[SHOWOVERVIEWPANEL]);		StringUtil.appendXMLTag(buffer, 2, "showOriginalImportPanel",defaultChromBoolean[SHOWORIGINALTRIMMEDPANEL]);		StringUtil.appendXMLTag(buffer, 2, "colorImportedByQuality",defaultChromBoolean[COLORIMPORTEDBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "colorReadCallsByQuality",defaultChromBoolean[COLORREADCALLSBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "colorMultiReadByQuality",defaultChromBoolean[COLORMULTIREADCALLSBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "colorOverviewByQuality",defaultChromBoolean[COLOROVERVIEWBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "colorEditedInMatrixByQuality",defaultChromBoolean[COLOREDITEDINMATRIXBYQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "useSequencherColors",defaultChromBoolean[USESEQUENCHERCOLORS]);		StringUtil.appendXMLTag(buffer, 2, "thickTrace",defaultChromBoolean[THICKTRACE]);		StringUtil.appendXMLTag(buffer, 2, "fadeLowQuality",defaultChromBoolean[FADELOWQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "fadeNonSourceRead",defaultChromBoolean[FADENONSOURCEREAD]);		StringUtil.appendXMLTag(buffer, 2, "fadeNonSourceLowerQualityRead",defaultChromBoolean[FADENONSOURCELOWERQUALITYREADS]);		StringUtil.appendXMLTag(buffer, 2, "showReadMatrixConflict",defaultChromBoolean[SHOWREADMATRIXCONFLICT]);		StringUtil.appendXMLTag(buffer, 2, "showReadReadConflict",defaultChromBoolean[SHOWREADREADCONFLICT]);		StringUtil.appendXMLTag(buffer, 2, "showLowerQualSourceConflictsWithHigherQualRead",defaultChromBoolean[SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD]);		StringUtil.appendXMLTag(buffer, 2, "showReadName",defaultChromBoolean[SHOWREADNAME]);		StringUtil.appendXMLTag(buffer, 2, "dimLowQualityConflicts",defaultChromBoolean[DIMLOWQUALITYCONFLICTS]);		StringUtil.appendXMLTag(buffer, 2, "scrollToTouched",defaultChromBoolean[SCROLLTOTOUCHED]);		StringUtil.appendXMLTag(buffer, 2, "turnOffEditOnMove",defaultChromBoolean[TURNOFFEDITONMOVE]);		StringUtil.appendXMLTag(buffer, 2, "showBaseSource",defaultChromBoolean[SHOWBASESOURCE]);		StringUtil.appendXMLTag(buffer, 2, "showCodonPosition",defaultChromBoolean[SHOWCODONPOSITION]);		StringUtil.appendXMLTag(buffer, 2, "showFades",defaultChromBoolean[SHOWFADES]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextBase",defaultChromBoolean[JUMPTONEXTBASE]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextReadReadConflict",defaultChromBoolean[JUMPTONEXTREADREADCONFLICT]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextReadMatrixConflict",defaultChromBoolean[JUMPTONEXTREADMATRIXCONFLICT]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextLowQuality",defaultChromBoolean[JUMPTONEXTLOWQUALITY]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextAmbiguity",defaultChromBoolean[JUMPTONEXTAMBIGUITY]);		StringUtil.appendXMLTag(buffer, 2, "jumpToNextBadSourceRead",defaultChromBoolean[JUMPTONEXTBADSOURCEREAD]);		StringUtil.appendXMLTag(buffer, 2, "ignoreProblemIfBaseCalled",defaultChromBoolean[IGNOREPROBLEMIFBASECALLED]);		StringUtil.appendXMLTag(buffer, 2, "showPrimerMatches",defaultChromBoolean[SHOWPRIMERMATCHES]);		StringUtil.appendXMLTag(buffer, 2, "showSinglePrimerMatch",defaultChromBoolean[SHOWSINGLEPRIMERMATCH]);		StringUtil.appendXMLTag(buffer, 2, "enableShadowReduction",defaultChromBoolean[ENABLESHADOWREDUCTION]);		StringUtil.appendXMLTag(buffer, 2, "fadeLowQualityThreshold",defaultChromInt[FADELOWQUALITYTHRESHOLD]);		StringUtil.appendXMLTag(buffer, 2, "dimConflictMarkerThreshold",defaultChromInt[DIMCONFLICTMARKERTHRESHOLD]);		StringUtil.appendXMLTag(buffer, 2, "jumpQualityThreshold",defaultChromInt[JUMPQUALITYTHRESHOLD]);		StringUtil.appendXMLTag(buffer, 2, "jumpConflictThreshold",defaultChromInt[JUMPCONFLICTTHRESHOLD]);		StringUtil.appendXMLTag(buffer, 2, "ignoreFileSettings",ignoreFileSettings);		/*		StringUtil.appendXMLTag(buffer, 2, "showA",showA);		StringUtil.appendXMLTag(buffer, 2, "showC",showC);		StringUtil.appendXMLTag(buffer, 2, "showG",showG);		StringUtil.appendXMLTag(buffer, 2, "showT",showT);		 */		//	StringUtil.appendXMLTag(buffer, 2, "useBTOLDatabase",useBTOLDatabase);		return buffer.toString();	}	/*.................................................................................................................*/	public void setToStandardStyle () {		for (int i=0; i<numChromBooleans; i++)			setChromBoolean(i,factoryDefaultChromBoolean[i]);	}	/*.................................................................................................................*/	public void setToDRMStyle () {		setChromBoolean(SHOWBASESOURCE,true);		setChromBoolean(SHOWORIGINALUNTRIMMEDPANEL,true);		setChromBoolean(SHOWORIGINALTRIMMEDPANEL,true);		setChromBoolean(SHOWMULTIREADCALLSPANEL,false);		setChromBoolean(SHOWOVERVIEWPANEL,true);		setChromBoolean(CHROMATOGRAMSONTOP,true);		setChromBoolean(FIXEDCHROMATOHEIGHT,true);		setChromBoolean(COLORIMPORTEDBYQUALITY,true);		setChromBoolean(COLORREADCALLSBYQUALITY,true);		setChromBoolean(COLORMULTIREADCALLSBYQUALITY,true);		setChromBoolean(COLOROVERVIEWBYQUALITY,true);		setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,true);		setChromBoolean(FADENONSOURCELOWERQUALITYREADS,true);		setChromBoolean(SHOWFADES,false);				setChromBoolean(SHOWPRIMERMATCHES,true);		setChromBoolean(THICKTRACE,true);		setChromBoolean(SHOWREADMATRIXCONFLICT,true);	}	/*.................................................................................................................*/	public void setToWPMStyle () {		setChromBoolean(SHOWBASESOURCE,true);		setChromBoolean(SHOWORIGINALUNTRIMMEDPANEL,false);		setChromBoolean(SHOWORIGINALTRIMMEDPANEL,false);		setChromBoolean(SHOWMULTIREADCALLSPANEL,true);		setChromBoolean(SHOWOVERVIEWPANEL,true);		setChromBoolean(CHROMATOGRAMSONTOP,false);		setChromBoolean(FIXEDCHROMATOHEIGHT,true);		setChromBoolean(COLORIMPORTEDBYQUALITY,false);		setChromBoolean(COLORREADCALLSBYQUALITY,false);		setChromBoolean(COLORMULTIREADCALLSBYQUALITY,true);		setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,true);		setChromBoolean(COLOROVERVIEWBYQUALITY,true);		setChromBoolean(THICKTRACE,true);		setChromBoolean(SHOWREADMATRIXCONFLICT,true);		setChromBoolean(SCROLLTOTOUCHED,true);	}	/*.................................................................................................................*/	public void setToAEAStyle () {		setChromBoolean(SHOWBASESOURCE,false);		setChromBoolean(SHOWORIGINALUNTRIMMEDPANEL,false);		setChromBoolean(SHOWORIGINALTRIMMEDPANEL,false);		setChromBoolean(CHROMATOGRAMSONTOP,false);		setChromBoolean(SHOWMULTIREADCALLSPANEL,true);		setChromBoolean(SHOWOVERVIEWPANEL,true);		setChromBoolean(FIXEDCHROMATOHEIGHT,true);		setChromBoolean(COLORIMPORTEDBYQUALITY,false);		setChromBoolean(COLORREADCALLSBYQUALITY,false);		setChromBoolean(COLORMULTIREADCALLSBYQUALITY,true);		setChromBoolean(COLOROVERVIEWBYQUALITY,true);		setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,false);		setChromBoolean(THICKTRACE,false);		setChromBoolean(SHOWREADMATRIXCONFLICT,false);		setChromBoolean(SCROLLTOTOUCHED,true);	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot snapshot = new Snapshot();		Snapshot fromWindow = super.getSnapshot(file);		snapshot.incorporate(fromWindow,false);		snapshot.addLine("showControls  " + showControls.toOffOnString());		snapshot.addLine("toggleShowA  " + showA.toOffOnString());		snapshot.addLine("toggleShowC " + showC.toOffOnString());		snapshot.addLine("toggleShowG " + showG.toOffOnString());		snapshot.addLine("toggleShowT " + showT.toOffOnString());		/*   removed from snapshot */		snapshot.addLine("setFadeThreshold  " + chromInt[FADELOWQUALITYTHRESHOLD].getValue());		snapshot.addLine("setJumpQualityThreshold  " + chromInt[JUMPQUALITYTHRESHOLD].getValue());		snapshot.addLine("setJumpConflictThreshold  " + chromInt[JUMPCONFLICTTHRESHOLD].getValue());		snapshot.addLine("setDimConflictMarkerTheshold " + chromInt[DIMCONFLICTMARKERTHRESHOLD].getValue());		snapshot.addLine("togglechromatogramsOnTop " +  chromBoolean[CHROMATOGRAMSONTOP].toOffOnString());  		snapshot.addLine("togglefixedChromatoHeight " +  chromBoolean[FIXEDCHROMATOHEIGHT].toOffOnString());    		snapshot.addLine("toggleshowAceContigPanel " +  chromBoolean[SHOWORIGINALUNTRIMMEDPANEL].toOffOnString());  		snapshot.addLine("toggleshowMultiReadCallsPanel " +  chromBoolean[SHOWMULTIREADCALLSPANEL].toOffOnString());  		snapshot.addLine("toggleshowOverviewPanel " +  chromBoolean[SHOWOVERVIEWPANEL].toOffOnString());  		snapshot.addLine("toggleshowOriginalImportPanel " +  chromBoolean[SHOWORIGINALTRIMMEDPANEL].toOffOnString());  		snapshot.addLine("togglecolorImportedByQuality " +  chromBoolean[COLORIMPORTEDBYQUALITY].toOffOnString());  		snapshot.addLine("togglecolorReadCallsByQuality " +  chromBoolean[COLORREADCALLSBYQUALITY].toOffOnString());  		snapshot.addLine("togglecolorMultiReadByQuality " +  chromBoolean[COLORMULTIREADCALLSBYQUALITY].toOffOnString());  		snapshot.addLine("togglecolorOverviewByQuality " +  chromBoolean[COLOROVERVIEWBYQUALITY].toOffOnString());  		snapshot.addLine("togglecolorEditedInMatrixByQuality " +  chromBoolean[COLOREDITEDINMATRIXBYQUALITY].toOffOnString());  		snapshot.addLine("toggleuseSequencherColors " +  chromBoolean[USESEQUENCHERCOLORS].toOffOnString());  		snapshot.addLine("togglethickTrace " +  chromBoolean[THICKTRACE].toOffOnString());  		snapshot.addLine("togglefadeLowQuality " +  chromBoolean[FADELOWQUALITY].toOffOnString());  		snapshot.addLine("togglefadeNonSourceRead " +  chromBoolean[FADENONSOURCEREAD].toOffOnString());  		snapshot.addLine("togglefadeNonSourceLowerQualityRead " +  chromBoolean[FADENONSOURCELOWERQUALITYREADS].toOffOnString());  		snapshot.addLine("toggleshowReadMatrixConflict " +  chromBoolean[SHOWREADMATRIXCONFLICT].toOffOnString());  		snapshot.addLine("toggleshowReadReadConflict " +  chromBoolean[SHOWREADREADCONFLICT].toOffOnString());  		snapshot.addLine("toggleshowLowerQualSourceConflictsWithHigherQualRead " +  chromBoolean[SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD].toOffOnString());  		snapshot.addLine("toggleshowReadName " +  chromBoolean[SHOWREADNAME].toOffOnString());  		snapshot.addLine("toggledimLowQualityConflicts " +  chromBoolean[DIMLOWQUALITYCONFLICTS].toOffOnString());  		snapshot.addLine("togglescrollToTouched " +  chromBoolean[SCROLLTOTOUCHED].toOffOnString());  		snapshot.addLine("toggleturnOffEditOnMove " +  chromBoolean[TURNOFFEDITONMOVE].toOffOnString());  		snapshot.addLine("toggleshowBaseSource " +  chromBoolean[SHOWBASESOURCE].toOffOnString());  		snapshot.addLine("toggleshowCodonPosition " +  chromBoolean[SHOWCODONPOSITION].toOffOnString());  		snapshot.addLine("toggleshowFades " +  chromBoolean[SHOWFADES].toOffOnString());  		snapshot.addLine("togglejumpToNextBase " +  chromBoolean[JUMPTONEXTBASE].toOffOnString());  		snapshot.addLine("togglejumpToNextReadReadConflict " +  chromBoolean[JUMPTONEXTREADREADCONFLICT].toOffOnString());  		snapshot.addLine("togglejumpToNextReadMatrixConflict " +  chromBoolean[JUMPTONEXTREADMATRIXCONFLICT].toOffOnString());  		snapshot.addLine("togglejumpToNextLowQuality " +  chromBoolean[JUMPTONEXTLOWQUALITY].toOffOnString());  		snapshot.addLine("togglejumpToNextAmbiguity " +  chromBoolean[JUMPTONEXTAMBIGUITY].toOffOnString());  		snapshot.addLine("togglejumpToNextBadSourceRead " +  chromBoolean[JUMPTONEXTBADSOURCEREAD].toOffOnString());  		snapshot.addLine("toggleignoreProblemIfBaseCalled " +  chromBoolean[IGNOREPROBLEMIFBASECALLED].toOffOnString());  		snapshot.addLine("toggleShadowReduction " +  chromBoolean[ENABLESHADOWREDUCTION].toOffOnString());  		snapshot.addLine("showPrimerMatches " +  chromBoolean[SHOWPRIMERMATCHES].toOffOnString());  		snapshot.addLine("showSinglePrimerMatch " +  chromBoolean[SHOWSINGLEPRIMERMATCH].toOffOnString());  		/*-----*/		snapshot.addLine("setSinglePrimer  " + ParseUtil.tokenize(singlePrimer.getValue()));		snapshot.addLine("lockSequences " + sequencesLocked.toOffOnString());		Snapshot s = contigPanel.getSnapshot(file);		if (s != null){			snapshot.addLine("getMainContigPanel");			snapshot.addLine("tell It");			snapshot.incorporate(s, true);			snapshot.addLine("endTell");		}		if (extraContigs.size() > 0){			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				Taxon taxon = p.getTaxon();				if (taxon != null){					int it = taxon.getNumber();					snapshot.addLine("showExtraContig " + it);					Snapshot sE = p.getSnapshot(file);					if (sE != null){						snapshot.addLine("tell It");						snapshot.incorporate(sE, true);						snapshot.addLine("endTell");					}				}			}		}		snapshot.addLine("scrollToOverallBase " + contigPanel.getCenterBase());		return snapshot;	}	/*.................................................................................................................*/	void initializeContigPanelSettings(ContigPanel p){		p.setShowA(showA.getValue());		p.setShowC(showC.getValue());		p.setShowG(showG.getValue());		p.setShowT(showT.getValue());		p.setScrollToTouched(chromBoolean[SCROLLTOTOUCHED].getValue());		p.setShowBaseSource(chromBoolean[SHOWBASESOURCE].getValue());		p.setShowCodonPosition(chromBoolean[SHOWCODONPOSITION].getValue());		p.setShowReadName(chromBoolean[SHOWREADNAME].getValue());		//	p.setShowBaseNumberWithinRead(showBaseNumberWithinRead.getValue());		p.setShowReadMatrixConflict(chromBoolean[SHOWREADMATRIXCONFLICT].getValue());		p.setShowReadReadConflict(chromBoolean[SHOWREADREADCONFLICT].getValue());		p.setShowLowerQualSourceConflictsWithHigherQualRead(chromBoolean[SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD].getValue());		p.setDimConflictMarkerThreshold(chromInt[DIMCONFLICTMARKERTHRESHOLD].getValue());		p.setDimLowQualityConflicts(chromBoolean[DIMLOWQUALITYCONFLICTS].getValue());		p.setFadeLowQuality(chromBoolean[FADELOWQUALITY].getValue());		p.setShowFades(chromBoolean[SHOWFADES].getValue());		p.setThickTrace(chromBoolean[THICKTRACE].getValue());		p.setFadeNonSourceRead(chromBoolean[FADENONSOURCEREAD].getValue());		p.setFadeNonSourceLowerQualityRead(chromBoolean[FADENONSOURCELOWERQUALITYREADS].getValue());		p.setFadeQualityThreshold(chromInt[FADELOWQUALITYTHRESHOLD].getValue());		p.setShowAceContigPanel(chromBoolean[SHOWORIGINALUNTRIMMEDPANEL].getValue());		p.setShowMultiReadCallsPanel(chromBoolean[SHOWMULTIREADCALLSPANEL].getValue());		p.setShowOverviewPanel(chromBoolean[SHOWOVERVIEWPANEL].getValue());		p.setShowOriginalImportPanel(chromBoolean[SHOWORIGINALTRIMMEDPANEL].getValue());		p.setChromatogramsOnTop(chromBoolean[CHROMATOGRAMSONTOP].getValue());		p.setFixedChromatoHeight(chromBoolean[FIXEDCHROMATOHEIGHT].getValue());		p.setColorEditedInMatrixByQuality(chromBoolean[COLOREDITEDINMATRIXBYQUALITY].getValue());		p.setColorImportedByQuality(chromBoolean[COLORIMPORTEDBYQUALITY].getValue());		p.setColorReadByQuality(chromBoolean[COLORREADCALLSBYQUALITY].getValue());		p.setColorMultiReadByQuality(chromBoolean[COLORMULTIREADCALLSBYQUALITY].getValue());		p.setColorOverviewByQuality(chromBoolean[COLOROVERVIEWBYQUALITY].getValue());	}	/*.................................................................................................................*/	void addContig(Taxon taxon, Chromatogram[] chroms, Contig contig, Read[] reads){		ContigPanel panel = new ContigPanel( this, (DNAData)data, originalData, qualityData, table, taxon, chroms,  contig, false);		initializeContigPanelSettings(panel);		SequencePanel[] sequences = new SequencePanel[]{panel.originalUntrimmedPanel, panel.originalTrimmedPanel, panel.matrixSeqPanel};		extraContigs.addElement(panel);		addToWindow(panel);		panel.setVisible(true);		ContigControlPanel control = new ContigControlPanel(taxon.getName(), panel);		ContigLinkerPanel linker = new ContigLinkerPanel(panel);		panel.setLinker(linker);		addToWindow(linker);		panel.setControl(control);		addToWindow(control);		for (int i=0; i< viewModule.getEmployeeVector().size(); i++){			Object e = viewModule.getEmployeeVector().elementAt(i);			if (e instanceof ChromInit){				((ChromInit)e).addContext(taxon, contig, panel, reads, sequences, (DNAData)data, getOriginalData(), getQualityData(), table, panel.getID());			}		}		sizeDisplays();	}	/*.................................................................................................................*/	void adjustChromInitsIfPositionChanges(){		for (int i=0; i< viewModule.getEmployeeVector().size(); i++){			Object e = viewModule.getEmployeeVector().elementAt(i);			if (e instanceof ChromInit){				((ChromInit)e).adjustIfPositionChanges();			}		}	}	/*.................................................................................................................*/	void removeContig(ContigPanel panel){		extraContigs.removeElement(panel);		panel.setVisible(false);		ContigControlPanel control = panel.getControl();		control.setVisible(false);		removeFromWindow(panel);		removeFromWindow(control);		sizeDisplays();	}	/*.................................................................................................................*/	public boolean getChromatogramsOnTop() {		return chromBoolean[CHROMATOGRAMSONTOP].getValue();	}	/*.................................................................................................................*/	public static VChromWindow showChromatogram(Contig contig, MesquiteTable table, DNAData matrixData, Taxon taxon, VChromWindow existing, MesquiteModule windowServer, ChromatogramViewer ownerModule, String xmlPrefsString){		if (windowServer == null)			return null;		try {			int count = 0;			for (int i=0; i<contig.getNumReadsToShow(); i++) {				if (!StringUtil.blank(contig.getRead(i).getABIFile()) && !StringUtil.blank(contig.getRead(i).getABIFilePath()))					count++;			}			if (count == 0)				return null;			String[] fileNames = new String[count];			String[] paths = new String[count];			Read[] reads = new Read[count];			count = 0;			for (int i=0; i<contig.getNumReadsToShow(); i++) {				String abiFile = contig.getRead(i).getABIFile();				String abiFilePath = contig.getRead(i).getABIFilePath();				reads[count] = contig.getRead(i);				if (!StringUtil.blank(abiFile) && !StringUtil.blank(abiFilePath)) {					fileNames[count] = abiFile;					paths[count] = abiFilePath;					count++;				}			}			if (paths==null  || fileNames==null)				return null;			Chromatogram[] chromatograms = new Chromatogram[paths.length];			Associable as = matrixData.getTaxaInfo(false);			String[] fileNamesTranslator = null;			String[] primerNamesTranslator = null;			String[] sampleCodesTranslator = null;			if (as != null) {				fileNamesTranslator = ChromaseqUtil.getStringsAssociated(as,ChromaseqUtil.origReadFileNamesRef, taxon.getNumber());				primerNamesTranslator = ChromaseqUtil.getStringsAssociated(as,ChromaseqUtil.primerForEachReadNamesRef, taxon.getNumber());				sampleCodesTranslator = ChromaseqUtil.getStringsAssociated(as, ChromaseqUtil.sampleCodeNamesRef, taxon.getNumber());			}			for (int i = 0; i<paths.length; i++){ //getting chromatograms from all of the reads				File file = new File(paths[i].toString(), fileNames[i].toString());				FileInputStream regIN = new FileInputStream(file);;				BufferedInputStream fileIN = new BufferedInputStream(regIN);				byte[] magicNumArray = new byte[4];				fileIN.read(magicNumArray);				ByteArrayInputStream magicIN = new ByteArrayInputStream(magicNumArray);				DataInputStream magicDIN = new DataInputStream(magicIN);				int magicNum = magicDIN.readInt();				magicIN.reset();				SequenceInputStream seqIN = new SequenceInputStream(magicIN,fileIN);				//				Debugg.println("fileName: " + fileNames[i].toString());				if (magicNum == ABIChromatogram.MagicNum) {					chromatograms[i] = new ABIChromatogram(seqIN,reads[i]);					}				else if (magicNum == SCFChromatogram.MagicNum) {					chromatograms[i] = new SCFChromatogram(seqIN, reads[i]);				}				else throw new IOException("Unknown file type");				if (chromatograms[i]!=null) {					String origName = findNameRefElement(fileNamesTranslator, fileNames[i]);					if (origName != null)						chromatograms[i].setTitle(origName.toString());					else						chromatograms[i].setTitle("Read " + (i+1));					//					chromatograms[i].report("");					if (primerNamesTranslator!=null) {						String primerName = findNameRefElement(primerNamesTranslator, fileNames[i]);						reads[i].setPrimerName(primerName);   //DO NOT set this, as ther primer is now acquired later.					}					if (sampleCodesTranslator!=null) {						String sampleCodeSource = findNameRefElement(sampleCodesTranslator, fileNames[i], 1, 2);						String sampleCode = findNameRefElement(sampleCodesTranslator, fileNames[i], 2, 2);						reads[i].setSampleCode(sampleCode);   //DO NOT set this, as ther primer is now acquired later.						reads[i].setSampleCodeSource(sampleCodeSource);   //DO NOT set this, as ther primer is now acquired later.					}					if (reads[i].getComplemented())						chromatograms[i].reverseComplement(false);									}			}			if (existing == null){				ownerModule.hireAllEmployees(ChromInit.class);				String fragmentName = "";				if (StringUtil.notEmpty(ChromaseqUtil.getGeneName(matrixData)))					fragmentName=" ["+ChromaseqUtil.getGeneName(matrixData)+"]";				VChromWindow cw = new VChromWindow(ownerModule, windowServer, table, matrixData, taxon,"Chromatograms: " + taxon.getName()+fragmentName, chromatograms, contig, reads, xmlPrefsString); 				windowServer.setModuleWindow(cw);				if (!MesquiteThread.isScripting())					cw.setVisible(true);				windowServer.resetContainingMenuBar();				MesquiteModule.resetAllWindowsMenus();				return cw;			}			else {				existing.addContig(taxon, chromatograms, contig, reads);				return existing;			}		}		catch (MalformedURLException ex) {			System.out.println("Malformed URL");		}		catch (IOException ex) {			String exMessage = ex.getMessage();			String exName = ex.getClass().getName();			System.out.println("IO ERROR: " + exName + " : " + exMessage);		}		return null;	}	/* ............................................................................................................... */	/** returns the current Hand cursor for dragging columns, etc. */	public Cursor getHandCursor() {		return handCursor;	}	/*.................................................................................................................*/	/** When called the window will determine its own title.  MesquiteWindows need	 to be self-titling so that when things change (names of files, tree lists, etc.)	 they can reset their titles properly*/	public void resetTitle(){		setTitle(title);	}	public Taxon getTaxon(){		return contigPanel.getTaxon();	}	public void centerPanelAtOverallPosition(int ic){		contigPanel.centerPanelsAtUniversalBase(ic);	}	public int getHomePositionInMatrix(){		return contigPanel.getHomePositionInMatrix();	}	public int getCenterBase(){		return contigPanel.getCenterBase();		}	public void synchChromToTable(boolean synchPosition){		contigPanel.synchChromToTable(synchPosition);	}	/* ............................................................................................................... */	public int getUniversalBaseOfMatrixBase(int ic){		return contigPanel.getUniversalBaseOfMatrixBase(ic);	}	/* ............................................................................................................... */	public  void scrollToMatrixBase(int ic){		contigPanel.scrollToMatrixBase(ic);	}	public  void scrollToOverallBase(int ic){		contigPanel.scrollToUniversalBase(ic);	}	public  void scrollToConsensusBase(int ic){		contigPanel.scrollToConsensusBase(ic);	}	public SequencePanel getSequencePanel(int whichPanel){		return contigPanel.getSequencePanel(whichPanel);	}	public  int getTotalNumPeaks(){		return contigPanel.getTotalNumUniversalBases();	}	public  ContigDisplay getContigDisplay(){		return contigPanel;	}	public boolean extraContigsShown() {		return extraContigs.size()>0;	}	public void scrollsChanged(ContigPanel panel, int center){		if (panel != null && extraContigs != null && extraContigs.size()>0 && sequencesLocked.getValue()){			if (panel == contigPanel){				for (int i = 0; i< extraContigs.size(); i++){					ContigPanel p = (ContigPanel)extraContigs.elementAt(i);					int diff = p.getRelativeLockPos();					//if (p.isShownReversed() != contigPanel.isShownReversed())					//	diff = -diff;					/*(diff = c*f - c1*f1;					diffB = cB*f - c1B*f1;					c1B*f1 = cB*f - diff;					c1B = (cB*f - diff)/f1;					 */					int cB = center;					if (contigPanel.isShownReversed())						cB = -cB;					int c1B = cB-diff;					if (p.isShownReversed())						c1B = -c1B;					// 	Debugg.println("GET diff " + diff);									p.centerPanelsAtUniversalBase(c1B, false, true);					//	Debugg.println("GET diff after  contigPanel.getCenterBase()" + contigPanel.getCenterBase() + " p.getCenterBase() " + + p.getCenterBase() + " difference " + (contigPanel.getCenterBase()-p.getCenterBase()));									ContigLinkerPanel link = p.getLinker();					link.repaint();				}			}			else {				int diff = panel.getRelativeLockPos();				/*diff = c*f - c1*f1;				diffB = cB*f - c1B*f1;				cB = (diff + c1B*f1)/f;				 */				int c1B = center;				if (panel.isShownReversed())					c1B = -c1B;				int cB = c1B+diff;				if (contigPanel.isShownReversed())					cB = -cB;				//if (panel.isShownReversed() != contigPanel.isShownReversed())				//	diff = -diff;				//Debugg.println("diffB " + diff);								contigPanel.centerPanelsAtUniversalBase(cB, false, true);				if (contigPanel.isShownReversed())					cB = -cB;				for (int i = 0; i< extraContigs.size(); i++){					ContigPanel p = (ContigPanel)extraContigs.elementAt(i);					int diff2 = p.getRelativeLockPos();					int c1B2 = cB-diff2;					if (p.isShownReversed())						c1B2 = -c1B2;					p.centerPanelsAtUniversalBase(c1B2, false, true);					ContigLinkerPanel link = p.getLinker();					link.repaint();				}			}		}		else if (extraContigs != null){			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				ContigLinkerPanel link = p.getLinker();				link.repaint();			}		}	}	/*--------------------------------------*/	final int linkerHeight = 24;	/* Resize the chromatogram area and other components.*/	public void sizeDisplays(){		if (contigPanel != null){			int numContigs = extraContigs.size() + 1;			int left = 0;			if (numContigs>1 || showControls.getValue())				left = 24;			int modtest = 1;			if (extraContigs.size() % 2 == 0)				modtest = 0;			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				p.setBounds(left, getHeight()/numContigs*i, getWidth()-left, getHeight()/numContigs-linkerHeight);				p.sizePanels();				ContigControlPanel c = p.getControl();				if (i  % 2 == modtest)					c.setBackground(Color.lightGray);				else 					c.setBackground(ColorDistribution.veryLightGray);				c.setBounds(0, getHeight()/numContigs*i, left, getHeight()/numContigs);				ContigLinkerPanel link = p.getLinker();				link.setBounds(left, getHeight()/numContigs*(i+1)-linkerHeight, getWidth()-left, linkerHeight);			}			contigPanel.setBounds(left,getHeight()-getHeight()/numContigs, getWidth()-left, getHeight()/numContigs);			contigPanel.sizePanels();			if (numContigs>1 || showControls.getValue()){				ContigControlPanel c = contigPanel.getControl();				if (c == null){					c = new ContigControlPanel(contigPanel.getTaxon().getName(), contigPanel);					contigPanel.setControl(c);					c.setVisible(true);					addToWindow(c);				}				c.setBounds(0, getHeight()-getHeight()/numContigs, left, getHeight()/numContigs);				c.repaint();				//c.setBackground(ColorDistribution.lightGreen);				}			contigPanel.requestFocusInWindow();		}	}	/* Resize the chromatogram area and other components.*/	public void dispose(){		super.dispose();		if (data != null)			data.removeListener(this);		if (originalData != null)			originalData.removeListener(this);		if (qualityData != null)			qualityData.removeListener(this);		if (extraContigs != null){			for (int i = 0; i< extraContigs.size(); i++){				ContigPanel p = (ContigPanel)extraContigs.elementAt(i);				removeContig(p);				p.dispose();			}			extraContigs.removeAllElements();		}		if (contigPanel != null)			contigPanel.dispose();	}	/** passes which object changed, along with optional Notification object with details (e.g., code number (type of change) and integers (e.g. which character))*/	public void changed(Object caller, Object obj, Notification notification){		if (obj == data){			if (data.getTaxa().whichTaxonNumber(contigPanel.getTaxon())<0){				closeWindow();			}			else if (extraContigs != null)				for (int i = 0; i< extraContigs.size(); i++){					ContigPanel p = (ContigPanel)extraContigs.elementAt(i);					if (data.getTaxa().whichTaxonNumber(p.getTaxon())<0)						removeContig(p);					p.dispose();				}		}	}	/** passes which object was disposed*/	public void disposing(Object obj){		if (obj == data || obj == qualityData)			closeWindow();	}	/** Asks whether it's ok to delete the object as far as the listener is concerned (e.g., is it in use?)*/	public boolean okToDispose(Object obj, int queryUser){		return true;	}	/*--------------------------------------*/	/*Sets the size of the window (setSize and setBounds should not be used!!!>  <b>(overrides method of MesquiteWindow)</b>*/	public void setWindowSize(int w, int h){		super.setWindowSize(w,h);		sizeDisplays();	}	/*--------------------------------------*/	/* Called when the window has been resized, e.g. by user. <b>(overrides method of MesquiteWindow)</b>*/	public void windowResized(){		sizeDisplays();	}	public void setVisible(boolean v){		super.setVisible(v);		contigPanel.requestFocusInWindow();	}	ChromWindowPalette chromPalette;	protected ToolPalette makeToolPalette(){		MesquiteCommand sliderCommand = MesquiteModule.makeCommand("magnify", this);		MesquiteCommand shadowCommand = MesquiteModule.makeCommand("shadowOffset", this);		MesquiteCommand shadowRedCommand = MesquiteModule.makeCommand("shadowReduction", this);		chromPalette = new ChromWindowPalette(ownerModule, this, sliderCommand, shadowCommand, shadowRedCommand);		return chromPalette;	}	public DNAData getMatrixData(){		return data;	}	public DNAData getOriginalData(){		return originalData;	}	public ContinuousData getQualityData(){		return qualityData;	}	public boolean showPrimers(){		return chromBoolean[SHOWPRIMERMATCHES].getValue();	}	public Color getBackgroundColor(){		return backgroundColor;	}	public boolean getShowSinglePrimerMatch(){		return chromBoolean[SHOWSINGLEPRIMERMATCH].getValue();	}	public boolean getIgnoreProblemIfBaseCalled() {		return chromBoolean[IGNOREPROBLEMIFBASECALLED].getValue();	}	public String getSinglePrimer(){		if (singlePrimer==null)			return "";		return singlePrimer.getValue();	}	/*.................................................................................................................*/	public void startPrimerShow(){		chromBoolean[SHOWPRIMERMATCHES].setValue(true);		contigPanel.setUpPrimers();		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setUpPrimers();		}	}	/*.................................................................................................................*/	public void redrawChromatPanels () {		contigPanel.repaintPanels();		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.repaintPanels();		}	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Scrolls to overall base", "[base]", commandName, "scrollToOverallBase")) {			int it= MesquiteInteger.fromFirstToken(arguments, new MesquiteInteger(0));			if (MesquiteInteger.isCombinable(it))				scrollToOverallBase(it);		}		else if (checker.compare(this.getClass(), "Untrim ends", null, commandName, "untrimEnds")) {			contigPanel.untrimEnds();		}		else if (checker.compare(this.getClass(), "Convert selected to gaps", null, commandName, "selectedToGaps")) {			contigPanel.selectedToGaps();		}		else if (checker.compare(this.getClass(), "Convert trimmable to gaps", null, commandName, "trimmableToGaps")) {			contigPanel.trimmableToGaps();		}		else if (checker.compare(this.getClass(), "Revert selected to called", null, commandName, "selectedToCalled")) {			contigPanel.selectedToRevert();		}		else if (checker.compare(this.getClass(), "Sets whether shading multiple sequences are locked", "[on; off]", commandName, "lockSequences")) {			sequencesLocked.toggleValue(new Parser().getFirstToken(arguments));			setSequencesLocked(sequencesLocked.getValue());		}		else if (checker.compare(this.getClass(), "Shows whether primer shown is the single specified primer", "[on; off]", commandName, "showSinglePrimerMatch")) {			if (ignoreCommand())				return null;			chromBoolean[SHOWSINGLEPRIMERMATCH].toggleValue(new Parser().getFirstToken(arguments));			setShowSinglePrimerMatch(chromBoolean[SHOWSINGLEPRIMERMATCH].getValue());		}		else if (checker.compare(this.getClass(), "Sets the single primer", "[primer name]", commandName, "setSInglePrimer")) {			String primerName =  new Parser().getFirstToken(arguments);			boolean success = true;			if (StringUtil.blank(primerName) && !MesquiteThread.isScripting()) {				if (singlePrimer==null)					singlePrimer = new MesquiteString("");				success = QueryDialogs.queryShortString(viewModule.containerOfModule(),"Primer Name", "Name of primer to display", singlePrimer);			}			else				singlePrimer.setValue(new Parser().getFirstToken(arguments));			if (success) {				if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){					mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;					mod.setSinglePrimer(singlePrimer.getValue());				}				if (chromBoolean[SHOWPRIMERMATCHES].getValue())					startPrimerShow();			}		}		else if (checker.compare(this.getClass(), "Shows whether primers are shown matched", "[on; off]", commandName, "showPrimerMatches")) {			if (ignoreCommand())				return null;			chromBoolean[SHOWPRIMERMATCHES].toggleValue(new Parser().getFirstToken(arguments));			setShowPrimerMatches(chromBoolean[SHOWPRIMERMATCHES].getValue());		}		else if (checker.compare(this.getClass(), "Shows whether primer info comes from BTOL Database", "[on; off]", commandName, "useBTOLDatabase")) {			boolean currentValue = useBTOLDatabase.getValue();			useBTOLDatabase.toggleValue(new Parser().getFirstToken(arguments));			if (currentValue!=useBTOLDatabase.getValue()){				if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){					mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;					mod.setPrimerInfoFromDatabase(useBTOLDatabase.getValue());				}				if (chromBoolean[SHOWPRIMERMATCHES].getValue()){					contigPanel.setUpPrimers();					for (int i = 0; i< extraContigs.size(); i++){						ContigPanel p = (ContigPanel)extraContigs.elementAt(i);						p.setUpPrimers();					}				}			}			if (!MesquiteThread.isScripting())				redrawChromatPanels();		}		else if (checker.compare(this.getClass(), "Set Primer Sequence File...", null, commandName, "setPrimerSequenceFile")) {			if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){				mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;				mod.resetPrimersFile();				if (chromBoolean[SHOWPRIMERMATCHES].getValue()){					contigPanel.setUpPrimers();					for (int i = 0; i< extraContigs.size(); i++){						ContigPanel p = (ContigPanel)extraContigs.elementAt(i);						p.setUpPrimers();					}				}			}		}		else if (checker.compare(this.getClass(), "Returns main contig panel", null, commandName, "getMainContigPanel")) {			return contigPanel;		}		else if (checker.compare(this.getClass(), "Shows extra contig (taxon, sequence)", "[number of taxon]", commandName, "showExtraContig")) {			if (data != null){				Taxon taxon = null;				MesquiteInteger pos = new MesquiteInteger(0);				int it= MesquiteInteger.fromFirstToken(arguments, pos);				if (!MesquiteInteger.isCombinable(it)){					if (MesquiteThread.isScripting())						return null;					taxon = data.getTaxa().userChooseTaxon(this, "Choose extra sequence to show");					if (taxon == null)						return null;					it = data.getTaxa().whichTaxonNumber(taxon);				}				else taxon = data.getTaxa().getTaxon(it);								this.table = (CMTable)table;				this.data = (DNAData)data;				Contig contig = ChromaseqUtil.getContig(data, it, ownerModule, true);								if (contig==null)					return null;				VChromWindow.showChromatogram(contig, table, data,  taxon, this, windowServer, (ChromatogramViewer)viewModule, xmlPrefsString);				return extraContigs.elementAt(extraContigs.size()-1);			}		}		else if (checker.compare(this.getClass(), "Shadow offset chromatograms", null, commandName, "shadowOffset")) {			MesquiteInteger io = new MesquiteInteger(0);			double x = MesquiteDouble.fromString(arguments, io);			if (MesquiteDouble.isCombinable(x)){				int os = (int)((x-2.5)*20);				contigPanel.setShadowOffset(os);			}		}		else if (checker.compare(this.getClass(), "Shadow reduction chromatograms", null, commandName, "shadowReduction")) {			MesquiteInteger io = new MesquiteInteger(0);			double x= MesquiteDouble.fromString(arguments, io);			if (MesquiteDouble.isCombinable(x)){				contigPanel.setShadowReduction(x);			}		}		else if (checker.compare(this.getClass(), "Magnify chromatograms", null, commandName, "magnify")) {			MesquiteInteger io = new MesquiteInteger(0);			double x= MesquiteDouble.fromString(arguments, io);			if (MesquiteDouble.isCombinable(x)){				contigPanel.setMagnification(3.0 - x/2);				/*(3 - x/2)				 0 -- 3.0				 1-- 2.5				 2 --  2				 3 -- 1.5				 4-- 1.0				 5-- 0.5*/			}		}		else if (checker.compare(this.getClass(), "Touched with arrow.", null, commandName, "arrowTouch")) {		}		else if (checker.compare(this.getClass(), "Sets the threshold below which low quality bases will be faded", "[fadeLowQualityThreshold]", commandName, "setFadeThreshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Fading Threshold", "Threshold for fading low quality bases:", chromInt[FADELOWQUALITYTHRESHOLD].getValue(), 0, 100);			if (newNum>0  && newNum!=chromInt[FADELOWQUALITYTHRESHOLD].getValue()) {				setChromInt(FADELOWQUALITYTHRESHOLD,newNum);				repaintAll();			}		}		else if (checker.compare(this.getClass(), "Sets the quality threshold for arrow keys jumping between low quality bases", "[jumpQualityThreshold]", commandName, "setJumpQualityThreshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			String help = "Holding down the Option or Alt key and using the right and left arrow keys will cause the chromatogram viewer to jump to the next or previous bases in the Original Untrimmed ";			help += " sequence of quality less than the jump quality threshold value.  The jump quality threshold is set in this dialog box.";			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Jump Quality Threshold", "Jump between bases with quality less than:", help, chromInt[JUMPQUALITYTHRESHOLD].getValue(), 0, 100);			if (newNum>0  && newNum!=chromInt[JUMPQUALITYTHRESHOLD].getValue()) {				setChromInt(JUMPQUALITYTHRESHOLD,newNum);			}		}		else if (checker.compare(this.getClass(), "Sets the quality threshold for arrow keys jumping between bases with conflicting reads", "[jumpConflictThreshold]", commandName, "setJumpConflictThreshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			String help = "Holding down the Control key and using the right and left arrow keys will cause the chromatogram viewer to jump to the next or previous bases in the Original Untrimmed ";			help += " sequence in which two reads, both of quality greater than or equal to the jump conflict threshold value, differ in their calls.  The jump conflict threshold is set in this dialog box.";			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Jump Conflict Threshold", "Jump between bases with conflict quality greater than:", help, chromInt[JUMPCONFLICTTHRESHOLD].getValue(), 0, 100);			if (newNum>0  && newNum!=chromInt[JUMPCONFLICTTHRESHOLD].getValue()) {				setChromInt(JUMPCONFLICTTHRESHOLD,newNum);			}		}		else if (checker.compare(this.getClass(), "Sets the quality threshold below conflcits will be dimmed", "[dimConflictMarkerThreshold]", commandName, "setDimConflictMarkerTheshold")) {			MesquiteInteger pos = new MesquiteInteger(0);			int newNum= MesquiteInteger.fromFirstToken(arguments, pos);			if (!MesquiteInteger.isCombinable(newNum))				newNum = MesquiteInteger.queryInteger(viewModule.containerOfModule(), "Set Dimming Threshold", "Quality threshold for dimming conflicts:", chromInt[DIMCONFLICTMARKERTHRESHOLD].getValue(), 0, 100);			if (newNum>0  && newNum!=chromInt[DIMCONFLICTMARKERTHRESHOLD].getValue()) {				setChromInt(DIMCONFLICTMARKERTHRESHOLD,newNum);				repaintAll();			}		}		else if (checker.compare(this.getClass(), "Forces a full reregistration of these contigs/reads/etc", "[none]", commandName, "forceRegistrationContig")) {			contigPanel.fullReregistration();			repaintAll();		}		else if (checker.compare(this.getClass(), "Forces a full reregistration of these contigs/reads/etc", "[none]", commandName, "forceRegistrationMatrix")) {			ChromaseqUtil.inferRegistryData(registryData);			contigPanel.fullReregistration();			repaintAll();		}		else if (checker.compare(this.getClass(), "Forces a recalculation of the universalMapper and contigMapper", "[none]", commandName, "recalculateMappers")) {			ChromaseqUniversalMapper universalMapper = contigPanel.getUniversalMapper();			if (universalMapper!=null)				universalMapper.reset(false);			repaintAll();		}		else if (checker.compare(this.getClass(), "Forces a recalculation of the universalMapper and contigMapper", "[none]", commandName, "recalculateMappersInfer")) {			ChromaseqUniversalMapper universalMapper = contigPanel.getUniversalMapper();			if (universalMapper!=null)				universalMapper.reset(true);			repaintAll();		}		else if (checker.compare(this.getClass(), "Dumps some information from the universalMapper and contigMapper", "[none]", commandName, "dumpMappers")) {			ChromaseqUniversalMapper universalMapper = contigPanel.getUniversalMapper();			if (universalMapper!=null)				Debugg.println(universalMapper.toString());		}		else if (checker.compare(this.getClass(), "Specifies to chromaseq whether the sequence is reverse complemented into the matrix", "[on; off]", commandName, "toggleIsReverseComplemented")) {			matrixSequenceIsReverseComplemented.toggleValue(new Parser().getFirstToken(arguments));			contigPanel.setReverseComplemented(matrixSequenceIsReverseComplemented.getValue());		}		else if (checker.compare(this.getClass(), "Sets whether control bar is shown", "[on; off]", commandName, "showControls")) {			showControls.toggleValue(new Parser().getFirstToken(arguments));			sizeDisplays();		}		else if (checker.compare(this.getClass(), "Sets to standard style", "[none]", commandName, "styleStandard")) {			setToStandardStyle();			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets to style that Bets likes.", "[none]", commandName, "stylePhoenix")) {			setToAEAStyle();			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets to style that David likes.", "[none]", commandName, "styleCorvallis")) {			setToDRMStyle();			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets to style that Wayne likes.", "[none]", commandName, "styleVancouver")) {			setToWPMStyle();			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases called for each read are colored by quality scores", "[on; off]", commandName, "toggleColorReadCallsByQuality")) {			if (ignoreCommand()) return null;			setChromBoolean(COLORREADCALLSBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases called for the multiread panel are colored by quality scores", "[on; off]", commandName, "toggleColorMultiReadByQuality")) {			if (ignoreCommand()) return null;			setChromBoolean(COLORMULTIREADCALLSBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases called for the overview panel are colored by quality scores", "[on; off]", commandName, "toggleColorOverviewByQuality")) {			if (ignoreCommand()) return null;			setChromBoolean(COLOROVERVIEWBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases in Edited in Matrix line are colored by quality scores", "[on; off]", commandName, "toggleColorEditedInMatrixByQuality")) {			if (ignoreCommand()) return null;			setChromBoolean(COLOREDITEDINMATRIXBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases are colored by quality scores", "[on; off]", commandName, "toggleColorImportedByQuality")) {			if (ignoreCommand()) return null;			setChromBoolean(COLORIMPORTEDBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bases are colored by quality scores", "[on; off]", commandName, "toggleColorByQuality")) {  // save as toggleColorImportedByQuality, here to support older scripts			if (ignoreCommand()) return null;			setChromBoolean(COLORIMPORTEDBYQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the original, untrimmed sequence direclty from Phred/Phrap/Mesquite is shown", "[on; off]", commandName, "toggleShowAceContigPanel")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWORIGINALUNTRIMMEDPANEL,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the multi read panel is shown", "[on; off]", commandName, "toggleShowMultiReadCallsPanel")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWMULTIREADCALLSPANEL,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the overview panel is shown", "[on; off]", commandName, "toggleShowOverviewPanel")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWOVERVIEWPANEL,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the original trimmed imported sequence is shown", "[on; off]", commandName, "toggleShowOriginalImportPanel")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWORIGINALTRIMMEDPANEL,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether Chromatograms are on top or not", "[on; off]", commandName, "toggleChromatogramsOnTop")) {			if (ignoreCommand()) return null;			setChromBoolean(CHROMATOGRAMSONTOP,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether Chromatograms are on top or not", "[on; off]", commandName, "toggleFixedChromatoHeight")) {			if (ignoreCommand()) return null;			setChromBoolean(FIXEDCHROMATOHEIGHT,new Parser().getFirstToken(arguments));			contigPanel.sizePanels();			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the trace is shown using thick lines", "[on; off]", commandName, "toggleThickTrace")) {			if (ignoreCommand()) return null;			setChromBoolean(THICKTRACE,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the trace is shown using sequencher colors", "[on; off]", commandName, "toggleUseSequencherColors")) {			if (ignoreCommand()) return null;			setChromBoolean(USESEQUENCHERCOLORS,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of low quality", "[on; off]", commandName, "toggleFadeLowQuality")) {			if (ignoreCommand()) return null;			setChromBoolean(FADELOWQUALITY,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether any fades are shown", "[on; off]", commandName, "toggleShowFades")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWFADES,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of where they are not the source", "[on; off]", commandName, "toggleFadeNonSourceRead")) {			if (ignoreCommand()) return null;			setChromBoolean(FADENONSOURCEREAD,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether reads are dimmed in regions of where they are not the source AND of lower quality than the source", "[on; off]", commandName, "toggleFadeNonSourceLowerQualityRead")) {			if (ignoreCommand()) return null;			setChromBoolean(FADENONSOURCELOWERQUALITYREADS,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether shading indicates whether a chromatogram's call is different from matrix state", "[on; off]", commandName, "toggleShowReadMatrixConflict")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWREADMATRIXCONFLICT,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether bar indicates whether there are differences among the Phred calls for each read.", "[on; off]", commandName, "toggleShowReadReadConflict")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWREADREADCONFLICT,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether to draw a box around the Phred calls for which the a lower quality read is the source and this conflicts with a higher quality read.", "[on; off]", commandName, "toggleShowLowerQualSourceConflictsWithHigherQualRead")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the name of the read is shown", "[on; off]", commandName, "toggleShowReadName")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWREADNAME,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the red boxes for low quality conflicts are dimmed below the bases in the Original Untrimmed listing", "[on; off]", commandName, "toggleDimLowQualityConflicts")) {			if (ignoreCommand()) return null;			setChromBoolean(DIMLOWQUALITYCONFLICTS,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether shadow reduction is enabled", "[on; off]", commandName, "toggleShadowReduction")) {			if (ignoreCommand()) return null;			chromBoolean[ENABLESHADOWREDUCTION].toggleValue(new Parser().getFirstToken(arguments));			chromPalette.setShadowSlidersVisible(chromBoolean[ENABLESHADOWREDUCTION].getValue());			contigPanel.setShadowOffset(0);			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the view is the overview", "[on; off]", commandName, "toggleViewOverview")) {		}		else if (checker.compare(this.getClass(), "Sets whether the view is the chromatogram view", "[on; off]", commandName, "toggleViewChromatograms")) {		}		//=======================================		else if (checker.compare(this.getClass(), "Sets whether the A trace is shown", "[on; off]", commandName, "toggleShowA")) {			showA.toggleValue(new Parser().getFirstToken(arguments));			setShowA(showA.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the C trace is shown", "[on; off]", commandName, "toggleShowC")) {			showC.toggleValue(new Parser().getFirstToken(arguments));			setShowC(showC.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the G trace is shown", "[on; off]", commandName, "toggleShowG")) {			showG.toggleValue(new Parser().getFirstToken(arguments));			setShowG(showG.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the T trace is shown", "[on; off]", commandName, "toggleShowT")) {			showT.toggleValue(new Parser().getFirstToken(arguments));			setShowT(showT.getValue());			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether touching on the chromatograms centers the view to that base", "[on; off]", commandName, "toggleScrollToTouched")) {			if (ignoreCommand()) return null;			setChromBoolean(SCROLLTOTOUCHED,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether single selected bases are deselected when the chromatogram panels are scrolled", "[on; off]", commandName, "toggleTurnOffEditOnMove")) {			if (ignoreCommand()) return null;			setChromBoolean(TURNOFFEDITONMOVE,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether single selected bases are deselected when the chromatogram panels are scrolled", "[on; off]", commandName, "turnOffEditOnMove")) {			if (ignoreCommand()) return null;			setChromBoolean(TURNOFFEDITONMOVE,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the source of the base (that is, the read Phrap chose as the primary one fro that base) is marked by a brown bar", "[on; off]", commandName, "toggleShowBaseSource")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWBASESOURCE,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the codon position of a base is indicated by color", "[on; off]", commandName, "toggleShowCodonPosition")) {			if (ignoreCommand()) return null;			setChromBoolean(SHOWCODONPOSITION,new Parser().getFirstToken(arguments));			repaintAll();		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next problem base", "[on; off]", commandName, "toggleJumpToNextBadSourceRead")) {			if (ignoreCommand()) return null;			setChromBoolean(JUMPTONEXTBADSOURCEREAD,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next base", "[on; off]", commandName, "toggleJumpToNextBase")) {			if (ignoreCommand()) return null;			setChromBoolean(JUMPTONEXTBASE,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next low quality base", "[on; off]", commandName, "toggleJumpToNextLowQuality")) {			if (ignoreCommand()) return null;			setChromBoolean(JUMPTONEXTLOWQUALITY,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys ignore problems if the base has already been called", "[on; off]", commandName, "toggleIgnoreProblemIfBaseCalled")) {			if (ignoreCommand()) return null;			setChromBoolean(IGNOREPROBLEMIFBASECALLED,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next read-read conflict", "[on; off]", commandName, "toggleJumpToNextReadReadConflict")) {			if (ignoreCommand()) return null;			setChromBoolean(JUMPTONEXTREADREADCONFLICT,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next read-matrix conflict", "[on; off]", commandName, "toggleJumpToNextReadMatrixConflict")) {			if (ignoreCommand()) return null;			setChromBoolean(JUMPTONEXTREADMATRIXCONFLICT,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Sets whether the left and right arrow keys move to the previous or next matrix value with an IUPAC ambiguity code", "[on; off]", commandName, "toggleJumpToNextAmbiguity")) {			if (ignoreCommand()) return null;			setChromBoolean(JUMPTONEXTAMBIGUITY,new Parser().getFirstToken(arguments));		}		else if (checker.compare(this.getClass(), "Shows the matrix", null, commandName, "showMatrix")) {			MesquiteWindow f = ownerModule.getEmployer().containerOfModule();			if (f!= null)				f.show();		}		else if (checker.compare(this.getClass(), "Saves current settings as defaults", "[none]", commandName, "saveDefaults")) {			for (int i=0;i<numChromBooleans; i++) {				defaultChromBoolean[i] = chromBoolean[i].getValue();			}			for (int i=0;i<numChromInts; i++) {				defaultChromInt[i] = chromInt[i].getValue();			}			viewModule.storePreferences();		}		else if (checker.compare(this.getClass(), "Saves current settings as defaults", "[none]", commandName, "toggleIgnoreFileSettings")) {			ignoreFileSettings.toggleValue(new Parser().getFirstToken(arguments));			viewModule.storePreferences();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	private boolean ignoreCommand(){		return (ignoreFileSettings.getValue() && MesquiteThread.isScripting());	}	private void setShowPrimerMatches(boolean b){		chromBoolean[SHOWPRIMERMATCHES].setValue(b);		if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){			mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;			mod.setShowPrimers(chromBoolean[SHOWPRIMERMATCHES].getValue());		}		if (chromBoolean[SHOWPRIMERMATCHES].getValue()){			startPrimerShow();		}		else if (!MesquiteThread.isScripting())			redrawChromatPanels();	}	private void setShowSinglePrimerMatch(boolean b){		chromBoolean[SHOWSINGLEPRIMERMATCH].setValue(b);		if (viewModule instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){			mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)viewModule;			mod.setShowSinglePrimerMatch(chromBoolean[SHOWSINGLEPRIMERMATCH].getValue());		}		if (chromBoolean[SHOWPRIMERMATCHES].getValue()) {			startPrimerShow();			if (!MesquiteThread.isScripting())				redrawChromatPanels();		}	}	/*.................................................................................................................*/	private void setShowA(boolean show){		contigPanel.setShowA(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowA(show);		}	}	private void setShowC(boolean show){		contigPanel.setShowC(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowC(show);		}	}	private void setShowG(boolean show){		contigPanel.setShowG(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowG(show);		}	}	private void setShowT(boolean show){		contigPanel.setShowT(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowT(show);		}	}	public void setScrollToTouched(boolean s){		contigPanel.setScrollToTouched(s);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setScrollToTouched(s);		}	}	//	public void setTurnOffEditOnMove(boolean s){	//	}	public void setShowBaseSource(boolean s){		contigPanel.setShowBaseSource(s);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowBaseSource(s);		}	}	public void setShowCodonPosition(boolean s){		contigPanel.setShowCodonPosition(s);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowCodonPosition(s);		}	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		contigPanel.setShowReadName(showReadName);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowReadName(showReadName);		}	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		contigPanel.setShowBaseNumberWithinRead(showBaseNumberWithinRead);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowBaseNumberWithinRead(showBaseNumberWithinRead);		}	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean show) {		BasicChromatogramPanel.SHOWREADMATRIXCONFLICTDEFAULT = show;		contigPanel.setShowReadMatrixConflict(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowReadMatrixConflict(show);		}	}	/*.................................................................................................................*/	public void setShowReadReadConflict(boolean show) {		contigPanel.setShowReadReadConflict(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowReadReadConflict(show);		}	}	/*.................................................................................................................*/	public void setShowLowerQualSourceConflictsWithHigherQualRead(boolean show) {		contigPanel.setShowLowerQualSourceConflictsWithHigherQualRead(show);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowLowerQualSourceConflictsWithHigherQualRead(show);		}	}	/*.................................................................................................................*/	public void setDimConflictMarkerThreshold(int dimConflictMarkerThreshold) {		contigPanel.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		}	}	/*.................................................................................................................*/	public void setDimLowQualityConflicts(boolean dimLowQualityConflicts) {		contigPanel.setDimLowQualityConflicts(dimLowQualityConflicts);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setDimLowQualityConflicts(dimLowQualityConflicts);		}	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		contigPanel.setFadeLowQuality(fadeLowQuality);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeLowQuality(fadeLowQuality);		}	}	/*.................................................................................................................*/	public void setShowFades(boolean showFades) {		contigPanel.setShowFades(showFades);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setShowFades(showFades);		}		if (showFadesMenuItem!=null) {			if (showFades)				showFadesMenuItem.setName("Don't Show Fades");			else				showFadesMenuItem.setName("Show Fades");			ownerModule.resetContainingMenuBar();		}	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		contigPanel.setFadeNonSourceRead(fadeNonSourceRead);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeNonSourceRead(fadeNonSourceRead);		}	}	/*.................................................................................................................*/	public void setFadeNonSourceLowerQualityRead(boolean fadeNonSourceLowerQualityRead) {		contigPanel.setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead);		}	}	/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		contigPanel.setFadeQualityThreshold(fadeQualityThreshold);		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setFadeQualityThreshold(fadeQualityThreshold);		}	}	/*.................................................................................................................*/	public void setSequencesLocked(boolean seqLocked) {		sequencesLocked.setValue(seqLocked);		contigPanel.setSequencesLocked(seqLocked);		int centerMain = contigPanel.getCenterBase();		if (contigPanel.isShownReversed())			centerMain = -centerMain;		for (int i = 0; i< extraContigs.size(); i++){			ContigPanel p = (ContigPanel)extraContigs.elementAt(i);			p.setSequencesLocked(seqLocked);			int centerThis = p.getCenterBase();			if (p.isShownReversed())				centerThis = -centerThis;			int diff = centerMain - centerThis;			//	Debugg.println("SET diff " + diff);			p.setRelativeLockPos(diff);		}	}	/*.................................................................................................................*/	public void setColorImportedByQuality(boolean cbQ) {		contigPanel.setColorImportedByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorReadCallsByQuality(boolean cbQ) {		contigPanel.setColorReadByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorMultiReadByQuality(boolean cbQ) {		contigPanel.setColorMultiReadByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorOverviewByQuality(boolean cbQ) {		contigPanel.setColorOverviewByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorEditedInMatrixByQuality(boolean cbQ) {		contigPanel.setColorEditedInMatrixByQuality(cbQ);	}	/*.................................................................................................................*/	public void setThickTrace(boolean thickTrace) {		contigPanel.setThickTrace(thickTrace);	}	/*.................................................................................................................*/	public void setUseSequencherColors(boolean useSequencherColors)  {		contigPanel.setUseSequencherColors(useSequencherColors);	}	/*.................................................................................................................*/	public boolean getUseSequencherColors()  {		return chromBoolean[USESEQUENCHERCOLORS].getValue();	}	/*.................................................................................................................*/	public static String findNameRefElement(String[] namesTranslator, String changedName){		if (namesTranslator == null || changedName == null)			return changedName;		for (int i = 0; i*2+1<namesTranslator.length; i++){			if (StringUtil.stringsEqualIgnoreCaseIgnoreBlanksUnderlines(changedName,namesTranslator[i*2]))				return namesTranslator[i*2+1];		}		return changedName;	}	/*.................................................................................................................*/	public static String findNameRefElement(String[] namesTranslator, String changedName, int whichElement, int numElements){		if (namesTranslator == null || changedName == null)			return changedName;		for (int i = 0; i*(numElements+1)+whichElement<namesTranslator.length; i++){   //DavidJan07: OK?			if (StringUtil.stringsEqualIgnoreCaseIgnoreBlanksUnderlines(changedName,namesTranslator[i*(numElements+1)]))				return namesTranslator[i*(numElements+1)+whichElement];		}		return changedName;	}	public boolean getMatrixSequenceIsReverseComplemented() {		return matrixSequenceIsReverseComplemented.getValue();	}	public void setMatrixSequenceIsReverseComplemented(boolean b) {		matrixSequenceIsReverseComplemented.setValue(b);	}}class ContigLinkerPanel extends MesquitePanel implements SequenceMatchCalc{	ContigPanel parent, otherPanel;	MatrixSequence mySeq, refSeq;	String mySequence, otherSequence;	SequenceCanvas mySeqCanvas, refSeqCanvas;	Color[] match;	public ContigLinkerPanel(ContigPanel parent){		this.parent = parent;		SequencePanel mySeqPanel = parent.getSequencePanel(2);		otherPanel = (ContigPanel)parent.window.getContigDisplay();		SequencePanel refSeqPanel = otherPanel.getSequencePanel(2);		refSeqCanvas = refSeqPanel.getCanvas();		mySeq = (MatrixSequence)mySeqPanel.getSequence();		mySeqCanvas = mySeqPanel.getCanvas();		refSeq = (MatrixSequence)refSeqPanel.getSequence();		//setBackground(Color.blue);	}	MesquitePopup popup=null;	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		if (MesquiteEvent.rightClick(modifiers) || MesquiteEvent.controlKeyDown(modifiers)){			if (popup==null) {				popup = new MesquitePopup(this);				popup.add(new MesquiteMenuItem("Align", parent.window.getOwnerModule(), new MesquiteCommand("align", this)));				add(popup);			}			popup.show(this, x,y);		}	}	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Tries to align this with base contig", null, commandName, "align")) {			alignToRef();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	void alignToRef(){		int center = mySeqCanvas.getLocalIndexFromUniversalBase(parent.getCenterBase());		int otherCenter = refSeqCanvas.getLocalIndexFromUniversalBase(otherPanel.getCenterBase());		int centerAsViewed = center;		int otherCenterAsViewed = otherCenter;				//first, align sequences		long[] mySequence = mySeq.getSequenceAsLongs();		long[] otherSequence = refSeq.getSequenceAsLongs();		int[][] subs = AlignUtil.getDefaultSubstitutionCosts(DNAState.maxDNAState +1); 		MesquiteInteger gapOpen = new MesquiteInteger();		MesquiteInteger gapExtend = new MesquiteInteger();		MesquiteInteger gapOpenTerminal = new MesquiteInteger();		MesquiteInteger gapExtendTerminal = new MesquiteInteger();		AlignUtil.getDefaultGapCosts(gapOpen, gapExtend, gapOpenTerminal, gapExtendTerminal); 		gapOpenTerminal.setValue(1);		gapExtendTerminal.setValue(1);		PairwiseAligner aligner = new PairwiseAligner(true,  subs, gapOpen.getValue(), gapExtend.getValue(), gapOpenTerminal.getValue(), gapExtendTerminal.getValue(), 4);		aligner.setMaintainOrder(true);		MesquiteNumber score = new MesquiteNumber();		if (mySeqCanvas.isShownReversed()) {			reverse(mySequence);			centerAsViewed = mySequence.length-center-1;		}		if (mySeqCanvas.isShownComplemented())			complement(mySequence);		if (refSeqCanvas.isShownReversed()){			otherCenterAsViewed = otherSequence.length-otherCenter-1;			reverse(otherSequence);		}		if (refSeqCanvas.isShownComplemented())			complement(otherSequence);		long[][] results = aligner.alignSequences( mySequence, otherSequence, true, score);		//now, find region of overlap between aligned sequences		int firstMy = -1; 		int lastMy = -1;		int firstOther = -1; 		int lastOther = -1;		for (int ic = 0; ic<results.length; ic++){			if (DNAState.isCombinable(results[ic][0])) {				if (firstMy < 0)					firstMy = ic;				lastMy = ic;			}			if (DNAState.isCombinable(results[ic][1])) {				if (firstOther < 0)					firstOther = ic;				lastOther = ic;			}		}		int firstOverlap = -1;		int lastOverlap = -1;		if (firstMy<firstOther){ //my starts to left			if (lastMy < firstOther) //no overlap				;			else if (lastOther<= lastMy) { //other contained in my				firstOverlap = firstOther;				lastOverlap = lastOther;			}			else {  //partial overlap				firstOverlap = firstOther;				lastOverlap = lastMy;			}		}		else {  //other starts to left			if (lastMy < firstOther) //no overlap				;			else if (lastMy<= lastOther) { //my contained in other				firstOverlap = firstMy;				lastOverlap = lastMy;			}			else {  //partial overlap				firstOverlap = firstMy;				lastOverlap = lastOther;			}		}				//OK, there is overlap, so adjust centering		if (firstOverlap >=0){  //there is overlap, so adjust centering for alignment			//first find if reference sequence is already shown in region of overlap			int countCenterOther = 0;			int icAtCurrentCenter = -1;			for (int ic = 0; ic<results.length && icAtCurrentCenter < 0; ic++){				if (!DNAState.isInapplicable(results[ic][1])){					if (countCenterOther == otherCenterAsViewed)						icAtCurrentCenter = ic;					countCenterOther++;				}			}			if (icAtCurrentCenter >= firstOverlap && icAtCurrentCenter <= lastOverlap){				//now center my at icAtCurrentCenter				int countMy = 0;				for (int ic = 0; ic<icAtCurrentCenter; ic++){					if (!DNAState.isInapplicable(results[ic][0]))						countMy++;				}				int centerMyAt = countMy;				if (mySeqCanvas.isShownReversed())					centerMyAt = mySequence.length-countMy-1;				parent.window.setSequencesLocked(false);				parent.scrollToMatrixBase(centerMyAt);				parent.window.setSequencesLocked(true);			}			else {  //no, current center of reference sequence is not in aligned overlap, so go to center of aligned overlap				int countMy = 0;				int countOther = 0;				int centerOfOverlap = (firstOverlap + lastOverlap)/2;				for (int ic = 0; ic<=centerOfOverlap; ic++){					if (!DNAState.isInapplicable(results[ic][0]))						countMy++;					if (!DNAState.isInapplicable(results[ic][1]))						countOther++;				}				int centerMyAt = countMy;				int centerOtherAt = countOther;				if (mySeqCanvas.isShownReversed())					centerMyAt = mySequence.length-countMy-1;				if (refSeqCanvas.isShownReversed())					centerOtherAt = otherSequence.length-countOther-1;				parent.window.setSequencesLocked(false);				parent.scrollToMatrixBase(centerMyAt);				otherPanel.scrollToMatrixBase(centerOtherAt);				parent.window.setSequencesLocked(true);			}		}	}	void reverse(long[] seq){		for (int i = 0; i<seq.length/2; i++){			long temp = seq[i];			seq[i] = seq[seq.length-1-i];			seq[seq.length-1-i] = temp;		}	}	void complement(long[] seq){		for (int i = 0; i<seq.length; i++)			seq[i] = DNAState.complement(seq[i]);	}	double compareStates(char char1, char char2){		long state = DNAState.fromCharStatic(char1);		long state2 = DNAState.fromCharStatic(char2);		int cardInt = CategoricalState.cardinality(state & state2);		int cardUn = CategoricalState.cardinality(state | state2);		if (cardUn == 0)			return 0;		return (cardInt*1.0/cardUn);	}	int distance = 8;	int widthHalf = 20;	public synchronized Color getBaseMatchColor(int ic){		int diff = otherCenter-center;		double s = 0;		if (parent.isShownReversed()){			ic = mySequence.length() - ic-1;		}		String acO = "";		String ac = "";		//looking at a window widthHalf left and right of this site		for (int ik = ic-widthHalf; ik<= ic + widthHalf; ik++){ //surveying window			//seeing that point in window is in both sequences			if (ik>=0 && ik<mySequence.length() && ik+diff>=0 && ik+diff<otherSequence.length()){				char state = mySequence.charAt(ik);				char otherState = otherSequence.charAt(ik+diff);				if (ic == center){					ac += state;					acO += otherState;				}				s += compareStates(state, otherState);			}		}		s = s/(2.0*widthHalf +1);		double bestScore = s;  //set this as baseline best match		int bestOffset = 0;		for (int offset= -distance; offset<=distance; offset++){			int icOffset = ic + offset;			if (icOffset>=0 && icOffset<mySequence.length()){				double sD = 0;				//looking at a window widthHalf left and right of this site				for (int ik = icOffset-widthHalf; ik<= icOffset + widthHalf; ik++){ //surveying window					//seeing that point in window is in both sequences					if (ik>=0 && ik<mySequence.length() && ik+diff-offset>=0 && ik+diff-offset<otherSequence.length()){						char state = mySequence.charAt(ik);						char otherState = otherSequence.charAt(ik+diff- offset);						sD += compareStates(state, otherState);					}				}				sD = sD/(2.0*widthHalf +1);				if (sD > bestScore) {					bestScore = sD;					bestOffset = offset;				}			}		}		//bestScore = bestScore*0.7;//to soften colors		if (bestOffset>0){			bestOffset = bestOffset/2;			if (bestOffset == 0)				bestOffset =1;			return MesquiteColorTable.getGreenScale(bestScore/bestOffset, 0, 1, false);		}		else if (bestOffset<0){			bestOffset = - bestOffset;			bestOffset = bestOffset/2;			if (bestOffset == 0)				bestOffset = 1;			return MesquiteColorTable.getRedScale(bestScore/bestOffset, 0, 1, false);		}		else {			if (ic>=0 && ic<mySequence.length() && ic+diff>=0 && ic+diff<otherSequence.length()){				char state = mySequence.charAt(ic);				char otherState = otherSequence.charAt(ic+diff);				if (state == otherState){					double score = compareStates(state, otherState);					if (score > 0.9){						//if (CategoricalState.cardinality(DNAState.fromCharStatic(state))>1 || CategoricalState.cardinality(DNAState.fromCharStatic(otherState))>1){						//	Debugg.println("state " + CategoricalState.toString(DNAState.fromCharStatic(state)) + " otherState " + CategoricalState.toString(DNAState.fromCharStatic(otherState)) + " score " + score);						//}						return Color.yellow;					}				}			}			return MesquiteColorTable.getYellowScale(bestScore, 0, 2, false);		}	}	int center, otherCenter; //myLength, otherLength, 	public void paint(Graphics g){		//myLength = mySeq.getLength();		//otherLength = refSeq.getLength();		center = mySeqCanvas.getLocalIndexFromUniversalBase(parent.getCenterBase());		otherCenter = refSeqCanvas.getLocalIndexFromUniversalBase(otherPanel.getCenterBase());		mySequence = mySeq.getSequence();		otherSequence = refSeq.getSequence();		//	Debugg.println("mySequence " + center + "  " + otherCenter);		if (parent.isShownComplemented())			mySequence = DNAData.complementString(mySequence);		if (parent.isShownReversed()){			mySequence = DNAData.reverseString(mySequence);			center = mySequence.length()-center-1;		}		/**/		/**/		//	Debugg.println("mySequenceLATER " + center + "  " + otherCenter);		if (otherPanel.isShownComplemented())			otherSequence = DNAData.complementString(otherSequence);		if (otherPanel.isShownReversed()){			otherSequence = DNAData.reverseString(otherSequence);			otherCenter = otherSequence.length()-otherCenter-1;		}		mySequence = mySequence.toLowerCase();		otherSequence = otherSequence.toLowerCase();		//		COMPLEMENT IF NEEDED		//		REVERSE IF NEEDED AND then change center		g.translate(0, -14);		mySeqCanvas.paint(g, true, this);		g.translate(0, 14);		g.setColor(Color.black);		g.fillRect(0, getBounds().height-3, getBounds().width, 3);	}}class ContigControlPanel extends MesquitePanel  {	//close (all except for base)	//close individual reads	// reverse	// complement	// name	String name;	ContigPanel parent;	MesquiteButton reverseButton, complementButton, goAwayButton, alignButton;	MesquiteButton[] chromatButtons=null;	boolean showChromatButtons = false;	boolean isPrimary;	public ContigControlPanel(String name, ContigPanel parent){		this.name = name;		this.parent = parent;		this.isPrimary = parent.isPrimary;		if (showChromatButtons) {			chromatButtons = new MesquiteButton[parent.getNumChromats()];			for (int i=0; i< parent.getNumChromats(); i++){				chromatButtons[i] = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("toggleChromatVisible", parent), Integer.toString(i), true, parent.window.viewModule.getPath() + "triangleDownOn.gif", 12, 12);				chromatButtons[i].setOptionImagePath(parent.window.viewModule.getPath() + "triangleRightOn.gif");				add(chromatButtons[i]);				chromatButtons[i].setBounds(getBounds().width-20, parent.getChromatTop(i), 12, 12);				chromatButtons[i].setShowBackground(false);				chromatButtons[i].setVisible(true);				chromatButtons[i].setOptionDown(!parent.getChromatVisible(i));			}		}		int top = getBounds().height-36;		complementButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("showComplemented", parent), null, true, parent.window.viewModule.getPath() + "complementOff.gif", 16, 16);		complementButton.setOptionImagePath(parent.window.viewModule.getPath() + "complementOn.gif");		add(complementButton);		complementButton.setBounds(4, top, 16, 16);		top -= 20;		complementButton.setShowBackground(false);		complementButton.setVisible(true);		complementButton.setOptionDown(parent.showComplemented.getValue());		reverseButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("showReversed", parent), null, true, parent.window.viewModule.getPath() + "forward.gif", 16, 16);		reverseButton.setOptionImagePath(parent.window.viewModule.getPath() + "reverse.gif");		add(reverseButton);		reverseButton.setBounds(4, top, 16, 16);		top -= 20;		reverseButton.setShowBackground(false);		reverseButton.setVisible(true);		reverseButton.setOptionDown(parent.showReversed.getValue());		if (!isPrimary){			alignButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("align", parent), null, true, parent.window.viewModule.getPath() + "alignToRef.gif", 16, 16);			add(alignButton);			alignButton.setBounds(4, top, 16, 16);			alignButton.setShowBackground(false);			alignButton.setVisible(true);			top -= 20;						goAwayButton = new MesquiteButton (parent.window.viewModule, MesquiteModule.makeCommand("goAway", parent), null, true, MesquiteModule.getRootImageDirectoryPath() + "goAway.gif", 16, 16);			add(goAwayButton);			goAwayButton.setBounds(4, top, 16, 16);			goAwayButton.setShowBackground(false);			goAwayButton.setVisible(true);		}	}	void resetButtons(){		if (showChromatButtons) {			for (int i=0; i< parent.getNumChromats(); i++){				chromatButtons[i].setOptionDown(!parent.getChromatVisible(i));				chromatButtons[i].repaint();			}		}	}	void resize(){		if (showChromatButtons) {			for (int i=0; i< parent.getNumChromats(); i++){				chromatButtons[i].setOptionDown(!parent.getChromatVisible(i));				chromatButtons[i].setBounds(getBounds().width-16, parent.getChromatTop(i) +2, 12, 12);				chromatButtons[i].repaint();			}		}		int top = getBounds().height-36;		complementButton.setBounds(4, top, 16, 16);		top -= 20;		reverseButton.setBounds(4, top, 16, 16);		top -= 20;		if (!isPrimary){			alignButton.setBounds(4, top, 16, 16);			top -= 20;			goAwayButton.setBounds(2, top, 16, 16);		}	}	public void setSize(int w, int h){		super.setSize( w,  h);		resize();	}	public void setBounds(int x, int y, int w, int h){		super.setBounds(x, y, w,  h);		resize();	}	public void setBackground(Color c){		super.setBackground(c);		if (goAwayButton != null)			goAwayButton.setBackground(c);		if (alignButton != null)			alignButton.setBackground(c);		complementButton.setBackground(c);		reverseButton.setBackground(c);		if (showChromatButtons) {			for (int i=0; i< parent.getNumChromats(); i++){				chromatButtons[i].setBackground(c);			}		}	}	public void paint(Graphics g){		if (parent.isReversedInEditedData() || parent.isComplementedInEditedData())			setBackground(ColorDistribution.lightRed);		else			setBackground(ColorTheme.getContentBackground());		g.setColor(ColorTheme.getInterfaceEdgePositive());		g.drawRect(0,0,getBounds().width-1, getBounds().height);		//g.drawRect(1,1,getBounds().width-3, getBounds().height-3);	}}/* ======================================================================== */class ChromWindowPalette extends ToolPalette {	VChromWindow w;	MiniSlider magSlider, shadowSlider, shadowRedSlider;	int shadowWidth = 40;	public ChromWindowPalette(MesquiteModule ownerModule, VChromWindow containingWindow, MesquiteCommand sliderCommand, MesquiteCommand shadowOffsetCommand, MesquiteCommand shadowRedCommand) {  //in future pass general MesquiteWindow		super( ownerModule,  containingWindow, 1);		w = containingWindow;		magSlider = new MiniSlider (sliderCommand, false, 4, 0, 5, 0, 5);		add(magSlider);		magSlider.setVisible(true);		magSlider.setBounds(20, 100, 10, 200);		shadowSlider = new MiniSlider (shadowOffsetCommand, true, 2.5, 0, 5, 0, 5);		add(shadowSlider);		shadowSlider.setVisible(false);		shadowSlider.setBounds(20, 40, shadowWidth, 12);		shadowRedSlider = new MiniSlider (shadowRedCommand, false, 0.5, 0, 1, 0, 1);		add(shadowRedSlider);		shadowRedSlider.setVisible(false);		shadowRedSlider.setBounds(20, 60, shadowWidth, 12);	}	public void setShadowSlidersVisible(boolean vis){		shadowSlider.setVisible(vis);		shadowRedSlider.setVisible(vis);	}	public void setSize(int width, int height){		super.setSize(width, height);		magSlider.setSize(16, 80);		magSlider.setLocation(width/2-10, height-100);		shadowSlider.setSize(shadowWidth, 16);		shadowSlider.setLocation(width/2-shadowWidth/2, height-180);		shadowRedSlider.setSize(16, shadowWidth);		shadowRedSlider.setLocation(width/2-8, height-160);	}	public void setBounds(int x, int y, int width, int height){		super.setBounds(x, y, width, height);		magSlider.setSize(16, 80);		magSlider.setLocation(width/2-10, height-100);		shadowSlider.setSize(shadowWidth, 16);		shadowSlider.setLocation(width/2-shadowWidth/2, height-180);		shadowRedSlider.setSize(16, shadowWidth);		shadowRedSlider.setLocation(width/2-8, height-160);	}}/*class SequenceIterator {	MatrixSequence seq;	MolecularData data;	MesquiteInteger currentMatrixIC, currentSeqIC;	MesquiteBoolean firstHit = new MesquiteBoolean(false);	public SequenceIterator(MolecularData data, MatrixSequence seq){		this.data = data;		this.seq = seq;		currentMatrixIC = new MesquiteInteger(0);		currentSeqIC = new MesquiteInteger(0);	}	public void reset(){		firstHit.setValue(false);		currentMatrixIC.setValue(0);		currentSeqIC.setValue(0);	}	public long getSite(int ic, boolean verb){if (verb)	Debugg.println("target " + ic + "  currentSeqIC " + currentSeqIC + "  currentMatrixIC " + currentMatrixIC + "  firstHit " + firstHit);			if (ic >= currentSeqIC.getValue())			return seq.getSite(ic, currentMatrixIC, currentSeqIC, firstHit); 		reset();		return seq.getSite(ic, currentMatrixIC, currentSeqIC, firstHit); 	}} *//*class PrefBoolean extends MesquiteBoolean {	static boolean factoryDefaultValue = true;	static boolean defaultValue = true;	public PrefBoolean (boolean factoryDefault, boolean startValue) {		super(startValue);		defaultValue = startValue		factoryDefaultValue=factoryDefault;	}	public void setFactoryDefault(boolean b) {		factoryDefaultValue = b;	}	public void returnToFactoryDefault() {		setValue(factoryDefaultValue);	}	public void setValue(boolean b) {		super.setValue(b);		defaultValue=b;	}} *///^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^class ContigPanel extends MesquitePanel implements ContigDisplay, AdjustmentListener, ClosablePanelContainer {	static boolean listen = true; //static because all windows need to stop listening momentarily	int numTrimmedFromStart = -1;	int padBeforeTrim = -1;	int minimumChromatoHeight=0;	double horizScale = 1.0;	double peakDistance = 20.0;	int centerBase = 0;	MatrixSequence originalSequence;	MatrixSequence editedSequence;	Panel chromSetPanel;	BasicChromatogramPanel[] chromPanels;	Chromatogram[] chromatograms;	SequencePanel originalUntrimmedPanel;	SequencePanel matrixSeqPanel;	SequencePanel originalTrimmedPanel;	MultiReadCallsPanel multiReadCallsPanel;	ContigOverviewPanel overviewPanel;	Taxon taxon;	String sequenceID = null;	int seqPanelHeight = 36;	int scrollDepth = 16;	int bufferHeight = 4;	Panel bufferPanel;	int numSequencePanels = 3;	int spacer = 4;	boolean[] selectedUniversalBase=null;	Contig contig;	ContigMapper contigMapper;	ChromaseqUniversalMapper universalMapper;	boolean showAceContigPanel = false;	boolean showOriginalImportPanel = true;;	boolean chromatogramsOnTop = false;	boolean showOverviewPanel = false;	static int standardChromatoHeight = 120;	boolean showMultiReadCallsPanel = false;	boolean fixedChromatoHeight = true;	boolean reversedInMatrix = false;	boolean complementedInMatrix = false;	int vertScrollPosition = 0;	int maxVertScroll=0;	ContigControlPanel control;	ContigLinkerPanel linker;	Scrollbar horizScrollBar;	Scrollbar vertScrollBar;	MesquitePanel horizScrollPanel;	MesquitePanel vertScrollPanel;	VChromWindow window;	DNAData data;	DNAData originalData;	ContinuousData qualityData;	MesquiteTable table;	MesquiteBoolean showComplemented = new MesquiteBoolean(false);	MesquiteBoolean showReversed = new MesquiteBoolean(false);	boolean isPrimary = false;	boolean locked = false;	static int numIDs = 0;	int id;	int it=-1;	public ContigPanel (VChromWindow window, DNAData data, DNAData originalData, ContinuousData qualityData, MesquiteTable table, Taxon taxon, Chromatogram[] chroms, Contig contig, boolean isPrimary){		//^^^^single contig^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^		this.taxon = taxon;		id = ++numIDs;		this.contig = contig;		this.isPrimary = isPrimary;		chromatograms = chroms;		double totalPeakDistance = 0.0;		this.data = data;		this.originalData = originalData;		this.qualityData = qualityData;		this.window = window;		this.table = table;		addKeyListener(this);		requestFocusInWindow();		if (taxon!=null)			it = taxon.getNumber();		contigMapper = getContigMapper();		numTrimmedFromStart = contigMapper.getNumTrimmedFromStart();		showAceContigPanel = window.defaultChromBoolean[window.SHOWORIGINALUNTRIMMEDPANEL];		showMultiReadCallsPanel = window.defaultChromBoolean[window.SHOWMULTIREADCALLSPANEL];		showOverviewPanel = window.defaultChromBoolean[window.SHOWOVERVIEWPANEL];		showOriginalImportPanel = window.defaultChromBoolean[window.SHOWORIGINALTRIMMEDPANEL];		chromatogramsOnTop = window.defaultChromBoolean[window.CHROMATOGRAMSONTOP];		fixedChromatoHeight = window.defaultChromBoolean[window.FIXEDCHROMATOHEIGHT];		//		setNumBasesAddedToStart(ChromaseqUtil.getNumAddedToStart(data,taxon.getNumber(), true));		//		setNumBasesAddedToEnd(ChromaseqUtil.getNumAddedToEnd(data,taxon.getNumber(), true));		setBackground(ColorTheme.getContentBackground());		if (chroms != null){			chromSetPanel = new Panel();			add(chromSetPanel);			chromPanels = new BasicChromatogramPanel[chroms.length];			//chromVis = new boolean[chroms.length];			for (int i=0; i<chroms.length; i++){				//chromVis[i] = true;				chromPanels[i] = new BasicChromatogramPanel(this,chroms[i], this, i, id);				chromPanels[i].setVisible(true);				//	chromPanels[i].setBackground(Color.blue);				//addToWindow(chromPanels[i]);				chromSetPanel.add(chromPanels[i]);				totalPeakDistance+= chroms[i].getAveragePeakDistance();			}			peakDistance = totalPeakDistance/chroms.length;			}		originalUntrimmedPanel = new OriginalUntrimmedSeqPanel(this, contig, id);		originalUntrimmedPanel.setVisible(true);		originalUntrimmedPanel.setShowLowerQualSourceConflictsWithHigherQualRead(true);		add(originalUntrimmedPanel);		if (originalData != null){			originalSequence =new OrigSequenceImported(this,(MolecularData)data, (MolecularData)originalData, (ContinuousData)qualityData, contig, taxon.getNumber());			originalTrimmedPanel = new OriginalTrimmedSeqPanel(this, originalSequence, id);			originalTrimmedPanel.setVisible(true);			add(originalTrimmedPanel);		}		editedSequence =new EditedMatrixSequence(this,(MolecularData)data, (MolecularData)originalData, (ContinuousData)qualityData,  contig, taxon.getNumber());		matrixSeqPanel = new MatrixSequencePanel(this, editedSequence, id);		if (originalSequence == null)			originalSequence = editedSequence;		matrixSeqPanel.setVisible(true);		matrixSeqPanel.setBackground(Color.white);		add(matrixSeqPanel);		/*		 * 		if (data != null) {			data.addListener(editedSequence);			originalData.addListener(editedSequence);			qualityData.addListener(editedSequence);			data.addListener(originalSequence);			originalData.addListener(originalSequence);			qualityData.addListener(originalSequence);		}		 */		multiReadCallsPanel = new MultiReadCallsPanel(this,id,this, chroms);		multiReadCallsPanel.setVisible(true);		add(multiReadCallsPanel);		overviewPanel = new ContigOverviewPanel(this,id, this, chroms);		overviewPanel.setVisible(true);		add(overviewPanel);		bufferPanel = new Panel();		//bufferPanel.setBackground(Color.green);		bufferPanel.setVisible(true);		add(bufferPanel);		int numPeaksVisible = getApproximateNumberOfPeaksVisible();		centerBase = numPeaksVisible/2;		horizScrollPanel = new MesquitePanel();		horizScrollBar = new Scrollbar(Scrollbar.HORIZONTAL);		horizScrollBar.addAdjustmentListener(this);		int scrollTotal = getTotalNumUniversalBases() + numPeaksVisible;		horizScrollBar.setValues(centerBase,numPeaksVisible,0,getTotalNumUniversalBases() + numPeaksVisible); 		horizScrollBar.setUnitIncrement(1);		horizScrollBar.setBlockIncrement(1);		//		hbar.addKeyListener(this);		horizScrollPanel.add("South",horizScrollBar);		//hbar.setVisible(true);		horizScrollPanel.setVisible(true);		horizScrollPanel.setBackground(Color.white);		add(horizScrollPanel);		vertScrollPanel = new MesquitePanel();		vertScrollBar = new Scrollbar(Scrollbar.VERTICAL);		vertScrollBar.addAdjustmentListener(this);		vertScrollBar.setValues(0,0,0,0); 		vertScrollBar.setUnitIncrement(1);		vertScrollBar.setBlockIncrement(1);		vertScrollPanel.add("EAST",vertScrollBar);		vertScrollPanel.setVisible(true);		vertScrollPanel.setBackground(Color.white);		add(vertScrollPanel);		/*		Associable tInfo = data.getTaxaInfo(false);		numBasesOriginallyTrimmedFromStartOfPhPhContig = 0;		if (tInfo != null && taxon != null) {			int it = taxon.getNumber();			long t =	ChromaseqUtil.getLongAssociated(tInfo,ChromaseqUtil.startTrimRef, it);			if (MesquiteLong.isCombinable(t)) {				numBasesOriginallyTrimmedFromStartOfPhPhContig = (int)t;				padBeforeTrim = contig.resetPadding(numBasesOriginallyTrimmedFromStartOfPhPhContig, false);				numBasesOriginallyTrimmedFromStartOfPhPhContig -= padBeforeTrim;			}		}		 */		synchChromToTable(true);		horizScrollBar.addKeyListener(this);		if (universalMapper==null){			universalMapper = new ChromaseqUniversalMapper(this, data);			universalMapper.reset(false);		}		//	Debugg.println(chromaseqGraphicsMapper.toString());	}	public int getID(){		return id;	}	public ChromaseqUniversalMapper getUniversalMapper() {		return universalMapper;	}	public void setUniversalMapper(ChromaseqUniversalMapper universalMapper) {		this.universalMapper = universalMapper;	}	public void fullReregistration() {		ChromaseqUtil.inferRegistryData(data, it);		if (universalMapper!=null)			universalMapper.reset(false);	}	public void setUpPrimers(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].setUpPrimers();			if (!MesquiteThread.isScripting())				chromPanels[i].repaintPanel();		}	}	public void setReverseComplemented(boolean rc) {		boolean previousRev = isReversedInEditedData();		boolean previousComp = isComplementedInEditedData();		if (previousRev!=rc || previousComp!=rc) {			getEditedData().setReversed(getTaxon().getNumber(), rc);			getEditedData().setComplemented(getTaxon().getNumber(), rc);			repaintPanels();		}	}	public boolean isReversedInEditedData(){		return getEditedData().isReversed(getTaxon().getNumber());	}	public boolean isComplementedInEditedData(){		return getEditedData().isComplemented(getTaxon().getNumber());	}	public DNAData getEditedData() {		return data;	}	public BasicChromatogramPanel[] getChromPanels(){		return chromPanels;	}	public Chromatogram[] getChromatograms(){		return chromatograms;	}	public SequencePanel getAceContigPanel(){		return originalUntrimmedPanel;	}	public SequencePanel getMatrixSeqPanel(){		return matrixSeqPanel;	}	public SequencePanel getOrigSeqPanel(){		return originalTrimmedPanel;	}	public MultiReadCallsPanel getMultiReadCallsPanel(){		return multiReadCallsPanel;	}	public ContigOverviewPanel getContigOverviewPanel(){		return overviewPanel;	}	public boolean extraContigsShown() {		return window.extraContigsShown();	}	public String[][] getPrimerSequences(){		MesquiteModule m = window.viewModule;		if (m instanceof mesquite.chromaseq.ViewChromatograms.ViewChromatograms){			mesquite.chromaseq.ViewChromatograms.ViewChromatograms mod = (mesquite.chromaseq.ViewChromatograms.ViewChromatograms)m;			return mod.getPrimerSequences();		}		return null;	}	public boolean showPrimers(){		return window.showPrimers();	}	public boolean getShowSinglePrimerMatch(){		return window.getShowSinglePrimerMatch();	}	public String getSinglePrimer(){		return window.getSinglePrimer();	}	public void setSequencesLocked(boolean seqLocked) {		locked = seqLocked;	}	/*.................................................................................................................*/	public Snapshot getSnapshot(MesquiteFile file) {		Snapshot snapshot = new Snapshot();		snapshot.addLine("showReversed " + showReversed.toOffOnString());		snapshot.addLine("showComplemented " + showComplemented.toOffOnString());		snapshot.addLine("setRelativeLockPos " + relativeLockPos);		return snapshot;	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Shows sequence as reversed", "[]", commandName, "showReversed")) {			showReversed.toggleValue(new Parser().getFirstToken(arguments));			window.repaintAll();			control.reverseButton.setOptionDown(showReversed.getValue());		}		else if (checker.compare(this.getClass(), "Shows sequence as complemented", "[]", commandName, "showComplemented")) {			showComplemented.toggleValue(new Parser().getFirstToken(arguments));			window.repaintAll();			control.complementButton.setOptionDown(showComplemented.getValue());		}		else if (checker.compare(this.getClass(), "Toggles a chromatogram is visible ", "[number of chromatogram]", commandName, "toggleChromatVisible")) {			/*			int which = MesquiteInteger.fromString(arguments, new MesquiteInteger(0));			if (MesquiteInteger.isCombinable(which) && which < chromVis.length && which >=0)				setChromatVisible(which, !chromVis[which]);			//sizePanels();			control.resize();			control.repaint();			 */		}		else if (checker.compare(this.getClass(), "Sets the relative lock position ", "[difference]", commandName, "setRelativeLockPos")) {			int pos = MesquiteInteger.fromString(arguments, new MesquiteInteger(0));			if (MesquiteInteger.isCombinable(pos))				setRelativeLockPos(pos);		}		else if (checker.compare(this.getClass(), "Closes extra panel", "[]", commandName, "goAway")) {			window.removeContig(this);		}		else if (checker.compare(this.getClass(), "Aligns extra to reference", "[]", commandName, "align")) {			if (linker != null)				linker.alignToRef();		}		else			return  super.doCommand(commandName, arguments, checker);		return null;	}	/*.................................................................................................................*/	public void dispose(){		if (originalSequence!=null)			originalSequence.dispose();		if (editedSequence != null)			editedSequence.dispose();		super.dispose();	}	int relativeLockPos;	public int getRelativeLockPos(){		return relativeLockPos;	}	public void setRelativeLockPos(int p){		relativeLockPos = p;	}	public void setControl(ContigControlPanel c){		this.control = c;	}	public ContigControlPanel getControl(){		return control;	}	public void setLinker(ContigLinkerPanel c){		this.linker = c;	}	public ContigLinkerPanel getLinker(){		return linker;	}	public void setExplanation(String s){		window.setExplanation(s);	}	/*--------------------*/	public int getNumChromats(){		return chromPanels.length;	}	public int getChromatTop(int i){		if (i>=0 && i<chromPanels.length)			return chromPanels[i].getBounds().y;		return 0;	}	/*--------------------------------------*	public void setChromatVisible(int i, boolean v){		if (i>=0 && i<chromVis.length){			boolean ch = v != chromPanels[i].isOpen();			chromVis[i] = v;			control.resetButtons();			if (ch)				sizePanels();		}	}	/*--------------------------------------*/	public boolean getChromatVisible(int i){		if (i>=0 && i<chromPanels.length)			return chromPanels[i].isOpen();		return false;	}	public int getNumChromatVisible(){		int count = 0;		for (int i=0; i<chromPanels.length; i++)			if (chromPanels[i].isOpen())				count++;		return count;	}	//boolean[] chromVis;	final int closedHeight = 24;	/*--------------------------------------*/	public int getHorizontalScrollBarMaximum(){		if (horizScrollBar==null)			return 0;		return horizScrollBar.getMaximum();	}	/*--------------------------------------*/	public int getHorizontalScrollBarValue(){		if (horizScrollBar==null)			return 0;		return horizScrollBar.getValue();	}	/*--------------------------------------*/	/* Resize the chromatogram area and other components.*/	public void sizePanels(){		/* if chromatogramsOnTop then order is		 * 	overview		 * 	chromatograms		 * 	multiread		 * 	sequence		 * 		 * if not		 * 	overview		 * 	multiread		 * 	sequence		 * 	chromatograms		 * 			 * 			 */		//TODO: size panels		if (horizScrollPanel!=null)			horizScrollPanel.setVisible(false);		if (vertScrollPanel!=null)			vertScrollPanel.setVisible(false);		int border = 2;		int totalWidth = getWidth();		//		int totalHeight = getHeight();		int belowOverviewTop = 0;		if (overviewPanel!=null) {			if (showOverviewPanel) {				overviewPanel.setBounds(border,0,totalWidth-border*2 ,overviewPanel.getRequestedHeight(totalWidth));				belowOverviewTop += overviewPanel.getRequestedHeight(totalWidth);			}			overviewPanel.setVisible(showOverviewPanel);		}		if (chromPanels==null)			return;		int singleChromatoHeight = 0;		if (getNumChromatVisible()>0) {			if (fixedChromatoHeight)				singleChromatoHeight = standardChromatoHeight ;			else				singleChromatoHeight = MesquiteInteger.maximum(minimumChromatoHeight,(getChromAreaHeight()-(chromPanels.length-getNumChromatVisible())*closedHeight)/getNumChromatVisible()) ;		}		int topOfChromatograms = belowOverviewTop;		if (!chromatogramsOnTop)			topOfChromatograms = getNonChromAreaHeight();		int topOfThisChromatogram = 0;		int totalChromatogramHeight = 0;		for (int i=0; i<chromPanels.length; i++){			int thisHeight = 0;			chromPanels[i].setStandardHeight(singleChromatoHeight);			thisHeight = chromPanels[i].getStandardHeight(); 			chromPanels[i].setBounds(border,topOfThisChromatogram, totalWidth-border*2, thisHeight -spacer);			chromPanels[i].setTop(topOfThisChromatogram);			topOfThisChromatogram += thisHeight;			totalChromatogramHeight+=thisHeight;			// chromPanels[i].setVisible((i+2)*chromatoHeight<getChromAreaHeight()+spacer+1 || i==0);		}		//int bottom = singleChromatoHeight*chromPanels.length + getNonChromAreaHeight();		int topOfSequencePanels = singleChromatoHeight*chromPanels.length+belowOverviewTop;		if (!chromatogramsOnTop)			topOfSequencePanels = belowOverviewTop;		else			if (topOfSequencePanels>getChromAreaHeight()+belowOverviewTop)				topOfSequencePanels=getChromAreaHeight()+belowOverviewTop;		int top = topOfSequencePanels;		if (chromatogramsOnTop) {			bufferPanel.setBounds(border,top,totalWidth-border*2,bufferHeight);			top += bufferHeight;		} 		if (multiReadCallsPanel!=null) {			if (showMultiReadCallsPanel) {				multiReadCallsPanel.setBounds(border,top,totalWidth-border*2 ,getMultiReadCallsPanelHeight());				top += getMultiReadCallsPanelHeight();			}			multiReadCallsPanel.setVisible(showMultiReadCallsPanel);		}		if (originalUntrimmedPanel!=null) {			if (showAceContigPanel) {				originalUntrimmedPanel.setBounds(border,top,totalWidth-border*2 ,seqPanelHeight);				top += seqPanelHeight;			}			originalUntrimmedPanel.setVisible(showAceContigPanel);		}		if (originalTrimmedPanel!=null) { 			if (showOriginalImportPanel) {				originalTrimmedPanel.setBounds(border,top,totalWidth-border*2,seqPanelHeight);				top += seqPanelHeight;			} 			originalTrimmedPanel.setVisible(showOriginalImportPanel);		}		matrixSeqPanel.setBounds(border,top,totalWidth-border*2,seqPanelHeight);		top += seqPanelHeight;		if (horizScrollPanel!=null) {			horizScrollPanel.setBounds(border,getBounds().height-scrollDepth,totalWidth-border*2,scrollDepth);			horizScrollBar.setBounds(0,0,totalWidth-border*2,scrollDepth);			horizScrollPanel.setVisible(true);		}		int chromAreaHeight = getChromAreaHeight();		if (chromAreaHeight>getBounds().height - getNonChromAreaHeight() && chromatogramsOnTop)			chromAreaHeight = getBounds().height - getNonChromAreaHeight();		if (vertScrollPanel!=null) {			//vertScrollPanel.setBounds(getBounds().width-scrollDepth,topOfChromatograms,scrollDepth,getChromAreaHeight());			vertScrollPanel.setBounds(getBounds().width-scrollDepth,topOfChromatograms,scrollDepth,chromAreaHeight);			vertScrollBar.setBounds(0,0,scrollDepth,chromAreaHeight);			maxVertScroll = totalChromatogramHeight-chromAreaHeight;			if (maxVertScroll<0) 				maxVertScroll = 0;			int localMaxVertScroll = maxVertScroll;			int oldVertScrollPosition = vertScrollPosition;			vertScrollPosition = MesquiteInteger.minimum(vertScrollPosition, maxVertScroll);			vertScrollBar.setValues(vertScrollPosition, 0, 0,  maxVertScroll);			if (oldVertScrollPosition!=vertScrollPosition)				scrollVertically(vertScrollPosition);			vertScrollPanel.setVisible(true);			vertScrollBar.setUnitIncrement(10);			vertScrollBar.setBlockIncrement(getChromAreaHeight()/2);		}		chromSetPanel.setBounds(border,topOfChromatograms, totalWidth-border*2, chromAreaHeight);		//chromSetPanel.setBackground(Color.blue);		if (!chromatogramsOnTop) {			bufferPanel.setBounds(border,top,totalWidth-border*2,bufferHeight);			top += bufferHeight;		} 		if (horizScrollBar != null){			int numPeaksVisible = getApproximateNumberOfPeaksVisible();			int scrollTotal = getTotalNumUniversalBases() + numPeaksVisible;			horizScrollBar.setValues(centerBase,numPeaksVisible,0,getTotalNumUniversalBases() + numPeaksVisible);// - numPeaksVisible -1);			int blockIncrement = numPeaksVisible/2-1;			if (blockIncrement<1)				blockIncrement=1;			horizScrollBar.setBlockIncrement(blockIncrement);		}	}	/*--------------------------------------*/	/*Sets the size of the window (setSize and setBounds should not be used!!!>  <b>(overrides method of MesquiteWindow)</b>*/	public void setSize(int w, int h){		super.setSize(w,h);		sizePanels();		if (horizScrollBar != null){			int numPeaksVisible = getApproximateNumberOfPeaksVisible();			int scrollTotal = getTotalNumUniversalBases() + numPeaksVisible;			horizScrollBar.setValues(centerBase,numPeaksVisible,0,getTotalNumUniversalBases() + numPeaksVisible);// - numPeaksVisible -1);			horizScrollBar.setBlockIncrement(numPeaksVisible);		}		if (vertScrollBar!=null) {			vertScrollBar.setValues(vertScrollPosition, getChromAreaHeight(), 0,  maxVertScroll);			vertScrollBar.setBlockIncrement(getChromAreaHeight()/2);		}	}	/*.................................................................................................................*/	public boolean getColorByQuality() {		return window.chromBoolean[window.COLORIMPORTEDBYQUALITY].getValue();	}	public boolean getColorReadCallsByQuality(){		return window.chromBoolean[window.COLORREADCALLSBYQUALITY].getValue();	}	public boolean getColorMultiReadByQuality(){		return window.chromBoolean[window.COLORMULTIREADCALLSBYQUALITY].getValue();	}	public boolean getColorOverviewByQuality(){		return window.chromBoolean[window.COLOROVERVIEWBYQUALITY].getValue();	}	public boolean getColorEditedInMatrixByQuality(){		return window.chromBoolean[window.COLOREDITEDINMATRIXBYQUALITY].getValue();	}	/*.................................................................................................................*/	public Color getBaseColor(char c, Color backgroundColor) {		switch (c) {		case 'A':			return getBaseColor(DNAState.A, backgroundColor);		case 'C':			return getBaseColor(DNAState.C, backgroundColor);		case 'G':			return getBaseColor(DNAState.G, backgroundColor);		case 'T':			return getBaseColor(DNAState.T, backgroundColor);		case 'a':			return getBaseColor(DNAState.A, backgroundColor);		case 'c':			return getBaseColor(DNAState.C, backgroundColor);		case 'g':			return getBaseColor(DNAState.G, backgroundColor);		case 't':			return getBaseColor(DNAState.T, backgroundColor);		case '-':			return getBaseColor(DNAState.inapplicable, backgroundColor);		case '*':			return getBaseColor(DNAState.inapplicable, backgroundColor);		case 'N':			return getBaseColor(DNAState.unassigned, backgroundColor);		case '?':			return getBaseColor(DNAState.unassigned, backgroundColor);		default:			return Color.darkGray;		}	}	/*.................................................................................................................*/	public Color getBaseColor(long c, Color backgroundColor) {		Color color = Color.darkGray;		if (c == DNAState.unassigned)			color = Color.darkGray;		else if (c == DNAState.inapplicable)			color =  Color.gray;		c = c & DNAState.statesBitsMask;		if (c == DNAState.A){ //should make this more efficient by using constants!			if (window.getUseSequencherColors())				color =  window.AColorSequencher;			else				color = window.AColorStandard;		}		else if (c == DNAState.C) {			if (window.getUseSequencherColors())				color =  window.CColorSequencher;			else				color = window.CColorStandard;		}		else if (c == DNAState.G) {			if (window.getUseSequencherColors())				color =  window.GColorSequencher;			else				color = window.GColorStandard;		}		else if (c == DNAState.T) {			if (window.getUseSequencherColors())				color =  window.TColorSequencher;			else				color = window.TColorStandard;		}		else if (c == (DNAState.A | DNAState.C | DNAState.G | DNAState.T)  )			color =  Color.darkGray;		if (backgroundColor.equals(color) && color.equals(Color.black))			color= Color.white;		return color;	}	/*.................................................................................................................*/	public Color getBackgroundColor() {		return window.getBackgroundColor();	}	public int getCenterBase(){		return centerBase;	}	public boolean isShownReversed(){		return showReversed.getValue();	}	public boolean isShownComplemented(){		return showComplemented.getValue();	}	//for coordinating selection	int firstTouched = MesquiteInteger.unassigned;	int secondTouched = MesquiteInteger.unassigned;	public void setFirstTouchedOverall(int ic){		firstTouched = ic;	}	public int getFirstTouchedOverall(){		return firstTouched;	}	public int getFirstTouchedConsensus(){		if (!MesquiteInteger.isCombinable(firstTouched))			return firstTouched;		int c =  getContigBaseFromUniversalBase(firstTouched);		if (c <0)			return 0;		return c;	}	public void setSecondTouchedOverall(int ic){		secondTouched = ic;	}	public int getSecondTouchedOverall(){		return secondTouched;	}	public int getSecondTouchedConsensus(){		if (!MesquiteInteger.isCombinable(secondTouched))			return secondTouched;		int c =  getContigBaseFromUniversalBase(secondTouched);		if (c <0)			return 0;		return c;	}	void setShowA(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowA(show);	}	void setShowC(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowC(show);	}	void setShowG(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowG(show);	}	void setShowT(boolean show){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowT(show);	}	public void setScrollToTouched(boolean s){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setScrollToTouched(s);		if (originalUntrimmedPanel!=null)			originalUntrimmedPanel.setScrollToTouched(s);		if (matrixSeqPanel!=null)			matrixSeqPanel.setScrollToTouched(s);		if (originalTrimmedPanel!=null)			originalTrimmedPanel.setScrollToTouched(s);		if (multiReadCallsPanel!=null)			multiReadCallsPanel.setScrollToTouched(s);	}	public void setShowBaseSource(boolean s){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowBaseSource(s);	}	public void setShowCodonPosition(boolean s){		if (chromPanels!=null)			for (int i = 0; i<chromPanels.length; i++)				chromPanels[i].setShowCodonPosition(s);	}	/*...............................................................................................................*/	public String getContigDisplayExplanation (int universalBase){		StringBuffer sb = new StringBuffer();		int contigBase = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.ACEFILECONTIG, universalBase);	//	sb.append("Contig Base: " + contigBase + "  ");   		//sb.append("This is the consensus sequence as produced by Phred, Phrap, and Mesquite. ");		sb.append("Contig base quality: " + contig.getQualityOfBase(contigBase));		if (window.chromBoolean[window.SHOWREADREADCONFLICT].getValue())			sb.append("\nRed/pink bar: two reads conflict. ");		if (window.chromBoolean[window.SHOWLOWERQUALSOURCECONFLICTSWITHHIGHERQUALREAD].getValue())			sb.append("Box: source read is notably lower quality than other read. ");		return sb.toString();	}	/*.................................................................................................................*/	public void setShowReadName(boolean showReadName) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowReadName(showReadName);			}	}	/*.................................................................................................................*/	public void setShowBaseNumberWithinRead(boolean showBaseNumberWithinRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowBaseNumberWithinRead(showBaseNumberWithinRead);			}	}	/*.................................................................................................................*/	public void setShowReadMatrixConflict(boolean show) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowReadMatrixConflict(show);			}	}	/*.................................................................................................................*/	public void setShowReadReadConflict(boolean show) {		if (originalUntrimmedPanel!=null)			originalUntrimmedPanel.setShowReadReadConflict(show);	}	/*.................................................................................................................*/	public void setShowLowerQualSourceConflictsWithHigherQualRead(boolean show) {		if (originalUntrimmedPanel!=null)			originalUntrimmedPanel.setShowLowerQualSourceConflictsWithHigherQualRead(show);	}	/*.................................................................................................................*/	public void setDimConflictMarkerThreshold(int dimConflictMarkerThreshold) {		if (contig!=null)			contig.setDimConflictMarkerThreshold(dimConflictMarkerThreshold);		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setDimConflictMarkerThreshold(dimConflictMarkerThreshold);			}	}	/*.................................................................................................................*/	public void setDimLowQualityConflicts(boolean dimLowQualityConflicts) {		if (contig!=null)			contig.setDimLowQualityConflicts(dimLowQualityConflicts);		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setDimLowQualityConflicts(dimLowQualityConflicts);			}	}	/*.................................................................................................................*/	public void setShowFades(boolean showFades) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setShowFades(showFades);			}	}	/*.................................................................................................................*/	public void setFadeLowQuality(boolean fadeLowQuality) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeLowQuality(fadeLowQuality);			}	}	/*.................................................................................................................*/	public void setFadeNonSourceRead(boolean fadeNonSourceRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeNonSourceRead(fadeNonSourceRead);			}	}	/*.................................................................................................................*/	public void setFadeNonSourceLowerQualityRead(boolean fadeNonSourceLowerQualityRead) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeNonSourceLowerQualityRead(fadeNonSourceLowerQualityRead);			}	}	/*.................................................................................................................*/	public void setFadeQualityThreshold(int fadeQualityThreshold) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setFadeQualityThreshold(fadeQualityThreshold);			}	}	/*.................................................................................................................*/	public void setThickTrace(boolean thickTrace) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setThickTrace(thickTrace);			}	}	public void setUseSequencherColors(boolean useSequencherColors) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setUseSequencherColors(useSequencherColors);			}	}	/*.................................................................................................................*/	public void setColorImportedByQuality(boolean cbQ) {		if (originalUntrimmedPanel!=null)			originalUntrimmedPanel.setColorByQuality(cbQ);		if (originalTrimmedPanel!=null)			originalTrimmedPanel.setColorByQuality(cbQ);	}	/*.................................................................................................................*/	public void setColorEditedInMatrixByQuality(boolean colorMatrixbQ) {		if (matrixSeqPanel!=null)			matrixSeqPanel.setColorByQuality(colorMatrixbQ);	}	/*.................................................................................................................*/	public void setColorReadByQuality(boolean cReadbQ) {		if (chromPanels!=null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setColorByQuality(cReadbQ);			}	}	/*.................................................................................................................*/	public void setColorMultiReadByQuality(boolean cReadbQ) {		if (multiReadCallsPanel!=null)			multiReadCallsPanel.setColorByQuality(cReadbQ);	}	/*.................................................................................................................*/	public void setColorOverviewByQuality(boolean cReadbQ) {		if (overviewPanel!=null)			overviewPanel.setColorByQuality(cReadbQ);	}	/*.................................................................................................................*/	public double getHorizScale() {		return horizScale;	}	/*.................................................................................................................*/	public double getAveragePeakDistance() {		return (peakDistance * getHorizScale());	}	/*.................................................................................................................*/	public int getApproximateNumberOfPeaksVisible() {		if (getAveragePeakDistance()<=0)			return 0;		else			return (int)(getBounds().width/getAveragePeakDistance());	}	/*.................................................................................................................*/	/** Returns the number of pixels the window is scrolled */	public int getCenterPixelFromCenterBase(int centerBase){		return (int)((centerBase)*getAveragePeakDistance());	}	/*.................................................................................................................*/	public Contig getContig() {		return contig;	}	/*.................................................................................................................*/	public boolean contigExists() {		return originalUntrimmedPanel.getLength()>0;	}	/*.................................................................................................................*/	public int getHorizontalPixels(int pixels) {		return (int)(pixels * getHorizScale());	}	void setMagnification(double mag){		for (int i = 0; i<chromPanels.length; i++){			chromPanels[i].setMagnification(mag);		}	}	void setShadowOffset(int o){		for (int i = 0; i<chromPanels.length; i++){			chromPanels[i].setShadowOffset(o);		}	}	void setShadowReduction(double o){		for (int i = 0; i<chromPanels.length; i++){			chromPanels[i].setShadowReduction(o);		}	}	public int getMultiReadCallsPanelHeight() {		if (multiReadCallsPanel!=null)			return multiReadCallsPanel.getRequestedHeight(getWidth());		return 0;	}	/*--------------------------------------*	public int getOverviewPanelHeight() {		if (overviewPanel!=null)			return overviewPanel.getAllReadHeight()+25;		return 0;	}	/*--------------------------------------*/	public int getNonChromAreaHeight(){		int part =  seqPanelHeight  + bufferHeight;		if (showAceContigPanel)			part += seqPanelHeight;		if (originalTrimmedPanel!=null && showOriginalImportPanel) 			part += seqPanelHeight;		if (showMultiReadCallsPanel)			part += getMultiReadCallsPanelHeight();		if (showOverviewPanel && overviewPanel!=null)			part += overviewPanel.getRequestedHeight(getWidth());		return part;	}	/*--------------------------------------*/	public int getChromAreaHeight(){		int totalHeight = getHeight();		return totalHeight-getNonChromAreaHeight()-scrollDepth;	}	public SequencePanel getSequencePanel(int whichPanel){		if (whichPanel == 0)			return originalUntrimmedPanel;		else if (whichPanel == 1)			return originalTrimmedPanel;		else if (whichPanel == 2)			return matrixSeqPanel;		return null;	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at consensus base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtContigBase(int ic){		centerPanelsAtUniversalBase(getUniversalBaseFromContigBase(ic));	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at overall base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtUniversalBase(int ic){		centerPanelsAtUniversalBase(ic, true, false);	}	/*--------------------------------------*/	/** Moves the chromatogram panels over so that the center line is at overall base ic.  	 * Do NOT use this to scroll to that base, as this does not set the scroll bar	 * */	public void centerPanelsAtUniversalBase(int ic, boolean notifyWindow, boolean adjustScroll){		//		Debugg.printStackTrace("center");		if (adjustScroll)			horizScrollBar.setValue(ic);		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].centerPanelAtUniversalBase(ic);  		}		if (originalUntrimmedPanel!=null)			originalUntrimmedPanel.centerPanelAtOverallPosition(ic);		matrixSeqPanel.centerPanelAtOverallPosition(ic);		if (originalTrimmedPanel!=null)			originalTrimmedPanel.centerPanelAtOverallPosition(ic);		if (multiReadCallsPanel!=null)			multiReadCallsPanel.centerPanelAtOverallPosition(ic);		if (overviewPanel!=null)			overviewPanel.centerPanelAtOverallPosition(ic);		centerBase = ic;		if (notifyWindow)			window.scrollsChanged(this, ic);	}	public int getHomePositionInMatrix(){		return getMatrixPositionOfUniversalBase(getContigBaseFromUniversalBase(centerBase), originalData);	}	/*--------------------------------------*/	public void focusMatrixOn(int ic1, int ic2){  //ic1 is the first touched universal base (NOT consensus base); ic2 is the last touched base		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		if (!MesquiteInteger.isCombinable(ic1) && !MesquiteInteger.isCombinable(ic2))  // they are both unassigned, bail			return;		else if (MesquiteInteger.isCombinable(ic1) && ic1<0 && ic2<0)  // they are both <0, and so we don't want to move the matrix here			return;		else if (!MesquiteInteger.isCombinable(ic2) || (ic2<0) ||  ic2 == ic1){   // ic2 hasn't been assigned, or ic1 and ic2 are both positive and assigned			table.setFocusedCell(getMatrixPositionOfUniversalBase(ic1, originalData), it);		}		else {  //both are unassigned, and at least one is positive			table.setFocusedSequence(getMatrixPositionOfUniversalBase(ic1, originalData), getMatrixPositionOfUniversalBase(ic2, originalData), it);		}	}	/*--------------------------------------*/	/**This synchs the chromatogram viewer to the selections currently in the Matrix Editor */	public void synchChromToTable(boolean synchPosition){		if (!listen)			return;		if (!table.anyCellSelectedAnyWay())			return;		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		boolean changed = false;		int firstSel = -1;		int lastSel = -1;		boolean blockEnded = true;		if (universalMapper==null){			universalMapper = new ChromaseqUniversalMapper(this, data);			universalMapper.reset(false);		}		//boolean currentCenterBaseIsSelected = table.isCellSelectedAnyWay(getMatrixPositionOfConsensusPosition( getConsensusBaseFromOverallBase(centerBase), originalData), it);		for (int universalBase =0; universalBase<universalMapper.getNumUniversalBases(); universalBase++) { 			//	int consensusBase = getConsensusBaseFromOverallBase(universalBase);			//			int mPos = getMatrixPositionOfConsensusBase(consensusBase, originalData);			int matrixBase = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, universalBase);			boolean sel = table.isCellSelectedAnyWay(matrixBase, it);			if (sel) {				if (blockEnded){					firstSel = -1;					lastSel = -1;				}				if (firstSel == -1)					firstSel = universalBase;				lastSel = universalBase;				blockEnded = false;			} 			//else if (firstSel != -1){   //DRM 24 April 2008:  turned this off			//	blockEnded = true;			//}			changed = setSelectedUniversalBaseInChrom(universalBase, sel, false) || changed ;		}		if (changed && synchPosition && firstSel >= 0 && lastSel >= 0)			scrollToUniversalBase((firstSel + lastSel)/2);		if (changed)			repaintPanels();	}	/*--------------------------------------*/	/**This synchs the chromatogram viewer to the selections currently in the Matrix Editor */	public void matrixChanged(boolean synchPosition){		//synchChromToTable(synchPosition);   // DRM turned this off 24 April 2008, as it forces the selection in the matrix to take precedent over that in chromaseq		repaintPanels();	}		/*--------------------------------------*/	public boolean getSelectedAnyChromatogram(int overallBase){		for (int i=0; i<chromPanels.length; i++){			if (chromPanels[i].getSelected(overallBase))				return true;		}		return false;	}	/*--------------------------------------*/	public void synchTableToChrom(boolean synchPosition){		if (!listen)			return;		if (taxon == null || table == null)			return;		int it = taxon.getNumber();		boolean changed = false;		int firstSel = -1;		int lastSel = -1;		boolean blockEnded = true;		for (int universalBase =0; universalBase<universalMapper.getNumUniversalBases(); universalBase++) { 			boolean sel = getSelectedAnyChromatogram(universalBase);			//		int consensusBase = getConsensusBaseFromOverallBase(universalBase);			//	int mPos = getMatrixPositionOfConsensusBase(consensusBase, originalData); //Wayne: use this to then select table			if (sel) {				if (blockEnded){					firstSel = -1;					lastSel = -1;				}				if (firstSel == -1)					firstSel = universalBase;				lastSel = universalBase;				blockEnded = false;			} 			else if (firstSel != -1){				blockEnded = true;			}			changed = setSelectedUniversalBaseInChrom(universalBase, sel, false) || changed ;		}		if (changed && synchPosition && firstSel >= 0 && lastSel >= 0)			scrollToUniversalBase((firstSel + lastSel)/2);		if (changed)			repaintPanels();	}	/*--------------------------------------*/	//  NOT WORKING YET!!!	void untrimEnds(){		if (taxon == null)			return;		int it = taxon.getNumber();		Contig contig = getContig();				int firstMatrixBase = data.firstApplicable(it);		int firstUniversalBase = universalMapper.getUniversalBaseFromOtherBase(ChromaseqUniversalMapper.EDITEDMATRIX, firstMatrixBase);		int lastMatrixBase = data.lastApplicable(it);		int lastUniversalBase = universalMapper.getUniversalBaseFromOtherBase(ChromaseqUniversalMapper.EDITEDMATRIX, lastMatrixBase);		int matrixBase = lastMatrixBase;				for (int universalBase = lastUniversalBase+1; universalBase<getTotalNumUniversalBases(); universalBase++){			int contigBase = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.ACEFILECONTIG, universalBase);			long s = contig.getHighQualityPeakState(contigBase, 10.0);			if (DNAState.isCombinable(s)){				if (isComplementedInEditedData())					s = DNAState.complement(s);				matrixBase++;				data.setState(matrixBase, it, s);  			} else				break;		}/*		matrixBase = firstMatrixBase-1;  		for (int universalBase = firstMatrixBase-1; universalBase>=0; universalBase--){			int contigBase = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.ACEFILECONTIG, universalBase);			long s = contig.getHighQualityPeakState(contigBase, 50.0);			if (DNAState.isCombinable(s)){				if (isComplementedInEditedData())					s = DNAState.complement(s);				int matrixBase = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, universalBase);				data.setState(matrixBase, it, s);  			} else				break;		}*/		getContigMapper().recalc(it);				data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED));		data.notifyInLinked(new Notification(MesquiteListener.DATA_CHANGED));		matrixSeqPanel.repaintPanel();	}	/*--------------------------------------*/	void selectedToGaps(){		if (taxon == null)			return;		int it = taxon.getNumber();		for (int universalBase = 0; universalBase< universalMapper.getNumUniversalBases(); universalBase++){			if (getSelectedUniversalBaseInChrom(universalBase)){				int ic = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, universalBase);				ChromaseqUtil.setStateOfMatrixBase(this, data, ic, it, CategoricalState.inapplicable, true);			}		}		data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED));		data.notifyInLinked(new Notification(MesquiteListener.DATA_CHANGED));		matrixSeqPanel.repaintPanel();	}	/*--------------------------------------*/	void trimmableToGaps(){		if (taxon == null)			return;		int it = taxon.getNumber();		for (int universalBase = 0; universalBase< universalMapper.getNumUniversalBases(); universalBase++){			int ic = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, universalBase);			if (ic>=0 && ic<data.getNumChars() && ChromaseqUtil.isTrimmable(ic,it,data)){				ChromaseqUtil.setStateOfMatrixBase(this, data, ic, it, CategoricalState.inapplicable, true);			}		}		data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED));		matrixSeqPanel.repaintPanel();	}	/*--------------------------------------*/	void selectedToRevert(){		if (taxon == null)			return;		int it = taxon.getNumber();		for (int ic = 0; ic< getTotalNumUniversalBases(); ic++){			if (getSelectedUniversalBaseInChrom(ic)){				int icc = getMatrixPositionOfUniversalBase(ic, originalData);				((DNAData)data).setState(icc, it, ((DNAData)originalData).getStateRaw(icc, it));			}		}		data.notifyListeners(this, new Notification(CharacterData.DATA_CHANGED));		matrixSeqPanel.repaintPanel();	}	/*--------------------------------------*/	/** This returns the horizontal position, in pixels, of consensus site ic  */	public int getFullPixelValueOfContigBase(int ic){		int basesFromLeftSide = getUniversalBaseFromContigBase(ic);   // now adjust for the fact that the consensus sequence may not start at 0, 		// as there may be excess on the left		return (int)(basesFromLeftSide*getAveragePeakDistance());	}	/*--------------------------------------*/	/** This returns the horizontal position, in pixels, of consensus site ic  */	public int getFullPixelValueOfUniversalBase(int ic){		// as there may be excess on the left		return (int)(ic*getAveragePeakDistance());	}	/*--------------------------------------*/	public long getMatrixStateLongOfUniversalBase(int ic){		if (taxon == null)			return '-';		int icM = getMatrixPositionOfUniversalBase(ic);		int it = taxon.getNumber();			return data.getState(icM, it);	}	/*--------------------------------------*/	public char getMatrixStateAtContigBase(int ic){		if (taxon == null)			return '-';		int universalBase = universalMapper.getUniversalBaseFromOtherBase(ChromaseqUniversalMapper.ACEFILECONTIG, ic);		int icM = getMatrixPositionOfUniversalBase(universalBase);		int it = taxon.getNumber();			return DNAData.getIUPACChar(data.getState(icM, it));	}	/*--------------------------------------*/	public char getMatrixStateAtUniversalBase(int ic){		if (taxon == null || universalMapper == null)			return '-';		int icM = universalMapper.getEditedMatrixBaseFromUniversalBase(ic);		int it = taxon.getNumber();			if (isComplementedInEditedData())			return DNAData.getIUPACChar(DNAState.complement(data.getState(icM, it)));		else			return DNAData.getIUPACChar(data.getState(icM, it));	}	/*--------------------------------------*/	public boolean getSelectedUniversalBase(int universalBase){		if (selectedUniversalBase != null && universalBase>=0 && universalBase<selectedUniversalBase.length)			return selectedUniversalBase[universalBase];		return false;	}	/*--------------------------------------*/	public void deSelectAllUniversalBases(){		if (universalMapper==null)			return;		if (selectedUniversalBase==null || selectedUniversalBase.length!=universalMapper.getNumUniversalBases()){			selectedUniversalBase = new boolean [universalMapper.getNumUniversalBases()];		}		for (int universalBase=0; universalBase<selectedUniversalBase.length; universalBase++)			selectedUniversalBase[universalBase]= false;	}	/*--------------------------------------*/	public boolean setSelectedUniversalBaseInChrom(int universalBase, boolean sel, boolean repnt){		if (!listen)			return false;		boolean changed = false;		if (selectedUniversalBase==null || selectedUniversalBase.length!=universalMapper.getNumUniversalBases()){			selectedUniversalBase = new boolean [universalMapper.getNumUniversalBases()];			deSelectAllUniversalBases();		}		if (universalBase>=0 && universalBase<selectedUniversalBase.length)			selectedUniversalBase[universalBase]= sel;		for (int i=0; i<chromPanels.length; i++){			changed = chromPanels[i].selectUniversalPositionInChrom(universalBase, sel, repnt) || changed;		}		changed = originalUntrimmedPanel.setSelectedUniversalBase(universalBase, sel, repnt) || changed;		changed = matrixSeqPanel.setSelectedUniversalBase(universalBase, sel, repnt) || changed;		if (originalTrimmedPanel!=null)			changed = originalTrimmedPanel.setSelectedUniversalBase(universalBase, sel, repnt) || changed;		return changed;	}	/*--------------------------------------*/	//this is consensus position	public void selectUniversalBaseInTable(int i){		listen = false;		if (taxon != null && table != null){			int ic = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, i);			//	int ic = getMatrixPositionOfConsensusBase(i, originalData);			int it = taxon.getTaxa().whichTaxonNumber(taxon);			//			originalSequence.dumpFirstPositions();			table.selectCell(ic, it);			table.redrawCell(ic, it);		}		listen = true;	}	//this is consensus position	public void deselectUniversalBaseInTable(int i){		listen = false;		if (taxon != null && table != null){			int it = taxon.getTaxa().whichTaxonNumber(taxon);			int ic = universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.EDITEDMATRIX, i);			//	int ic = getMatrixPositionOfConsensusBase(i, originalData);			table.deselectCell(ic, it);			table.redrawCell(ic, it);		}		listen = true;	}	public void deselectAllInTable(){		listen = false;		if (taxon != null && table != null){			int it = taxon.getTaxa().whichTaxonNumber(taxon);			for (int ic = 0; ic<table.getNumColumns(); ic++){				table.deselectCell(ic, it);				table.redrawCell(ic, it);			}		}		listen = true;	}	public void deselectAllInPanels(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll();		}		originalUntrimmedPanel.deselectAll();		matrixSeqPanel.deselectAll();		if (originalTrimmedPanel!=null)			originalTrimmedPanel.deselectAll();		deSelectAllUniversalBases();	}	public void deselectAllReads(){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll();		}	}	public void deselectAllChrom(int overallBase){		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].deselectAll(overallBase);		}	}	/*--------------------------------------*	public void switchView(){		/*			 for (int i=0; i<chromPanels.length; i++){				chromPanels[i].setVisible(viewChromatograms.getValue());			}			aceContigPanel.setVisible(viewChromatograms.getValue());			matrixSeqPanel.setVisible(viewChromatograms.getValue());			if (origSeqPanel!=null)				origSeqPanel.setVisible(viewChromatograms.getValue());	 */	/*--------------------------------------*/	public void repaintPanels(){		if (chromPanels != null)			for (int i=0; i<chromPanels.length; i++){				chromPanels[i].repaintPanel();			}		if (originalUntrimmedPanel!=null)			originalUntrimmedPanel.repaintPanel();		if (matrixSeqPanel!=null)			matrixSeqPanel.repaintPanel();		if (originalTrimmedPanel!=null)			originalTrimmedPanel.repaintPanel();		if (multiReadCallsPanel!=null)			multiReadCallsPanel.repaintPanel();		if (overviewPanel!=null)			overviewPanel.repaintPanel();		if (chromSetPanel!=null)			chromSetPanel.repaint();		if (bufferPanel!=null)			bufferPanel.repaint();		if (control!=null)			control.repaint();	}	/*--------------------------------------*/	public boolean oneSelectedForEditing(){		if (matrixSeqPanel==null)			return false;		if (!matrixSeqPanel.isVisible())			return false;		return matrixSeqPanel.oneSelected();	}	/*--------------------------------------*/	public Taxon getTaxon(){		return taxon;	}	int keys = 0;	public void keyReleased(KeyEvent e){	}	public void keyTyped(KeyEvent e){	}	public void keyPressed(KeyEvent e){		int k = e.getKeyCode();		if (k==KeyEvent.VK_LEFT) {			checkToDeselect();			if (window.chromBoolean[window.JUMPTONEXTBASE].getValue())				scrollToConsensusBaseOffset(-1);  //David: deselect any selection			else 				goToNextProblem(false, false);		}		else if (k==KeyEvent.VK_RIGHT) {			checkToDeselect();			if (window.chromBoolean[window.JUMPTONEXTBASE].getValue())				scrollToConsensusBaseOffset(1);  //David: deselect any selection			else 				goToNextProblem(true, false);		}	}	/*.................................................................................................................*/ 	public void checkToDeselect(){		if (window.chromBoolean[window.TURNOFFEDITONMOVE].getValue() && oneSelectedForEditing())			deselectAllInPanels();	}	/*.................................................................................................................*/ 	private int nextLowQuality(boolean right, int threshold) {		if (!right)			for (int universalBase=centerBase-1;universalBase >=0;universalBase--) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					int contigBase = getContigBaseFromUniversalBase(universalBase);					int qual = contig.getQualityOfBase(contigBase);					if (qual<threshold)						return universalBase;				}			}		else			for (int universalBase=centerBase+1;universalBase < getTotalNumUniversalBases();universalBase++) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					int contigBase = getContigBaseFromUniversalBase(universalBase);					int qual = contig.getQualityOfBase(contigBase);					if (qual<threshold)						return universalBase;				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextAmbiguity(boolean right) {  // next ambiguity either in the matrix base or the original Original Untrimmed calls		if (!right)			for (int universalBase=centerBase-1;universalBase >=0;universalBase--) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					long s = getMatrixStateLongOfUniversalBase(universalBase);					if (CategoricalState.hasMultipleStates(s)) {						return universalBase;					}					int contigBase = getContigBaseFromUniversalBase(universalBase);					s = contig.getBase(contigBase);					if (CategoricalState.hasMultipleStates(s)) {						return universalBase;					}				}			}		else			for (int universalBase=centerBase+1;universalBase < getTotalNumUniversalBases() ;universalBase++) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					long s = getMatrixStateLongOfUniversalBase(universalBase);					if (CategoricalState.hasMultipleStates(s)) {						return universalBase;					}					int contigBase = getContigBaseFromUniversalBase(universalBase);					s = contig.getBase(contigBase);					if (CategoricalState.hasMultipleStates(s)) {						return universalBase;					}				}			}		return -1;	}	public boolean baseCalled(int i) {		int it = data.getTaxa().whichTaxonNumber(getTaxon());		int ic = getMatrixPositionOfUniversalBase(i, data);		if (it>=0)			if (ChromaseqUtil.baseCalled(getMatrixPositionOfUniversalBase(i, data), it , data))				return true;		return false;	}	private boolean checkForBaseCalled(int i) {		return (!window.getIgnoreProblemIfBaseCalled()|| !baseCalled(i));	}	/*.................................................................................................................*/ 	private int nextSourceReadIsLowerQualityAndConflicts(boolean right, int smallConflictThreshold, int largeConflictThreshold, boolean strongly) {		MesquiteBoolean higherReadConflicts = new MesquiteBoolean(false);		MesquiteBoolean muchHigherReadConflicts = new MesquiteBoolean(false);		if (!right)			for (int universalBase=centerBase-1;universalBase >=0;universalBase--) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					int contigBase = getContigBaseFromUniversalBase(universalBase);					if (contig.sourceReadIsLowerQuality(contigBase,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts)) {						if (strongly && muchHigherReadConflicts.getValue() || !strongly && higherReadConflicts.getValue())							return universalBase;					}				}			}		else			for (int universalBase=centerBase+1;universalBase < getTotalNumUniversalBases();universalBase++) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					int contigBase = getContigBaseFromUniversalBase(universalBase);					if (contig.sourceReadIsLowerQuality(contigBase,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts)) {						if (strongly && muchHigherReadConflicts.getValue() || !strongly && higherReadConflicts.getValue())							return universalBase;					}				}			}		return -1;	}	/*.................................................................................................................*	private int nextSourceReadIsLowerQuality(boolean right, int smallConflictThreshold, int largeConflictThreshold) {		MesquiteBoolean higherReadConflicts = new MesquiteBoolean(false);		MesquiteBoolean muchHigherReadConflicts = new MesquiteBoolean(false);		if (!right)			for (int universalBase=centerBase-1;universalBase >=0;universalBase--) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					if (contig.sourceReadIsLowerQuality(universalBase,smallConflictThreshold, higherReadConflicts, largeConflictThreshold, muchHigherReadConflicts))						return universalBase;				}			}		else			for (int i=centerBase+1;i < getTotalNumUniversalBases();i++) {				if (i>=0 && checkForBaseCalled(i)) {					if (contig.sourceReadIsLowerQuality(i,smallConflictThreshold, higherReadConflicts,largeConflictThreshold, muchHigherReadConflicts))						return i;				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextReadReadConflict(boolean right, int threshold) {		if (!right)			for (int universalBase=centerBase-1;universalBase >=0;universalBase--) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					int contigBase = getContigBaseFromUniversalBase(universalBase);					int conflict = contig.getConflictLevel(contigBase);					if (conflict>=threshold)						return universalBase;				}			}		else			for (int universalBase=centerBase+1;universalBase < getTotalNumUniversalBases();universalBase++) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					int contigBase = getContigBaseFromUniversalBase(universalBase);					int conflict = contig.getConflictLevel(contigBase);					if (conflict>=threshold)						return universalBase;				}			}		return -1;	}	/*.................................................................................................................*	private int nextDoublePeak(boolean right, int threshold) {   //threshold is quality threshold		int centerConsensusBase = getContigBaseFromUniversalBase(centerBase); 		MesquiteDouble fraction = new MesquiteDouble(0.0);		if (!right)			for (int i=centerConsensusBase-1;i >=0;i--) {				if (i>=0 && checkForBaseCalled(i)) {					int highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);					Debugg.println("q: " + highestQualityDoublePeak+ ", f: " + fraction.getValue());					if (highestQualityDoublePeak>=threshold) {						Debugg.println("   q chosen: " + highestQualityDoublePeak + ", fraction: " + fraction.getValue());						//						highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);						return i;					}				}			}		else			for (int i=centerConsensusBase+1;i < getTotalNumUniversalBases();i++) {				if (i>=0 && checkForBaseCalled(i)) {					int highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);					Debugg.println("q: " + highestQualityDoublePeak+ ", f: " + fraction.getValue());					if (highestQualityDoublePeak>=threshold) {						Debugg.println("   q chosen: " + highestQualityDoublePeak + ", fraction: " + fraction.getValue());						//						highestQualityDoublePeak= contig.getHighestQualityDoublePeak(i,0.5, fraction);						return i;					}				}			}		return -1;	}	/*.................................................................................................................*/ 	private int nextReadMatrixConflict(boolean right, int threshold) {		if (!right)			for (int universalBase=centerBase-1;universalBase >=0;universalBase--) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					for (int chrom = 0; chrom<chromPanels.length; chrom++){						Read read = chromPanels[chrom].getRead();						int contigBase = getContigBaseFromUniversalBase(universalBase);						int readBase = read.getReadBaseFromContigBase(contigBase);						char c = read.getPhdBaseChar(readBase);						char contigChar = getMatrixStateAtContigBase(contigBase);						if (isComplementedInEditedData())							contigChar = DNAData.complementChar(contigChar);						if (c!=contigChar) {							int quality = read.getPhdBaseQuality(readBase);							if (quality>=threshold)								return universalBase;						}					}				}			}		else			for (int universalBase=centerBase+1;universalBase < getTotalNumUniversalBases();universalBase++) {				if (universalBase>=0 && checkForBaseCalled(universalBase)) {					for (int chrom = 0; chrom<chromPanels.length; chrom++){						Read read = chromPanels[chrom].getRead();						int contigBase = getContigBaseFromUniversalBase(universalBase);						int readBase = read.getReadBaseFromContigBase(contigBase);						char c = read.getPhdBaseChar(readBase);						char contigChar = getMatrixStateAtContigBase(contigBase);						if (isComplementedInEditedData())							contigChar = DNAData.complementChar(contigChar);						if (c!=contigChar) {							int quality = read.getPhdBaseQuality(readBase);							if (quality>=threshold)								return universalBase;						}					}				}			}		return -1;	}	/*.................................................................................................................*/	private void goToNextProblem(boolean right, boolean major) {					int next = -1;		int next2 = -1;		if (window.chromBoolean[window.JUMPTONEXTAMBIGUITY].getValue()) {			next2 = nextAmbiguity(right);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.chromBoolean[window.JUMPTONEXTLOWQUALITY].getValue()) {			next2 = nextLowQuality(right, window.chromInt[window.JUMPQUALITYTHRESHOLD].getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.chromBoolean[window.JUMPTONEXTREADMATRIXCONFLICT].getValue()) {			next2 = nextReadMatrixConflict(right, window.chromInt[window.JUMPCONFLICTTHRESHOLD].getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.chromBoolean[window.JUMPTONEXTREADREADCONFLICT].getValue()) {			next2 = nextReadReadConflict(right, window.chromInt[window.JUMPCONFLICTTHRESHOLD].getValue());			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}		if (window.chromBoolean[window.JUMPTONEXTBADSOURCEREAD].getValue()) {			next2 = nextSourceReadIsLowerQualityAndConflicts(right, 1, 20, major);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}				/*		boolean jumpToNextDoublePeak = true;		if (jumpToNextDoublePeak) {			next2 = nextDoublePeak(right, 20);			if (next2>=0)				if (right && (next2<next || next<0)) next = next2;				else if (!right && (next2>next || next<0)) next = next2;		}				 */		/*		Debugg.println("||||||||||||||||||||||||||||");		for (int i=0;i < getTotalNumUniversalBases();i++) {				StringBuffer b = new StringBuffer();				b.append("  " + i + "          ");				for (int r=0; r<contig.getNumReadsToShow(); r++) {					Read read = contig.getRead(r);					int iBase = read.getReadBaseFromConsensusBase(i);					if (iBase>=0 && iBase<=read.getBasesLength()) {						double candidateFraction = read.getSecondaryPeakFraction(iBase);						int candidatePeakQuality =  read.getPhdBaseQuality(iBase);						b.append("     /     " + candidateFraction + "     " + candidatePeakQuality);					}				}				Debugg.println(b.toString());		}		 */		//Debugg.println("nextLow: " + nextLow);		if (next>=0 && next<getTotalNumUniversalBases()) {			scrollToUniversalBase(next);		}	}	/*.................................................................................................................*/	private void goToNextReadReadConflict(boolean right) {		int nextLow = nextReadReadConflict(right, window.chromInt[window.JUMPCONFLICTTHRESHOLD].getValue());		if (nextLow>=0 && nextLow<getTotalNumUniversalBases()) {			scrollToUniversalBase(nextLow);		}	}	/*.................................................................................................................*/	private void goToNextAmbiguity(boolean right) {		int next = nextAmbiguity(right);		//		Debugg.println("nextLow: " + nextLow);		if (next>=0 && next<getTotalNumUniversalBases()) {			scrollToUniversalBase(next);		}	}	/*.................................................................................................................*/	private void goToNextLowQuality(boolean right) {		int nextLow = nextLowQuality(right, window.chromInt[window.JUMPQUALITYTHRESHOLD].getValue());		//		Debugg.println("nextLow: " + nextLow);		if (nextLow>=0 && nextLow<getTotalNumUniversalBases()) {			scrollToUniversalBase(nextLow);		}	}	/*.................................................................................................................*/	private void goToNextReadMatrixConflict(boolean right) {		int nextLow = nextReadMatrixConflict(right, window.chromInt[window.JUMPCONFLICTTHRESHOLD].getValue());		if (nextLow>=0 && nextLow<getTotalNumUniversalBases()) {			scrollToUniversalBase(nextLow);		}	}	/*--------------------------------------*/	public  void scrollToUniversalBase(int universalBase){		if (!MesquiteInteger.isCombinable(universalBase))			universalBase = 0;		horizScrollBar.setValue(universalBase);		centerPanelsAtUniversalBase(universalBase);	}	/*--------------------------------------*/	public  void scrollToConsensusBase(int i){		scrollToUniversalBase(getUniversalBaseFromContigBase(i));	}	/*--------------------------------------*/	public  void scrollToMatrixBase(int i){		scrollToUniversalBase(getUniversalBaseFromMatrixBase(i));	}	/*--------------------------------------*/	public  void scrollToConsensusBaseOffset(int i){		int newBase = centerBase+i;		//		Debugg.printStackTrace("scrollToConsensus " + newBase);		if (newBase>=0 && newBase<getTotalNumUniversalBases()) {						horizScrollBar.setValue(newBase);			centerPanelsAtUniversalBase(newBase);		}	}	/*--------------------------------------*/	public void scrollVertically(int value) {		vertScrollBar.setValue(value);		vertScrollPosition = value;		for (int i=0; i<chromPanels.length; i++){			chromPanels[i].adjustTop(vertScrollPosition);		}	}	/*--------------------------------------*/	public  void adjustmentValueChanged(AdjustmentEvent evt){		if(evt.getAdjustable() == horizScrollBar) {			switch(evt.getAdjustmentType()) {			case AdjustmentEvent.UNIT_DECREMENT:			case AdjustmentEvent.UNIT_INCREMENT:			case AdjustmentEvent.BLOCK_INCREMENT:			case AdjustmentEvent.BLOCK_DECREMENT:			case AdjustmentEvent.TRACK:				centerPanelsAtUniversalBase(evt.getValue());				checkToDeselect();				break;			}		}		else	if(evt.getAdjustable() == vertScrollBar) {			switch(evt.getAdjustmentType()) {			case AdjustmentEvent.UNIT_DECREMENT:			case AdjustmentEvent.UNIT_INCREMENT:			case AdjustmentEvent.BLOCK_INCREMENT:			case AdjustmentEvent.BLOCK_DECREMENT:			case AdjustmentEvent.TRACK:				scrollVertically(evt.getValue());				break;			}		}	}	public boolean isShowAceContigPanel() {		return showAceContigPanel;	}	public void setShowAceContigPanel(boolean showAceContigPanel) {		this.showAceContigPanel = showAceContigPanel;	}	public boolean isShowOriginalImportPanel() {		return showOriginalImportPanel;	}	public void setShowOriginalImportPanel(boolean showOriginalImportPanel) {		this.showOriginalImportPanel = showOriginalImportPanel;	}	public boolean isChromatogramsOnTop() {		return chromatogramsOnTop;	}	public void setChromatogramsOnTop(boolean chromatogramsOnTop) {		this.chromatogramsOnTop = chromatogramsOnTop;	}	public boolean isFixedChromatoHeight() {		return fixedChromatoHeight;	}	public void setFixedChromatoHeight(boolean fixedChromatoHeight) {		this.fixedChromatoHeight = fixedChromatoHeight;	}	public boolean isShowMultiReadCallsPanel() {		return showMultiReadCallsPanel;	}	public void setShowMultiReadCallsPanel(boolean showMultiReadCallsPanel) {		this.showMultiReadCallsPanel = showMultiReadCallsPanel;	}	public void setShowOverviewPanel(boolean showOverviewPanel) {		this.showOverviewPanel = showOverviewPanel;	}	public ClosablePanel getPrecedingPanel(ClosablePanel panel) {		/*	if (panel==null) return null;		if (panel.equals(overviewPanel))			return null;		else if (chromatogramsOnTop){			if (panel.equals(multiReadCallsPanel)){				if (chromPanels.length>0)					return chromPanels[chromPanels.length-1];			}			else {				for (int i=0; i<chromPanels.length; i++) {					if (panel.equals(chromPanels[i])) {						if (i==0) {							if (showOverviewPanel)								return overviewPanel;							else								return null;						} else							return chromPanels[i-1];					}				}			}		}		else {			if (panel.equals(multiReadCallsPanel)){				if (showOverviewPanel)					return overviewPanel;			}			else {				for (int i=0; i<chromPanels.length; i++) {					if (panel.equals(chromPanels[i])) {						if (i==0) {							if (showMultiReadCallsPanel)								return multiReadCallsPanel;							else if (showOverviewPanel)								return overviewPanel;							else								return null;						} else							return chromPanels[i-1];					}				}			}		}		 */		return null;	}	public void requestHeightChange(ClosablePanel panel){		sizePanels();		repaint();	}	/* |||||||||||||||||   BASE COORDINATION SECTION |||||||||||||||||||||| */	/* this section helps with the coordination and registration between bases and peeks, in the matrices, the chromatagrams and phred/phrap output, and the display	 */	/*.................................................................................................................*/	public void setBaseInContigDeleted(int matrixBase, boolean b){		int contigBase = universalMapper.getOtherBaseFromEditedMatrixBase(ChromaseqUniversalMapper.ACEFILECONTIG, matrixBase);		getContigMapper();		if (contigBase>=0 && contigMapper!=null){			contigMapper.setDeletedBase(contigBase, b);		}	}	/*.................................................................................................................*/	public boolean baseInContig(int matrixBase){		int contigBase = universalMapper.getOtherBaseFromEditedMatrixBase(ChromaseqUniversalMapper.ACEFILECONTIG, matrixBase);		if (contigBase>=0){			return true;		}		return false;	}	/*.................................................................................................................*/	public boolean baseInContigDeleted(int matrixBase){		int contigBase = universalMapper.getOtherBaseFromEditedMatrixBase(ChromaseqUniversalMapper.ACEFILECONTIG, matrixBase);		getContigMapper();		if (contigBase>=0 && contigMapper!=null)			return contigMapper.getDeletedBase(contigBase);		return false;	}	/*.................................................................................................................*/	public ContigMapper getContigMapper() {		contigMapper = ContigMapper.getContigMapper(data, getContig(), it);		return contigMapper;	}	/*.................................................................................................................*/	/** Adds to the numBasesAddedToStart in the Contig.   */	public void addToNumBasesAddedToStart(int i){		getContig().addToNumBasesAddedToStart(i);	}	/*.................................................................................................................*/	public void setNumBasesAddedToStart(int numBasesAddedToStart) {		getContig().setNumBasesAddedToStart(numBasesAddedToStart);	}	/*.................................................................................................................*	public int getNumBasesAddedToStart() {		return getContig().getNumBasesAddedToStart();	}	/*.................................................................................................................*/	/** Adds to the numBasesAddedToEnd in the Contig.   */	public void addToNumBasesAddedToEnd(int i){		getContig().addToNumBasesAddedToEnd(i);	}	/*.................................................................................................................*/	public void setNumBasesAddedToEnd(int numBasesAddedToEnd) {		getContig().setNumBasesAddedToEnd(numBasesAddedToEnd);	}	/*.................................................................................................................*/	/** Returns the base number within the consensus sequence at the base baseNumber (which is numbered from the beginning, including excess bases at the start).   */	public int getContigBaseFromUniversalBase(int universalBase){		if (!MesquiteInteger.isCombinable(universalBase))			return universalBase;		if (!contigExists())			return universalBase;		return universalMapper.getOtherBaseFromUniversalBase(ChromaseqUniversalMapper.ACEFILECONTIG, universalBase);	}	/*.................................................................................................................*/	public int getUniversalBaseFromContigBase(int baseNumber){		if (!MesquiteInteger.isCombinable(baseNumber))			return baseNumber;		if (!contigExists())			return baseNumber;		return universalMapper.getUniversalBaseFromOtherBase(ChromaseqUniversalMapper.ACEFILECONTIG, baseNumber);	}	/*.................................................................................................................*/	public int getUniversalBaseFromMatrixBase(int baseNumber){		if (!MesquiteInteger.isCombinable(baseNumber))			return baseNumber;		return universalMapper.getUniversalBaseFromOtherBase(ChromaseqUniversalMapper.EDITEDMATRIX, baseNumber);	}	/*.................................................................................................................*/	public int getTotalNumUniversalBases() {		if (universalMapper!=null)			return universalMapper.getNumUniversalBases();		return contig.getNumBases() + contig.getReadExcessAtStart()+ contig.getReadExcessAtEnd();	}	/*.................................................................................................................*/	public int getTotalNumInitialOverallBases() {		return contig.getNumBases() + contig.getReadExcessAtStart()+ contig.getReadExcessAtEnd();	}	/*.................................................................................................................*/	public  int numPadsInTrimmedRegionAtStart(int it) {		return padBeforeTrim;	}	/*--------------------------------------*/	/** This should return for overall site ic what codon position the site is. */	public int  getCodonPositionOfOverallBase(int overallBase){		if (data==null)			return 0;		//	int consensusBase = getContigBaseFromUniversalBase(overallBase);		int matrixCharacter = getMatrixPositionOfUniversalBase(overallBase, data);		if (matrixCharacter>=0 && matrixCharacter<data.getNumChars())			return data.getCodonPosition(matrixCharacter);		else			return 0;	}	/*.................................................................................*/	public int getUniversalBaseOfMatrixBase(int matrixBase){		return universalMapper.getUniversalBaseFromOtherBase(ChromaseqUniversalMapper.EDITEDMATRIX, matrixBase);	}	/*.................................................................................*/	public int getMatrixPositionOfUniversalBase(int universalBase){		return getMatrixPositionOfUniversalBase(universalBase, originalData);	}	/*.................................................................................*/	/** This should return for consensus site ic what character in matrix it corresponds to.  	 * This is needed in case the sequence has been aligned,	 * and thus is not left justified and contiguous.  It also accounts for the trimming that is done in going from 	 * the consensus (i.e., main contig) sequence to the sequence in the matrix. */	public int getMatrixPositionOfUniversalBase(int universalBase, DNAData data){		if (taxon == null || universalMapper==null)			return -1;		int it = taxon.getNumber();		return universalMapper.getEditedMatrixBaseFromUniversalBase(universalBase);	}	/*.................................................................................*/	public int getNumTrimmedFromStart(){		return numTrimmedFromStart;	}	/*.................................................................................*/	public int getNumTrimmedFromEnd(){		if (contigMapper==null)			return 0;		return contigMapper.getNumTrimmedFromEnd();	}	/*--------------------------------------*/	/*This uses indices as in consensus*/	public boolean getSelectedUniversalBaseInChrom(int ic){		return matrixSeqPanel.getSelectedConsensus(ic);	}	/*.................................................................................*/	public boolean getSelectedOverallBase(int overallBase) {		return chromPanels[0].getSelected(overallBase);	}	/* |||||||||||||||||   END BASE COORDINATION SECTION |||||||||||||||||||||| */	/* to be used by subclasses to tell that panel touched */	public void mouseDown (int modifiers, int clickCount, long when, int x, int y, MesquiteTool tool) {		deselectAllInTable();		deselectAllInPanels();		//	universalMapper.reset(false);		repaintPanels();	}}