/* Mesquite Chromaseq source code.  Copyright 2005-2011 David Maddison and Wayne Maddison.Version 1.0   December 2011Disclaimer:  The Mesquite source code is lengthy and we are few.  There are no doubt inefficiencies and goofs in this code. The commenting leaves much to be desired. Please approach this source code with the spirit of helping out.Perhaps with your help we can be more than a few, and make Mesquite better.Mesquite is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.Mesquite's web site is http://mesquiteproject.orgThis source code and its compiled class files are free and modifiable under the terms of GNU Lesser General Public License.  (http://www.gnu.org/copyleft/lesser.html) */package mesquite.chromaseq.PhredPhrap; import java.io.*;import java.util.*;import java.awt.*;import java.awt.event.*;import javax.swing.JLabel;import org.dom4j.*;import mesquite.lib.*;import mesquite.lib.duties.*;import mesquite.tol.lib.MesquiteXMLToLUtilities;import mesquite.categ.lib.*;import mesquite.cont.lib.*;import mesquite.externalCommunication.AppHarvester.AppHarvester;import mesquite.externalCommunication.lib.*;import mesquite.meristic.lib.*;import mesquite.molec.lib.DNADatabaseURLSource;import mesquite.chromaseq.ChromaseqAuthorDefaults.ChromaseqAuthorDefaults;import mesquite.chromaseq.lib.*;/* ======================================================================== */public class PhredPhrap extends ChromatogramProcessor implements ActionListener, AppUser, OutputFileProcessor, ShellScriptWatcher  { 	protected DNADatabaseURLSource databaseURLSource = null;	private boolean uploadResultsToDatabase = false;		private ChromaseqAuthorDefaults authorDefaults;	ChromatogramFileNameParser nameParserManager;	StringBuffer logBuffer;		boolean scriptBased = true;   // Note: turning this off will require Java 7 because of Process.isAlive()	ShellScriptRunner scriptRunner;	ExternalProcessManager externalRunner;	boolean hasApp = false;	AppInformationFile appInfoFile;	boolean useDefaultExecutablePath = true;	boolean singleScript = MesquiteTrunk.isWindows();	ProgressIndicator progIndicator = null;	boolean importing = true;	String[][] fileNameTranslation;	String[] outputFilePaths;	//for importing sequences	//MesquiteProject project = null;	FileCoordinator coord = null;	MesquiteFile file = null;	Taxa taxa  = null;	DNAData data = null;	DNAData originalData = null;	ContinuousData  qualityData = null;//	CategoricalData addedBaseData = null;	MeristicData  registrationData = null;	MesquiteInteger maxChar = new MesquiteInteger(0);	static String previousDirectory = null;	int preDNANumberLength = 10;	final String processedFolder = "processed";	final String originalFolder = "originals";//	final String fastaFolder = "fasta";	final String processedACEFolder = "processedACE";	final String sequencesFolder = "sequences";	String fastaDirectory = null;	String processedFastaDirectory = null;	String processedACEDirectory = null;	final static String  VERSION_FILE = "fileToDetermineVersion";	final static String PHRED_PHRAP_SCRIPT_FILE_NAME = "ppscript.bat";	boolean preferencesSet = false;	String phredParamPath; 	String phredPath;	String phrapOptions = "-qual_show 20 -vector_bound 0 ";	String phredOptions = "";	String fileExtension = "";	boolean requiresExtension=true;	final static boolean runPhredPhrap = true;	boolean processPolymorphisms = true;	boolean verbose = true;	boolean singleTaxaBlock = false;	boolean addPhrapFailures = true;	boolean showBirdsEye = true;	double polyThreshold = 0.3;	ExtensibleDialog dialog = null;	SingleLineTextField cygwinPathField =  null;	SingleLineTextField phredPathField =  null;	SingleLineTextField paramPathField = null;	int qualThresholdForTrim = 20;	int qualThresholdForLowerCase = 49;	boolean truncateMixedEnds = true;	int mixedEndWindow = 10;	int mixedEndThreshold = 5;	boolean renameContigsInAceFiles = true;	boolean addFragName = false;//	boolean unTrimAceReads = true;	boolean backupOriginals = true;		SequenceNameSource sequenceNameTask = null;	PrimerInfoSource primerInfoTask = null;	public void getEmployeeNeeds(){  //This gets called on startup to harvest information; override this and inside, call registerEmployeeNeed		EmployeeNeed e1 = registerEmployeeNeed(SequenceNameSource.class, "Phred/Phrap processing requires a source of sequence names; choose the one that appropriately determines the sequence names from the sample codes.", "This is activated automatically.");		EmployeeNeed e2 = registerEmployeeNeed(PrimerInfoSource.class, "Phred/Phrap processing requires a source of information about primers, including their names, direction, and sequence, as well as the gene fragments to which they correspond.", "This is activated automatically.");		EmployeeNeed e3 = registerEmployeeNeed(ChromatogramFileNameParser.class, "Phred/Phrap processing requires a means to determine the sample code and primer name.", "This is activated automatically.");	}	/*.................................................................................................................*/	public boolean startJob(String arguments, Object condition, boolean hiredByName){		/* don't know if your structure permits this but:  if was set previously, could use prefs to have these modules start up and hire according 		 * to prefs before dialog shows up. Then in composing dialog use getParameters() of all these employees to report on current settings, 		 * and put report in a little text area at top of dialog to indicate current settings, and a button that says "change".  Would require 		 * that getParameters of these modules return text with this in mind, and that modules that hire other modules would have to put 		 * the latter's text embedded in own getParameters text returned. */		loadPreferences();		if (authorDefaults == null) {			authorDefaults = (ChromaseqAuthorDefaults)MesquiteTrunk.mesquiteTrunk.findEmployeeWithName("#ChromaseqAuthorDefaults");		}		if (nameParserManager == null)			nameParserManager= (ChromatogramFileNameParser)MesquiteTrunk.mesquiteTrunk.hireEmployee(ChromatogramFileNameParser.class, "Supplier of sample code and primer name from the chromatogram file name.");		if (nameParserManager == null || authorDefaults == null) {			return false;		} else {			if (!nameParserManager.optionsSpecified())				if (!nameParserManager.queryOptions())					return false;		}				if (sequenceNameTask==null) 			sequenceNameTask = (SequenceNameSource)hireEmployee(SequenceNameSource.class,  "Supplier of sequence names from sample codes");		if (sequenceNameTask==null) 			return false;		 else {				if (!sequenceNameTask.optionsSpecified())					if (!sequenceNameTask.queryOptions())						return false;			}		//		primerInfoTask = (PrimerInfoSource)hireCompatibleEmployee(PrimerInfoSource.class,  new MesquiteString("alwaysAsk"), "Supplier of information about primers and gene fragments");		if (primerInfoTask==null) 			primerInfoTask = (PrimerInfoSource)hireEmployee(PrimerInfoSource.class,  "Supplier of information about primers and gene fragments");		if (primerInfoTask==null) 			return false;		 else {				if (!primerInfoTask.optionsSpecified())					if (!primerInfoTask.queryOptions())						return false;			}				logBuffer = new StringBuffer(200);		return true;	}	/*.................................................................................................................*/	public boolean processChromatograms(MesquiteProject project, boolean appendIfPossible) {		return processChromatograms(project, appendIfPossible,  null);	}	public boolean userAborted(){		return false;	}	public boolean getHasApp() {		return hasApp;	}	public void setHasApp(boolean hasApp) {		this.hasApp = hasApp;	}	public String getAppOfficialName() {		return "phredPhrap";	}	public String getProgramName(){		return "Phred&Phrap";	}	public boolean getDefaultExecutablePathAllowed() {		return true;	}	/*.................................................................................................................*/	public String getDefaultExecutablePath(){		if (appInfoFile==null) {			appInfoFile = getAppInfoFile();		}		if (appInfoFile!=null) {			String fullPath = appInfoFile.getFullPath();			return fullPath;		}		return null;	}	/*.................................................................................................................*/	public String getVersionFromAppInfo(){		if (!useDefaultExecutablePath || !getDefaultExecutablePathAllowed()) 			return null;		if (appInfoFile==null) {			appInfoFile = getAppInfoFile();		}		if (appInfoFile!=null) {			return appInfoFile.getVersion();		}		return null;	}	/*.................................................................................................................*/	public String getAppInfoForLog(){		if (appInfoFile==null) {			appInfoFile = getAppInfoFile();		}		if (appInfoFile!=null) {			StringBuffer sb = new StringBuffer(0);			sb.append("\nVersion " + appInfoFile.getVersion());			return sb.toString();		}		return null;	}	/*.................................................................................................................*/	public String getExecutablePath(){		if (useDefaultExecutablePath && getDefaultExecutablePathAllowed()) 			return getDefaultExecutablePath();		else			return phredPath;	}	public boolean useAppInAppFolder() {		return useDefaultExecutablePath && getDefaultExecutablePathAllowed();	}	/*.................................................................................................................*/	public AppInformationFile getAppInfoFile() {		return AppHarvester.getAppInfoFileForProgram(this);	}	/*.................................................................................................................*/	public boolean processChromatograms(MesquiteProject project, boolean appendIfPossible,  String outputDirectory) {		importing = project !=null;		if (queryOptions()) {			// if they want to upload the results to the database, they need to ensure that			// they have selected their username			if (uploadResultsToDatabase) {				boolean results = authorDefaults.verifyAuthorIsntDefault();				if (!results) {					return false;				}			}			if (project != null)	project.incrementProjectWindowSuppression();			boolean success = prepareAndRunPhredPhrap(project, appendIfPossible,  outputDirectory);			postBean();			if (project !=null) getProject().decrementProjectWindowSuppression();			return success;		}		return false;	}		/*.................................................................................................................*/	public void processSingleXMLPreference (String tag, String content) {		if ("requiresExtension".equalsIgnoreCase(tag))			requiresExtension = MesquiteBoolean.fromTrueFalseString(content);		else if ("phredParamPath".equalsIgnoreCase(tag))			phredParamPath = StringUtil.cleanXMLEscapeCharacters(content);		else if ("useDefaultExecutablePath".equalsIgnoreCase(tag))			useDefaultExecutablePath = MesquiteBoolean.fromTrueFalseString(content);		else if ("phredPath".equalsIgnoreCase(tag))			phredPath = StringUtil.cleanXMLEscapeCharacters(content);		else if ("previousDirectory".equalsIgnoreCase(tag))			previousDirectory = StringUtil.cleanXMLEscapeCharacters(content);		else if ("phrapOptions".equalsIgnoreCase(tag))			phrapOptions = StringUtil.cleanXMLEscapeCharacters(content);		else if ("fileExtension".equalsIgnoreCase(tag))			fileExtension = StringUtil.cleanXMLEscapeCharacters(content);		else if ("phredOptions".equalsIgnoreCase(tag))			phredOptions = StringUtil.cleanXMLEscapeCharacters(content);		else if ("processPolymorphisms".equalsIgnoreCase(tag))			processPolymorphisms = MesquiteBoolean.fromTrueFalseString(content);		else if ("showBirdsEye".equalsIgnoreCase(tag))			showBirdsEye = MesquiteBoolean.fromTrueFalseString(content);		else if ("singleTaxaBlock".equalsIgnoreCase(tag))			singleTaxaBlock = MesquiteBoolean.fromTrueFalseString(content);		else if ("truncateMixedEnds".equalsIgnoreCase(tag))			truncateMixedEnds = MesquiteBoolean.fromTrueFalseString(content);		else if ("renameContigsInAceFiles".equalsIgnoreCase(tag))			renameContigsInAceFiles = MesquiteBoolean.fromTrueFalseString(content);		else if ("addFragName".equalsIgnoreCase(tag))			addFragName = MesquiteBoolean.fromTrueFalseString(content);		else if ("backupOriginals".equalsIgnoreCase(tag))			backupOriginals = MesquiteBoolean.fromTrueFalseString(content);		else if ("polyThreshold".equalsIgnoreCase(tag))			polyThreshold = MesquiteDouble.fromString(content);		else if ("qualThresholdForTrim".equalsIgnoreCase(tag))			qualThresholdForTrim = MesquiteInteger.fromString(content);		else if ("qualThresholdForLowerCase".equalsIgnoreCase(tag))			qualThresholdForLowerCase = MesquiteInteger.fromString(content);		else if ("mixedEndWindow".equalsIgnoreCase(tag))			mixedEndWindow = MesquiteInteger.fromString(content);		else if ("mixedEndThreshold".equalsIgnoreCase(tag))			mixedEndThreshold = MesquiteInteger.fromString(content);		else if ("uploadResultsToDatabase".equalsIgnoreCase(tag)) {			uploadResultsToDatabase = MesquiteBoolean.fromTrueFalseString(content);		}		else if ("setPrimerInfoSource".equalsIgnoreCase(tag)) {			replacePrimerInfoSource(content);		}		else if ("setSequenceNameSource".equalsIgnoreCase(tag)) {			replaceSequenceNameSource(content);		}		preferencesSet = true;	}	/*.................................................................................................................*/	public String preparePreferencesForXML () {		StringBuffer buffer = new StringBuffer(200);		StringUtil.appendXMLTag(buffer, 2, "requiresExtension", requiresExtension);  		StringUtil.appendXMLTag(buffer, 2, "phredParamPath", phredParamPath);  		StringUtil.appendXMLTag(buffer, 2, "useDefaultExecutablePath",  useDefaultExecutablePath);  		StringUtil.appendXMLTag(buffer, 2, "phredPath", phredPath);  		StringUtil.appendXMLTag(buffer, 2, "processPolymorphisms", processPolymorphisms);  		StringUtil.appendXMLTag(buffer, 2, "polyThreshold", polyThreshold);  		StringUtil.appendXMLTag(buffer, 2, "previousDirectory", previousDirectory);  		StringUtil.appendXMLTag(buffer, 2, "singleTaxaBlock", singleTaxaBlock);  		StringUtil.appendXMLTag(buffer, 2, "qualThresholdForTrim", qualThresholdForTrim);  		StringUtil.appendXMLTag(buffer, 2, "qualThresholdForLowerCase", qualThresholdForLowerCase);  		StringUtil.appendXMLTag(buffer, 2, "mixedEndWindow", mixedEndWindow);  		StringUtil.appendXMLTag(buffer, 2, "mixedEndThreshold", mixedEndThreshold);  		StringUtil.appendXMLTag(buffer, 2, "truncateMixedEnds", truncateMixedEnds);  		StringUtil.appendXMLTag(buffer, 2, "renameContigsInAceFiles", renameContigsInAceFiles);  		StringUtil.appendXMLTag(buffer, 2, "addFragName", addFragName);  		StringUtil.appendXMLTag(buffer, 2, "backupOriginals", backupOriginals);  		StringUtil.appendXMLTag(buffer, 2, "phrapOptions", phrapOptions);  		StringUtil.appendXMLTag(buffer, 2, "fileExtension", fileExtension);  		StringUtil.appendXMLTag(buffer, 2, "phredOptions", phredOptions);  		StringUtil.appendXMLTag(buffer, 2, "showBirdsEye", showBirdsEye);  		StringUtil.appendXMLTag(buffer, 2, "uploadResultsToDatabase", uploadResultsToDatabase);				if (primerInfoTask!=null)			StringUtil.appendXMLTag(buffer, 2, "setPrimerInfoSource",primerInfoTask);		if (sequenceNameTask!=null)			StringUtil.appendXMLTag(buffer, 2, "setSequenceNameSource",sequenceNameTask);		preferencesSet = true;		return buffer.toString();	}	/*.................................................................................................................*/	/** returns whether this module is requesting to appear as a primary choice */	public boolean requestPrimaryChoice(){		return true;  	}	/*.................................................................................................................*/	public boolean isPrerelease(){		return false;	}	/*.................................................................................................................*/	public boolean isSubstantive(){		return true;	}	Checkbox defaultExecutablePathCheckBox =  null;	/*.................................................................................................................*/	public boolean queryFileLocations() {		MesquiteInteger buttonPressed = new MesquiteInteger(1);		ExtensibleDialog queryFilesDialog = new ExtensibleDialog(MesquiteTrunk.mesquiteTrunk.containerOfModule(), "Phred Phrap Locations & Options",buttonPressed);  //MesquiteTrunk.mesquiteTrunk.containerOfModule()		queryFilesDialog.addLabel("Phred & Phrap - File Locations & Options");		if (getDefaultExecutablePathAllowed()) {			defaultExecutablePathCheckBox = queryFilesDialog.addCheckBox("Use built-in app path for Phred, Phrap, & Phd2Fasta", useDefaultExecutablePath);		}		phredPathField = queryFilesDialog.addTextField("Path to alternative versions of Phred, Phrap, & Phd2Fasta:", phredPath, 40);		Button phredBrowseButton = queryFilesDialog.addAListenedButton("Browse...",null, this);		phredBrowseButton.setActionCommand("phBrowse");		paramPathField = queryFilesDialog.addTextField("Phred parameter file:", phredParamPath, 40);		Button paramBrowseButton = queryFilesDialog.addAListenedButton("Browse...",null, this);		paramBrowseButton.setActionCommand("paramBrowse");		SingleLineTextField phredOptionsField = queryFilesDialog.addTextField("Phred command-line arguments:", phredOptions, 26, true);		SingleLineTextField phrapOptionsField = queryFilesDialog.addTextField("Phrap command-line arguments:", phrapOptions, 26, true);		queryFilesDialog.completeAndShowDialog(true);		if (buttonPressed.getValue()==0)  {			phredParamPath = paramPathField.getText();			if (defaultExecutablePathCheckBox!=null)				useDefaultExecutablePath = defaultExecutablePathCheckBox.getState();			phredPath = phredPathField.getText();			phredPath = StringUtil.stripTrailingWhitespace(phredPath);			if (!phredPath.endsWith(MesquiteFile.fileSeparator))				phredPath+=MesquiteFile.fileSeparator;			phrapOptions = phrapOptionsField.getText();			phredOptions = phredOptionsField.getText();		}		queryFilesDialog.dispose();		return (buttonPressed.getValue()==0);	}	/*.................................................................................................................*/	public boolean queryPostOptions() {		MesquiteInteger buttonPressed = new MesquiteInteger(1);		ExtensibleDialog queryPostDialog = new ExtensibleDialog(MesquiteTrunk.mesquiteTrunk.containerOfModule(), "Post-Phrap Sequence Processing Options",buttonPressed);  //MesquiteTrunk.mesquiteTrunk.containerOfModule()		queryPostDialog.addLabel("Post-Phrap Processing by Chromaseq");		IntegerField lowerCaseQualityField = queryPostDialog.addIntegerField("Quality threshold for lower case:", qualThresholdForLowerCase, 3);		Checkbox polyBox = queryPostDialog.addCheckBox("Convert multiple-peaks sites to ambiguity codes",processPolymorphisms);		DoubleField polyThresholdField = queryPostDialog.addDoubleField("Minimum secondary peak fraction for ambiguity:", polyThreshold, 6);		Checkbox truncateEndsBox = queryPostDialog.addCheckBox("Trim low quality regions from ends (FASTA & import)",truncateMixedEnds);		IntegerField trimQualityField = queryPostDialog.addIntegerField("Quality threshold for trim:", qualThresholdForTrim, 3);		IntegerField trimWindowField = queryPostDialog.addIntegerField("Trim window length:", mixedEndWindow, 3);		IntegerField trimThresholdField = queryPostDialog.addIntegerField("Trim window threshold:", mixedEndThreshold, 3);//		Checkbox unTrimAceReadsField = queryPostDialog.addCheckBox("reset quality regions in reads in .ace files",unTrimAceReads);		Checkbox renameContigsField = queryPostDialog.addCheckBox("rename contigs in .ace files",renameContigsInAceFiles);		Checkbox addFragNameField = queryPostDialog.addCheckBox("add fragment name to contig name",addFragName);		queryPostDialog.addHorizontalLine(2);//		Checkbox openAceField = queryPostDialog.addCheckBox("open directory with .ace file links",openAceDirectory);//		Checkbox importSequencesField = queryPostDialog.addCheckBox("import sequences into Mesquite",importSequencesIntoMesquite);		String s = "After Phrap finishes assembling contigs, Mesquite will process the files produced.  It will change upper case nucleotides to lower case if the quality score falls below the specified quality threshold.\n\n";		s+= "Mesquite will also trim low quality ends of sequences, if you so choose.  This trimming is done by removing regions of leading or trailing nucleotides with quality values less than the specified quality threshold. ";		s+= "If the ends have a mixture of lower and higher quality nucleotides, then Mesquite will trim until if finds a window of nucleotides of specified length which have fewer than the \"Trim window threshold\" ";		s+= "of nucleotides below the quality score.  To put it another way, it will trim leading and trailing windows of nucleotides which have as many or more poor-quality nucleotides than specified; ";		s+= "it trims high-quality nucleotides only if they are external to low-quality nucleotides that are to be trimmed by this criterion.";		queryPostDialog.appendToHelpString(s);		queryPostDialog.completeAndShowDialog(true);		if (buttonPressed.getValue()==0)  {			qualThresholdForLowerCase = lowerCaseQualityField.getValue();			truncateMixedEnds = truncateEndsBox.getState();			qualThresholdForTrim = trimQualityField.getValue();			processPolymorphisms = polyBox.getState();			polyThreshold = polyThresholdField.getValue();			mixedEndWindow = trimWindowField.getValue();			mixedEndThreshold = trimThresholdField.getValue();			renameContigsInAceFiles = renameContigsField.getState();//			unTrimAceReads = unTrimAceReadsField.getState();			addFragName = addFragNameField.getState();//			openAceDirectory = openAceField.getState();//			importSequencesIntoMesquite = importSequencesField.getState();		}		queryPostDialog.dispose();		return (buttonPressed.getValue()==0);	}	JLabel nameParserLabel = null;	JLabel sequenceNameTaskLabel = null;	JLabel primerInfoTaskLabel = null;		MesquiteTextCanvas nameParserTextCanvas = null;	MesquiteTextCanvas sequenceNameTaskTextCanvas = null;	MesquiteTextCanvas primerInfoTaskTextCanvas = null;	Button sequenceNameTaskButton = null;	Button nameParserButton = null;	Button primerInfoTaskButton = null;	/*.................................................................................................................*/	private String getModuleText(MesquiteModule mod) {		return mod.getName() + "\n" + mod.getParameters();	}					/*.................................................................................................................*/	public boolean queryOptions() {		MesquiteInteger buttonPressed = new MesquiteInteger(ExtensibleDialog.defaultCANCEL);		ExtensibleDialog dialog = new ExtensibleDialog(containerOfModule(), "Phred/Phrap/Chromaseq Options",buttonPressed);  //MesquiteTrunk.mesquiteTrunk.containerOfModule()		dialog.addLabel("Phred/Phrap/Chromaseq Options");		dialog.setHelpURL(this, "manual/preparation.html#processing");				TextCanvasWithButtons textCanvasWithButtons;//section for name parser				dialog.addHorizontalLine(1);		dialog.addLabel("Chromatogram File Name Parser");		dialog.forceNewPanel();		String s = getModuleText(nameParserManager);		if (MesquiteTrunk.mesquiteTrunk.numModulesAvailable(ChromatogramFileNameParser.class)>1){			textCanvasWithButtons = dialog.addATextCanvasWithButtons(s,"File Name Parser...", "nameParserReplace", "Options...", "nameParserButton",this);			nameParserButton = textCanvasWithButtons.getButton2();		}		else {			textCanvasWithButtons = dialog.addATextCanvasWithButtons(s, "Options...", "nameParserButton",this);			nameParserButton = textCanvasWithButtons.getButton();		}		nameParserButton.setEnabled (nameParserManager.hasOptions());		nameParserTextCanvas = textCanvasWithButtons.getTextCanvas();		//section for SequenceNameSource		dialog.addHorizontalLine(1);		dialog.addLabel("Source of Sequence Names");		dialog.forceNewPanel();		s = getModuleText(sequenceNameTask);		if (MesquiteTrunk.mesquiteTrunk.numModulesAvailable(SequenceNameSource.class)>1){			textCanvasWithButtons = dialog.addATextCanvasWithButtons(s,"Sequence Name Source...", "sequenceNameTaskReplace", "Options...", "sequenceNameTaskButton",this);			sequenceNameTaskButton = textCanvasWithButtons.getButton2();		}		else {			textCanvasWithButtons = dialog.addATextCanvasWithButtons(s, "Options...", "sequenceNameTaskButton",this);			sequenceNameTaskButton = textCanvasWithButtons.getButton();		}		sequenceNameTaskButton.setEnabled (sequenceNameTask.hasOptions());		sequenceNameTaskTextCanvas = textCanvasWithButtons.getTextCanvas();//section for PrimerInfoSource		dialog.addHorizontalLine(1);		dialog.addLabel("Source of Primer Information");		dialog.forceNewPanel();		s = getModuleText(primerInfoTask);		if (MesquiteTrunk.mesquiteTrunk.numModulesAvailable(PrimerInfoSource.class)>1){			textCanvasWithButtons = dialog.addATextCanvasWithButtons(s,"Primer Info Source...", "primerInfoTaskReplace", "Options...", "primerInfoTaskButton",this);			primerInfoTaskButton = textCanvasWithButtons.getButton2();		}		else {			textCanvasWithButtons = dialog.addATextCanvasWithButtons(s, "Options...", "primerInfoTaskButton",this);			primerInfoTaskButton = textCanvasWithButtons.getButton();		}		nameParserButton.setEnabled (primerInfoTask.hasOptions());		primerInfoTaskTextCanvas = textCanvasWithButtons.getTextCanvas();		dialog.addHorizontalLine(2);				dialog.setDefaultButton("Process");		Checkbox requiresExtensionBox = dialog.addCheckBox("process only files with standard extensions (ab1,abi,ab,CRO,scf)", requiresExtension);		SingleLineTextField fileExtensionField = dialog.addTextField("uniform file extension for organized chromatograms (if desired):", fileExtension, 8, true);		Checkbox backupOriginalsBox = dialog.addCheckBox("save backups of original chromatograms", backupOriginals);		Panel buttonPanel = dialog.addNewDialogPanel();		Button fileLocationsButton = dialog.addAButton("Phred Phrap Locations & Options...",buttonPanel);		fileLocationsButton.addActionListener(this);		fileLocationsButton.setActionCommand("phLocations");		dialog.addHorizontalLine(2);		Panel buttonPanel2 = dialog.addNewDialogPanel();		Button postProcessingButton = dialog.addAButton("Post-Phrap Sequence Processing Options...",buttonPanel2);		postProcessingButton.addActionListener(this);		postProcessingButton.setActionCommand("postOptions");		Checkbox singleTaxaBlockBox=null;		if (importing) {			singleTaxaBlockBox = dialog.addCheckBox("import as single taxon block",singleTaxaBlock);		}		Checkbox uploadResultsBox = null;		if (MesquiteTrunk.mesquiteTrunk.numModulesAvailable(DNADatabaseURLSource.class)>=1)			uploadResultsBox = dialog.addCheckBox("upload results to database", uploadResultsToDatabase); 		Checkbox showBirdsEyeBox=null;		if (importing) {			showBirdsEyeBox = dialog.addCheckBox("display matrix in bird's eye view",showBirdsEye);		}		dialog.addHorizontalLine(2);		dialog.completeAndShowDialog(true);		boolean success=(buttonPressed.getValue()== dialog.defaultOK);		if (success)  {			fileExtension = fileExtensionField.getText();			requiresExtension = requiresExtensionBox.getState();			backupOriginals = backupOriginalsBox.getState();			if (uploadResultsBox!=null)				uploadResultsToDatabase = uploadResultsBox.getState();			if (importing) {				singleTaxaBlock = singleTaxaBlockBox.getState();				showBirdsEye = showBirdsEyeBox.getState();			}		}		storePreferences();  // do this here even if Cancel pressed as the File Locations subdialog box might have been used		nameParserTextCanvas = null;		 sequenceNameTaskTextCanvas = null;		 primerInfoTaskTextCanvas = null;		dialog.dispose();		return success;	}	/*.................................................................................................................*/	boolean makeDirectoriesForFragment(String fragmentDirPath){		File newDir = new File(fragmentDirPath);		try { newDir.mkdir();    //make folder for this gene					processedFastaDirectory = fragmentDirPath  + MesquiteFile.fileSeparator + ChromaseqUtil.processedFastaFolder;		newDir = new File(processedFastaDirectory);		newDir.mkdir();	//make processed fastaFolder		String sequencesDirectory = fragmentDirPath  + MesquiteFile.fileSeparator + sequencesFolder;		newDir = new File(sequencesDirectory);		newDir.mkdir();	//make sequences folder for holding all of the sequences and files produces by phred and phrap		}		catch (SecurityException e) { 			logln("Couldn't make directory.");			return false;		}		return true;	}	/*.................................................................................................................*/	String getPhredCommand(){		if (MesquiteTrunk.isWindows())			return StringUtil.protectFilePathForWindows(getExecutablePath() + "phred.exe");		else			return StringUtil.protectFilePathForUnix(getExecutablePath() + "phred");	}	/*.................................................................................................................*/	String getPhrapCommand(){		if (MesquiteTrunk.isWindows())			return StringUtil.protectFilePathForWindows(getExecutablePath() + "phrap.exe");		else			return StringUtil.protectFilePathForUnix(getExecutablePath() + "phrap");	}	/*.................................................................................................................*/	String getPhd2FastaCommand(){		if (MesquiteTrunk.isWindows())			return StringUtil.protectFilePathForWindows(getExecutablePath() + "phd2fasta.exe");		else			return StringUtil.protectFilePathForUnix(getExecutablePath() + "phd2fasta");	}	int sequenceCount = 0;	String importedDirectoryPath, importedDirectoryName;	public boolean prepareAndRunPhredPhrap(MesquiteProject project, boolean appendIfPossible){		return prepareAndRunPhredPhrap(project, appendIfPossible,  null);	}	/*.................................................................................................................*/	public boolean queryForPaths(MesquiteBoolean pleaseStorePrefs) {		if (!useDefaultExecutablePath && (!preferencesSet || StringUtil.blank(phredPath))) {			phredPath = MesquiteFile.chooseDirectory("Choose directory containing phred, phrap, and phd2fasta: ");			if (StringUtil.blank(phredPath))				return false;			if (!phredPath.endsWith(MesquiteFile.fileSeparator))				phredPath+=MesquiteFile.fileSeparator;			if (pleaseStorePrefs!=null)				pleaseStorePrefs.setValue(true);		}		if (!preferencesSet || StringUtil.blank(phredParamPath)) {			MesquiteString paramDir = new MesquiteString();			MesquiteString paramFile = new MesquiteString();			phredParamPath = MesquiteFile.openFileDialog("Choose phred parameter file: ", paramDir, paramFile);			if (StringUtil.blank(phredParamPath))				return false;			if (pleaseStorePrefs!=null)				pleaseStorePrefs.setValue(true);		}		return true;	}	/*.................................................................................................................*/	public void prepareShellScriptForDirectory(StringBuffer shellScript, StringBuffer postShellScript, String statusFilePath, String phphLogFilePath, String fragmentDirPath, String seqFileName, String fullSeqName, String fragmentName, String directoryPath){		shellScript.append(ShellScriptUtil.getChangeDirectoryCommand(MesquiteTrunk.isWindows(), directoryPath));		String commandTermination = "";		String redirectString = " 1> stdOut.txt 2>stErr.txt ";		if (MesquiteTrunk.isMacOSX())			commandTermination = " && sleep 0.2 ";		if (singleScript) {			shellScript.append(getPhredCommand() + " -V -log"+StringUtil.lineEnding());			shellScript.append(getPhrapCommand() + " > "+VERSION_FILE+StringUtil.lineEnding());		}		if (runPhredPhrap)			shellScript.append(ShellScriptUtil.getAppendStringAsFile(phphLogFilePath, "" + sequenceCount + ". " + fullSeqName + " (directory changed)"));		shellScript.append(getPhredCommand() + " -V -log -id . -pd . -d " + StringUtil.blankIfNull(phredOptions) + redirectString+ StringUtil.lineEnding());		if (runPhredPhrap) {			shellScript.append(ShellScriptUtil.getWriteStringAsFile(statusFilePath, "" + sequenceCount + ". " + fullSeqName + " (" + fragmentName +", Phred)"));			shellScript.append(ShellScriptUtil.getAppendStringAsFile(phphLogFilePath, "" + sequenceCount + ". " + fullSeqName + " (Phred completed)"));		}		shellScript.append(getPhd2FastaCommand() + " -id . -os '" + seqFileName + "' -oq '" + seqFileName + ".qual'"+  commandTermination+ StringUtil.lineEnding());		if (runPhredPhrap) {			shellScript.append(ShellScriptUtil.getWriteStringAsFile(statusFilePath, "" + sequenceCount + ". " + fullSeqName + " (" + fragmentName +", Phd2Fasta)"));			shellScript.append(ShellScriptUtil.getAppendStringAsFile(phphLogFilePath, "" + sequenceCount + ". " + fullSeqName + " (Phd2Fasta completed)"));		}		shellScript.append(getPhrapCommand() + " '" + seqFileName  + "' -screen  -new_ace " + StringUtil.blankIfNull(phrapOptions) + redirectString+  StringUtil.lineEnding());		if (runPhredPhrap) {			shellScript.append(ShellScriptUtil.getWriteStringAsFile(statusFilePath, "" + sequenceCount + ". " + fullSeqName + " (" + fragmentName +", Phrap)"));			shellScript.append(ShellScriptUtil.getAppendStringAsFile(phphLogFilePath, "" + sequenceCount + ". " + fullSeqName + " (Phrap completed)"));		}		shellScript.append(ShellScriptUtil.getSetFileTypeCommand(directoryPath + MesquiteFile.fileSeparator + "" + seqFileName + ".ace"));		//postShellScript.append(getSetFileTypeCommand(sequenceDirPath + MesquiteFile.fileSeparator + "" + seqName + processedACESuffix + ".ace"));	}		/*.................................................................................................................*/	private void assignStLouisString(MesquiteString stLouisString, boolean isForward) {		if (isForward)			stLouisString.setValue("b.");		else			stLouisString.setValue("g.");			}	/*.................................................................................................................*/	/** returns the next token in a string AFTER a particular substring; returns empty string if substring not present*/	public static String getNextTokenAfterSubStringIgnoreCase(String line, String subString) {		if (line==null)			return null;		else if (line.equals(""))			return "";		int loc=line.toLowerCase().indexOf(subString.toLowerCase());		if (loc<0)			return "";		loc += subString.length();		Parser parser = new Parser(line);		parser.setPosition(loc);		String token = parser.getNextToken();		return token;	}	/*.................................................................................................................*/	public String getAnalysisParameters() {		StringBuffer sb = new StringBuffer();		sb.append("Phred Options: " + " -id . -pd . -d " + StringUtil.blankIfNull(phredOptions) + "\n");		sb.append("Phrap Options: " + " -new_ace " + StringUtil.blankIfNull(phrapOptions) + "\n");		sb.append("Chromaseq Options: \n");		sb.append("    Quality threshold for lower case: " + qualThresholdForLowerCase + "\n");		sb.append("    Convert multiple-peaks sites to ambiguity codes: " + processPolymorphisms + "\n");		sb.append("    Minimum secondary peak fraction for ambiguity: " + polyThreshold + "\n");		sb.append("    Trim low quality regions from ends: " + truncateMixedEnds + "\n");		sb.append("    Quality threshold for trim: " + qualThresholdForTrim + "\n");		sb.append("    Trim window length: " + mixedEndWindow + "\n");		sb.append("    Trim window threshold: " + mixedEndThreshold + "\n");				return sb.toString();	}	int sectionNumber=1;	/*.................................................................................................................*/	// starting the run	private boolean startExecution(String scriptPath, String runningFilePath){  //do we assume these are disconnectable?		if (scriptBased) {			scriptRunner = new ShellScriptRunner(scriptPath, runningFilePath, null, false, "Phred and Phrap", outputFilePaths, this, this, MesquiteTrunk.isWindows());  //scriptPath, runningFilePath, null, true, name, outputFilePaths, outputFileProcessor, watcher, true			return scriptRunner.executeInShell();		} else {			return executeProgramsInScriptFile(scriptPath);		}		/*Process proc = ShellScriptUtil.executeScript(scriptPath, true);		if (proc==null) {		if (progIndicator!=null) progIndicator.goAway();			return false;		}		return true;		*/	}		/*.................................................................................................................*/	// not fully implemented; not currently used.  Will require Java 8 	public boolean executeProgramsInScriptFile(String scriptPath){  		String contents = MesquiteFile.getFileContentsAsString(scriptPath);		Parser parser = new Parser(contents);		String line = parser.getRawNextDarkLine();		Parser subParser = new Parser();		boolean overallSuccess = true;		while (StringUtil.notEmpty(line) && overallSuccess) {			subParser.setString(line);			String programCommand = subParser.getFirstItem(line, "\t");			String executableName = "test";			String arguments = subParser.getRemaining();			//externalRunner = new ExternalProcessManager(this, null, programCommand, arguments, executableName, outputFilePaths, this, this, false);			boolean success = externalRunner.executeInShell();			if (!success)				overallSuccess = false;			line = parser.getRawNextDarkLine();		}		return overallSuccess;	}	/*.................................................................................................................*/	public boolean monitorExecution(ProgressIndicator progIndicator){		if (scriptBased) {			if (scriptRunner!=null) {				boolean success = scriptRunner.monitorAndCleanUpShell(progIndicator);				//if (progIndicator!=null && progIndicator.isAborted())				//	processRequester.setUserAborted(true);				return success;			}		} else {			if (externalRunner!=null) {				boolean success = externalRunner.monitorAndCleanUpShell(progIndicator);	//			if (progIndicator!=null && progIndicator.isAborted())	//				processRequester.setUserAborted(true);				return success;			}		}		return false;	}	/*.................................................................................................................*/	public boolean prepareAndRunPhredPhrap(MesquiteProject project, boolean appendIfPossible,  String directoryPath){		MesquiteBoolean pleaseStorePrefs = new MesquiteBoolean(false);		if (!queryForPaths(pleaseStorePrefs))			return false;		if (pleaseStorePrefs.getValue())			storePreferences();	// ============  getting primer info  ===========//		PrimerList primers = getPrimers();				// if not passed-in, then ask		if (StringUtil.blank(directoryPath)) {			directoryPath = MesquiteFile.chooseDirectory("Choose directory containing ABI files:", previousDirectory); //MesquiteFile.saveFileAsDialog("Base name for files (files will be named <name>1.nex, <name>2.nex, etc.)", baseName);		}		if (StringUtil.blank(directoryPath))			return false;		File directory = new File(directoryPath);		importedDirectoryPath = directoryPath + MesquiteFile.fileSeparator;		importedDirectoryName = directory.getName();		previousDirectory = directory.getParent();		storePreferences();		if (directory.exists() && directory.isDirectory()) {			logBuffer.setLength(0);			progIndicator = new ProgressIndicator(getProject(),"Preparing for Phred/Phrap");			progIndicator.setStopButtonName("Stop");			progIndicator.start();			boolean abort = false;			/*			Thread mt = Thread.currentThread();			 boolean piMine = false;			 if (mt instanceof MesquiteThread) 			 progIndicator = ((MesquiteThread)mt).getProgressIndicator();			 if (progIndicator ==null) {			 progIndicator = new ProgressIndicator(getProject(),"Running Phred & Phrap", 0);			 piMine = true;			 if (mt instanceof MesquiteThread)			 ((MesquiteThread)mt).setProgressIndicator(progIndicator);			 }			 progIndicator.setButtonMode(ProgressIndicator.FLAG_AND_HIDE);			 progIndicator.start();			 boolean abort = false;			 */			String cPath;			String seqFileName;			String fullSeqName;			String fragName = "";			StringBuffer shellScript = new StringBuffer(6000);			StringBuffer postShellScript = new StringBuffer(6000);			sequenceCount = 0;			if (MesquiteTrunk.isWindows())  {				shellScript.append("set PHRED_PARAMETER_FILE="+phredParamPath+ StringUtil.lineEnding());			} else {//				shellScript.append("setenv PHRED_PARAMETER_FILE "+StringUtil.protectForUnix(phredParamPath)+"\n");				//shellScript.append("#!/bin/csh  -v\nsetenv PHRED_PARAMETER_FILE "+StringUtil.protectFilePathForUnix(phredParamPath)+StringUtil.lineEnding());				if (MesquiteTrunk.isMacOSXCatalinaOrLater())					shellScript.append("#!/bin/zsh  -v\nexport PHRED_PARAMETER_FILE='"+phredParamPath+"'"+StringUtil.lineEnding());				else					shellScript.append("#!/bin/bash  -v\nexport PHRED_PARAMETER_FILE='"+phredParamPath+"'"+StringUtil.lineEnding());			}			//	shellScript.append(getAliasCommand ("phred",  phredPath + "phred"));			//	shellScript.append(getAliasCommand ("phd2fasta",phredPath+"phd2fasta"));			//	shellScript.append(getAliasCommand ("phrap",phredPath+"phrap"));			//set path = ( $path /usr/bin /usr/sbin /phredPhrap/ph/)			int loc = 0;			String[] files = directory.list();			StringBuffer renameBuffer = new StringBuffer(1000);			String processedDirPath = directoryPath + MesquiteFile.fileSeparator + processedFolder;  // directory into which processed files go			String originalsDirPath = directoryPath + MesquiteFile.fileSeparator + originalFolder;  // directory for copies of original files			loglnEchoToStringBuffer("\nPhred Phrap processing of chromatograms as scripted by Mesquite", logBuffer);			loglnEchoToStringBuffer(StringUtil.getDateTime(), logBuffer);			loglnEchoToStringBuffer(StringUtil.lineEnding()+"Mesquite "+ MesquiteTrunk.getMesquiteVersion() + MesquiteTrunk.getBuildVersion(), logBuffer);			loglnEchoToStringBuffer("Chromaseq "+ getVersion() + " (build " + getBuildNumberOfPackage()+")", logBuffer);			loglnEchoToStringBuffer(StringUtil.lineEnding()+" Processing directory: ", logBuffer);			loglnEchoToStringBuffer("  "+directoryPath+"\n", logBuffer);			if (sequenceNameTask!=null)				sequenceNameTask.echoParametersToFile(logBuffer);			if (primerInfoTask!=null)				primerInfoTask.echoParametersToFile(logBuffer);			loglnEchoToStringBuffer("Parameters: " + getAnalysisParameters()+"\n", logBuffer);			String rootDir = processedDirPath;			String fragmentDirPath = "";			File newDir;			int numPrepared = 0;			shellScript.append(ShellScriptUtil.getChangeDirectoryCommand(MesquiteTrunk.isWindows(), rootDir));			shellScript.append(getPhredCommand() + " -V -log"+StringUtil.lineEnding());			//shellScript.append("("+getPhrapCommand() + ") >& phrapFileToDetermineVersion\n");			shellScript.append(getPhrapCommand() + " > "+VERSION_FILE+StringUtil.lineEnding());			   			   			newDir = new File(processedDirPath);			try { 				newDir.mkdir();				if (backupOriginals) {					newDir = new File(originalsDirPath);					newDir.mkdir(); 				}			}			catch (SecurityException e) {				logln("Couldn't make directory.");				if (progIndicator!=null) progIndicator.goAway();				return false;			}			String runningFilePath = rootDir + MesquiteFile.fileSeparator + "running";			String shellScriptPath = rootDir + MesquiteFile.fileSeparator + PHRED_PHRAP_SCRIPT_FILE_NAME;			String contigPropertiesFilePath = rootDir + MesquiteFile.fileSeparator + "contigProperties.txt";			String readQualityFilePath = rootDir + MesquiteFile.fileSeparator + "readQualities.txt";			String statusFilePath = rootDir + MesquiteFile.fileSeparator + "status";			String phphLogFilePath = rootDir + MesquiteFile.fileSeparator + "phPhPh.log";			String phredLogFilePath = rootDir   + MesquiteFile.fileSeparator + "phred.log";			String phrapStdErrFilePath = rootDir   + MesquiteFile.fileSeparator + VERSION_FILE;			outputFilePaths = new String[3];			outputFilePaths[0] =statusFilePath;			outputFilePaths[1] =phphLogFilePath;			outputFilePaths[2] =phrapStdErrFilePath;			if (runPhredPhrap && singleScript)				MesquiteFile.putFileContents(runningFilePath, "Phred Phrap are running...", true);			fileNameTranslation= new String[5][files.length];			Vector infoFiles = new Vector();			loglnEchoToStringBuffer("---------------------------------------------------", logBuffer);			loglnEchoToStringBuffer("Section " +(sectionNumber++) + ": Examining chromatogram files and preparing directories ", logBuffer);			loglnEchoToStringBuffer("", logBuffer);						String[] localScriptPath = new String[files.length];			String[]  localRunningFilePath = new String[files.length];			String[]  localStatusFilePath = new String[files.length];			int numToProcess=0;						for (int i=0; i<files.length; i++) {				progIndicator.spin();				if (progIndicator.isAborted())					abort = true;				if (abort)					break;				fragName = "";				if (files[i]==null )					;				else {					cPath = directoryPath + MesquiteFile.fileSeparator + files[i];					File cFile = new File(cPath);					if (cFile.exists() && !cFile.isDirectory() && (!files[i].startsWith(".")) && (!requiresExtension || (files[i].endsWith("ab1") ||  files[i].endsWith(".abi")  || files[i].endsWith(".ab")  ||  files[i].endsWith(".CRO") || files[i].endsWith(".scf")))) {						String chromFileName = cFile.getName();						if (StringUtil.blank(chromFileName)) {							loglnEchoToStringBuffer("Bad file name; it is blank.", logBuffer);							// remove "running"							if (progIndicator!=null) progIndicator.goAway();							return false;						}						MesquiteString sampleCodeSuffix = new MesquiteString();						MesquiteString sampleCode = new MesquiteString();						MesquiteString primerName = new MesquiteString();						MesquiteString startTokenResult = new MesquiteString();						//here's where the names parser processes the name						if (nameParserManager!=null) {							if (!nameParserManager.parseFileName(chromFileName, sampleCode, sampleCodeSuffix, primerName, logBuffer, startTokenResult, null))								continue;						}						else {							loglnEchoToStringBuffer("Naming parsing rule is absent.", logBuffer);							return false;						}						if (startTokenResult.getValue() == null)							startTokenResult.setValue("");						MesquiteString stLouisString = new MesquiteString("");						if (primerInfoTask!=null){							fragName = primerInfoTask.getGeneFragmentName(primerName.getValue());							assignStLouisString(stLouisString,primerInfoTask.isForward(primerName.getValue()));						}						if (!StringUtil.blank(sampleCode.getValue())) {							/* Translate code number to sample name if requested  */							 if (sequenceNameTask!=null && sequenceNameTask.isReady()) {								seqFileName = sequenceNameTask.getAlternativeName(startTokenResult.getValue(), sampleCode.getValue());								fullSeqName = sequenceNameTask.getSequenceName(startTokenResult.getValue(), sampleCode.getValue());								}							else {								seqFileName = sampleCode.getValue();								fullSeqName = sampleCode.getValue();							}						}						else {							seqFileName = chromFileName.substring(1, 10); // change!							fullSeqName = seqFileName;						}						seqFileName = StringUtil.cleanseStringOfFancyChars(seqFileName + sampleCodeSuffix.getValue());  // tack on suffix						fullSeqName = StringUtil.cleanseStringOfFancyChars(fullSeqName + sampleCodeSuffix.getValue());						progIndicator.spin();						fragmentDirPath = processedDirPath;						if (StringUtil.blank(fragName)) {							loglnEchoToStringBuffer("  Primer not found: " + primerName, logBuffer);  // so stop processing this one							loglnEchoToStringBuffer("   " + chromFileName + " not processed", logBuffer);						}						else {								fragmentDirPath = StringUtil.cleansePath(directoryPath + MesquiteFile.fileSeparator + processedFolder + MesquiteFile.fileSeparator + fragName);							if (!makeDirectoriesForFragment(fragmentDirPath)){   //make directories for fragment in case they don't already exist								if (progIndicator!=null) progIndicator.goAway();								return false;							}							String sequenceDirPath = StringUtil.cleansePath(fragmentDirPath + MesquiteFile.fileSeparator + sequencesFolder  + MesquiteFile.fileSeparator + seqFileName); 							newDir = new File(sequenceDirPath);     							try {								StringBuffer localShellScript = new StringBuffer();								localShellScript.append("#!/bin/bash  -v\nexport PHRED_PARAMETER_FILE='"+phredParamPath+"'"+StringUtil.lineEnding());								if (!newDir.exists()) {  // then this is our first time encountering this sequence									sequenceCount++;																		localScriptPath[numToProcess] = sequenceDirPath + MesquiteFile.fileSeparator + PHRED_PHRAP_SCRIPT_FILE_NAME;									localRunningFilePath[numToProcess] = sequenceDirPath + MesquiteFile.fileSeparator + "running";									localStatusFilePath[numToProcess] = sequenceDirPath + MesquiteFile.fileSeparator + "status";									if (singleScript)										prepareShellScriptForDirectory(shellScript, postShellScript, statusFilePath, phphLogFilePath, fragmentDirPath, seqFileName, fullSeqName, fragName, sequenceDirPath);									else {										prepareShellScriptForDirectory(localShellScript, postShellScript, statusFilePath, phphLogFilePath, fragmentDirPath, seqFileName, fullSeqName, fragName, sequenceDirPath);									}																		if (!StringUtil.blank(fragName))										loglnEchoToStringBuffer("  Preparing " + fullSeqName + "  ("+fragName+")", logBuffer);									else 										loglnEchoToStringBuffer("  Preparing " + fullSeqName, logBuffer);									numPrepared++;																		ChromaseqInfoFile infoFile = new ChromaseqInfoFile();									infoFile.addSample(fullSeqName, sampleCode.getValue());									infoFile.addPhredPhrapOptions(phredOptions, phrapOptions);									infoFile.addChromaseqProcessingOptions(qualThresholdForLowerCase,  processPolymorphisms,  polyThreshold,  truncateMixedEnds,  qualThresholdForTrim,  mixedEndWindow,  mixedEndThreshold);																		infoFile.addSequenceNameSource(sequenceNameTask);									infoFile.addPrimerInfoSource(primerInfoTask);									String infoFilePath = sequenceDirPath  + StringUtil.cleansePath(MesquiteFile.fileSeparator + ChromaseqUtil.infoFileName); 									infoFile.setFilePath(infoFilePath);									infoFile.setDirectoryPath(sequenceDirPath);									infoFiles.add(infoFile);									newDir.mkdir(); //make new directory for this sequence									localShellScript.append(ShellScriptUtil.getRemoveCommand(MesquiteTrunk.isWindows(), localRunningFilePath[numToProcess]));									localShellScript.append(ShellScriptUtil.getRemoveCommand(MesquiteTrunk.isWindows(), localStatusFilePath[numToProcess]));									MesquiteFile.putFileContents(localScriptPath[numToProcess], localShellScript.toString(), true);									numToProcess++;								}								//now copy file to "originals" folder								String oldExtension = "";								if (chromFileName.indexOf('.')>0)									oldExtension = "."+ StringUtil.getLastItem(chromFileName, ".");								String extension = fileExtension;								if (StringUtil.blank(extension))									extension=oldExtension;								if (backupOriginals) {									try { 										String pathInOriginalFolder = originalsDirPath + MesquiteFile.fileSeparator + chromFileName;  // path to where original will be stored										File originalFile = new File(pathInOriginalFolder); //										MesquiteFile.copy(cFile, originalFile);									}									catch (IOException e) {										logln( "Can't copy: " + seqFileName); 									}								}								//now move and rename the original to this sequence's directory								//writeInfoFile(infoFilePath, fullSeqName);																try {									String newFileName = startTokenResult + sampleCode.getValue()+"." + stLouisString.getValue()+primerName+extension;									String newFilePath = sequenceDirPath + MesquiteFile.fileSeparator + newFileName;														File newFile = new File(newFilePath); //									int count=1;									while (newFile.exists()) {										newFileName = startTokenResult + sampleCode.getValue()+"_"+count + "." + stLouisString.getValue()+primerName+extension;										newFilePath = sequenceDirPath + MesquiteFile.fileSeparator + newFileName;										newFile = new File(newFilePath);										count++;									}									if (verbose) 										renameBuffer.append("  " + chromFileName + "  renamed to  " + newFileName + "\n");									fileNameTranslation[0][i] = newFileName;									fileNameTranslation[1][i] = chromFileName;									fileNameTranslation[2][i] = primerName.toString();									fileNameTranslation[3][i] = startTokenResult.getValue();									fileNameTranslation[4][i] = sampleCode.getValue();									ChromaseqInfoFile infoFile = ChromaseqInfoFile.getInfoFile(infoFiles,sequenceDirPath);									if (infoFile!=null)										infoFile.addChromatogramInfo(chromFileName, newFileName, primerName.toString());									cFile.renameTo(newFile); 								}								catch (SecurityException e) {									logln( "Can't rename: " + seqFileName);								}							}							catch (SecurityException e) {								logln( "Can't make directory: " + seqFileName);							}						}					}				}			}			if (infoFiles!=null){				loglnEchoToStringBuffer("Writing info.xml files...", logBuffer);				ChromaseqInfoFile.writeInfoFiles(infoFiles, progIndicator);				ChromaseqInfoFile.dispose(infoFiles);			}			loglnEchoToStringBuffer("", logBuffer);			loglnEchoToStringBuffer("Number of files prepared: " + numPrepared, logBuffer);			loglnEchoToStringBuffer("", logBuffer);			loglnEchoToStringBuffer("---------------------------------------------------", logBuffer);			loglnEchoToStringBuffer("Section " +(sectionNumber++) + ": Renaming chromatograms for Phred and Phrap", logBuffer);			if (verbose)				loglnEchoToStringBuffer("\n" + renameBuffer.toString()+"\n", logBuffer);			boolean findPhredVersion = true;			String phredVersion = null;			boolean findPhrapVersion = true;			String phrapVersion = null;			if (singleScript) {				shellScript.append(ShellScriptUtil.getRemoveCommand(MesquiteTrunk.isWindows(), runningFilePath));				shellScript.append(ShellScriptUtil.getRemoveCommand(MesquiteTrunk.isWindows(), statusFilePath));				numToProcess=1;				localScriptPath[0] = shellScriptPath;				localRunningFilePath[0] = runningFilePath;			}			MesquiteFile.putFileContents(shellScriptPath, shellScript.toString(), true);			if (!abort) {				if (!singleScript) {					try {						ShellScriptUtil.setScriptFileToBeExecutable(shellScriptPath);							boolean success = startExecution(shellScriptPath, null);							if (success) {								success = monitorExecution(progIndicator);							}					} catch (IOException e){						logln("IOE error: " +  e);						abort =true;					}				}					progIndicator.spin();					if (runPhredPhrap) {						readQualityFileBuffer = new StringBuffer();						for (int fileNumber = 0; fileNumber<numToProcess; fileNumber++) {							//note name of file should end in .command for Terminal in OS X to run it; on other OS's we may be able to get the script to run directly from Runtime.exec							try {								ShellScriptUtil.setScriptFileToBeExecutable(localScriptPath[fileNumber]);								if (!startExecution(localScriptPath[fileNumber], localRunningFilePath[fileNumber]))									return false;								boolean success = monitorExecution(progIndicator);																if (progIndicator!=null)									progIndicator.setTitle("Running Phred & Phrap");								if (fileNumber==0) {									loglnEchoToStringBuffer("", logBuffer);									loglnEchoToStringBuffer("---------------------------------------------------", logBuffer);									loglnEchoToStringBuffer("Section " +(sectionNumber++) + ": Execution of Phred-Phrap command file begun", logBuffer);								}								/*On OS X at this point the script operates asyncronously, so if we wanted to immediately go into the post processing we'd have to listen for some file showing up or such							 When runtime.exec runs the script directly, proc.waitFor() can be used to force this thread to hang until the script finishes*/								/* the following does nothing on OS X, but will be useful on other OS's if previous statement executes script directly so as to show processing in log window  							 InputStream stream = proc.getInputStream();							 int c = 0;							 while ((c=stream.read())!=-1){							 log("" + (char)c);							 }							 /**/							}							catch (IOException e){								logln("IOE error: " +  e);								abort =true;							}							try {								String oldStatus = "";								int equalStatusCount = 0;								int count=-3;								while (MesquiteFile.fileExists(localRunningFilePath[fileNumber]) && !abort){									String status = "";									if (MesquiteFile.fileExists(statusFilePath)) {										status = MesquiteFile.getFileContentsAsString(statusFilePath);									}									if (!StringUtil.blank(status)) {										if (progIndicator!=null) {											if (progIndicator.getTotalValue()==0) {												progIndicator.setTotalValue(sequenceCount);												//progIndicator.repaintBar();											}											progIndicator.setText(status);											String s = StringUtil.getFirstItem(status,".");											int num = MesquiteInteger.fromString(s);											progIndicator.setCurrentValue(num);										}										if (status.equalsIgnoreCase(oldStatus))											equalStatusCount++;										else {											equalStatusCount = 0;											log(status);										}										if (equalStatusCount>25) {											logln("There may be a problem: Phred and Phrap do not seem to be actively analyzing files.");											if (equalStatusCount>35)												abort=true;										}										oldStatus = status;									}									else {										log(".");										if (progIndicator!=null) progIndicator.spin();									}									count = 1;									//}									if (progIndicator.isAborted())										abort = true;									Thread.sleep(200);									count++;								}								//logln("");								if (abort)									loglnEchoToStringBuffer("Mesquite processing stopped.", logBuffer);							//	else 							//		loglnEchoToStringBuffer("Phred & Phrap analyses completed.", logBuffer);							}							catch (InterruptedException e){								Thread.currentThread().interrupt();							}						}					}			}			if (findPhredVersion && MesquiteFile.fileExists(phredLogFilePath)) {   // get phredVersion				String phredLog = MesquiteFile.getFileContentsAsString(phredLogFilePath);				phredVersion = getNextTokenAfterSubStringIgnoreCase(phredLog, "PHRED version");				findPhredVersion = false;			}			if (findPhrapVersion && MesquiteFile.fileExists(phrapStdErrFilePath)) {   // get phredVersion				String phrapStdErr = MesquiteFile.getFileContentsAsString(phrapStdErrFilePath);				phrapVersion = getNextTokenAfterSubStringIgnoreCase(phrapStdErr, "phrap version");				findPhrapVersion = false;			}			if (runPhredPhrap && !abort) {				//PostPhrap pPhrap = (PostPhrap)hireEmployee(PostPhrap.class, "Post Phrap Processing");				if (!abort) {					loglnEchoToStringBuffer("", logBuffer);					loglnEchoToStringBuffer("---------------------------------------------------", logBuffer);					loglnEchoToStringBuffer("Section " +(sectionNumber++) + ": Mesquite processing of Phrap results", logBuffer);					contigPropertiesFileBuffer = new StringBuffer();					postPhrapOnDirectory( project,appendIfPossible, rootDir);					MesquiteFile.putFileContents(contigPropertiesFilePath, contigPropertiesFileBuffer.toString(), true);					MesquiteFile.putFileContents(readQualityFilePath, readQualityFileBuffer.toString(), true);				}			}			if (progIndicator!=null)				progIndicator.goAway();						loglnEchoToStringBuffer(StringUtil.getDateTime(), logBuffer);			logBuffer.append("Mesquite version: " + MesquiteTrunk.mesquiteTrunk.getVersion()+", build number " + MesquiteTrunk.mesquiteTrunk.getBuildNumber()+"\n");			loglnEchoToStringBuffer("Chromaseq version: " + getVersion(), logBuffer);			if (StringUtil.notEmpty(phredVersion))				loglnEchoToStringBuffer("Phred version: " + phredVersion, logBuffer);			if (StringUtil.notEmpty(phrapVersion))				loglnEchoToStringBuffer("Phrap version: " + phrapVersion, logBuffer);			loglnEchoToStringBuffer("", logBuffer);			loglnEchoToStringBuffer("========================", logBuffer);			loglnEchoToStringBuffer("", logBuffer);			MesquiteFile.putFileContents(rootDir + MesquiteFile.fileSeparator + "phredPhrapLog.txt", logBuffer.toString(), true);			MesquiteFile.deleteFile(phredLogFilePath);			if (project != null) {				//project.getCoordinatorModule().saveFile(project.getHomeFile());				if (originalData != null)					originalData.setDirty(true); //so that user will prompted; seems to be needed for annotations to be saved			}		}		return true;	}	/*.................................................................................................................*/	private void addWindowsHeaderOLD(StringBuffer shellScript) {		// TODO: Issues with new-ish Windows/Cygwin. Oliver.July.30.2015		// original implementation has these two lines		shellScript.append("REGEDIT /E %Temp%.\\tmp-cygwin.reg \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Cygnus Solutions\\Cygwin\\mounts v2\\/\"> nul"+ StringUtil.lineEnding());		shellScript.append("FOR /F \"tokens=1* delims==\" %%A IN ('TYPE %Temp%.\\tmp-cygwin.reg ^| FIND \"native\"') DO SET CYGWIN_ROOT=%%B> nul"+ StringUtil.lineEnding());        // For newer (?) installations of Cygwin, replace those two lines ^^ with these two lines vv		// shellScript.append("REGEDIT /E %Temp%.\\tmp-cygwin.reg \"HKEY_LOCAL_MACHINE\\SOFTWARE\\Cygwin\\setup\"> nul\n");		// shellScript.append("FOR /F \"tokens=1* delims==\" %%A IN ('TYPE %Temp%.\\tmp-cygwin.reg ^| FIND \"rootdir\"') DO SET CYGWIN_ROOT=%%B> nul\n");        // An alternative approach would be to shift the entire burden to the Windows user,        // Asking where cygwin is installed; it is often in the root, C:\cygwin64				shellScript.append("SET CYGWIN_ROOT=%CYGWIN_ROOT:\"=%> nul"+ StringUtil.lineEnding());		shellScript.append("if exist %Temp%.\\tmp-cygwin.reg del %Temp%.\\tmp-cygwin.reg"+ StringUtil.lineEnding());		shellScript.append("SET PATH=.;%CYGWIN_ROOT%\\bin;%CYGWIN_ROOT%\\opt\\elinos\\bin;%PATH%"+ StringUtil.lineEnding());		shellScript.append("set PHRED_PARAMETER_FILE="+phredParamPath+ StringUtil.lineEnding());	}	int aceFileCount = 0;	boolean processFolderAborted = false;	Vector goodNews = new Vector();	Vector badNews = new Vector();	/*.................................................................................................................*/	public void writeInfoFile(String infoFilePath, String fullName){		StringBuffer infoFileBuffer = new StringBuffer();		infoFileBuffer.append(fullName);  //here write the XML info file 		MesquiteFile.putFileContents(infoFilePath, infoFileBuffer.toString(), true);	}	StringBuffer contigPropertiesFileBuffer;	StringBuffer readQualityFileBuffer;	/*.................................................................................................................*/	public void processAceFileWithContig(MesquiteProject project, String processedAceFilePath, String fragmentDirPath, AceFile ace, SequenceUploader uploader, String geneName, MesquiteString fullName, String baseName, MesquiteString voucherCode) {		ace.setNameTranslation(fileNameTranslation);		log(ace.contigListForLog()+StringUtil.lineEnding());		if (processPolymorphisms)			ace.processPolys();  //creates an additional CO that has polys in it		if (renameContigsInAceFiles)			ace.renameContigs(fullName.toString(), addFragName, geneName);		ace.addReadInfoToBuffer(readQualityFileBuffer);		ace.setLowQualityToLowerCase(qualThresholdForLowerCase); 		ace.writeToPropertiesFile(contigPropertiesFileBuffer, fullName.toString());		if (truncateMixedEnds)			ace.trimMixedEnds(mixedEndThreshold, mixedEndWindow, qualThresholdForTrim, addPhrapFailures);		if (uploadResultsToDatabase && uploader!=null && databaseURLSource!=null) {			// note: this should really be abstracted, and become a job for a module to do; we shouldn't see the raw reference to getTOLPageDatabaseURL in here			uploader.uploadAceFileToServer(MesquiteXMLToLUtilities.getTOLPageDatabaseURL(databaseURLSource.getBaseURL()), ace, processPolymorphisms, qualThresholdForTrim);		}		System.out.println("\n\nfasta file name: " + baseName + " ace file: " + ace);		MesquiteFile.putFileContents(fragmentDirPath  + MesquiteFile.fileSeparator + ChromaseqUtil.processedFastaFolder + MesquiteFile.fileSeparator + baseName+".fas", ace.toFASTAString(processPolymorphisms, qualThresholdForTrim), true);		MesquiteFile.putFileContents(processedAceFilePath, ace.toString(processPolymorphisms), true);		if (project != null) {			ace.importSequence(taxa, data, MesquiteInteger.unassigned, originalData, qualityData, registrationData, singleTaxaBlock, processPolymorphisms, maxChar," contig ", false, voucherCode);		}	}		/*.................................................................................................................*/	public void processAceFileWithoutContig(String processedAceFilePath, AceFile ace, String geneName, MesquiteString fullName, MesquiteString voucherCode) {		ace.processFailedContig(polyThreshold);		ace.setNameTranslation(fileNameTranslation);				if (renameContigsInAceFiles)			ace.renameContigs(fullName.toString(), addFragName, geneName);		ace.setLowQualityToLowerCase(qualThresholdForLowerCase); 		ace.writeToPropertiesFile(contigPropertiesFileBuffer, fullName.toString());		if (truncateMixedEnds)			ace.trimMixedEnds(mixedEndThreshold, mixedEndWindow, qualThresholdForTrim, addPhrapFailures);		MesquiteFile.putFileContents(processedAceFilePath, ace.toString(processPolymorphisms), true);		ace.importSequence(taxa, data, MesquiteInteger.unassigned, originalData, qualityData, registrationData, singleTaxaBlock, processPolymorphisms, maxChar,"", true, voucherCode);		ace.addReadInfoToBuffer(readQualityFileBuffer);	}	/*.................................................................................................................*/	public boolean processAceFileDirectory(MesquiteProject project, boolean appendIfPossible, File directory, String directoryPath, String enclosingDirName, String geneName, String dataFilePath, int level){		boolean addingPhrapFailures = false;		String[] files = directory.list();				String processedAceFilePath = null;		AceFile ace = null;		int currentRead = -1;		if (uploadResultsToDatabase)			checkDatabaseSource();		SequenceUploader uploader = new SequenceUploader(databaseURLSource);		MesquiteString fullName = null;		MesquiteString voucherCode = new MesquiteString();		for (int i=0; i<files.length && !processFolderAborted; i++) { // going through the folders and finding the ace files			if (files[i]!=null ) {				String filePath = directoryPath + MesquiteFile.fileSeparator + files[i];				String infoFilePath = directoryPath + MesquiteFile.fileSeparator + ChromaseqUtil.infoFileName;				File cFile = new File(filePath);				if (cFile.exists()) {					if (!cFile.isDirectory()) {						if (files[i].endsWith(".ace")  && !files[i].startsWith(".") && !addingPhrapFailures) {							aceFileCount++;							loglnEchoToStringBuffer("Processing ACE file: " + files[i], logBuffer);							String baseName = files[i].substring(0,files[i].length()-4);  //this is the name of the sequence							processedAceFilePath = directoryPath + MesquiteFile.fileSeparator + baseName+ChromaseqUtil.processedACESuffix+".ace";							ace = new AceFile(filePath,processedAceFilePath, dataFilePath, dataFilePath, this, processPolymorphisms, polyThreshold, appendIfPossible && project!=null);							ace.setBaseName(baseName);							fullName = new MesquiteString(baseName);							voucherCode = new MesquiteString(baseName);							ChromaseqInfoFile.processInfoFile(infoFilePath, fullName, voucherCode);							String fragmentDirPath = StringUtil.getAllButLastItem(StringUtil.getAllButLastItem(directoryPath,MesquiteFile.fileSeparator ),MesquiteFile.fileSeparator );															ace.setLongSequenceName(fullName.toString());							if (ace.getNumContigs()>=1) {								processAceFileWithContig(project,  processedAceFilePath,  fragmentDirPath,  ace,  uploader,  geneName,  fullName,  baseName, voucherCode);							}							else {								loglnEchoToStringBuffer("   ACE file contains no contigs!", logBuffer); 								badNews.addElement("    (" + geneName + ") -- " + baseName);								if (addPhrapFailures && project !=null) {									addingPhrapFailures = true;									i=-1;									ace.createEmptyContigs(MesquiteFile.numFilesEndingWith(directoryPath,files,".phd.1"));  //create an empty contig									if (renameContigsInAceFiles)										ace.renameContigs(fullName.toString(), addFragName, geneName);								}							}							if (!addingPhrapFailures)								ace.dispose();						}						else if (files[i].endsWith(".phd.1") && addingPhrapFailures) {							loglnEchoToStringBuffer("   Importing single-read Phred file "+files[i], logBuffer); 							currentRead++;							ace.addPhdFileAsSingleReadInContig(currentRead, directoryPath, files[i], processPolymorphisms, polyThreshold);						}					}				}			}		}						if (addingPhrapFailures && ace !=null ) {  // have to process AceFile that we have manually made			MesquiteFile.putFileContents(processedAceFilePath, ace.toString(processPolymorphisms), true);			if (project != null){				processAceFileWithoutContig( processedAceFilePath,  ace,  geneName,  fullName, voucherCode);			}			ace.dispose();		}		return false;	}		/*.................................................................................................................*/	public boolean processFolderAfterPhrap(MesquiteProject project, boolean appendIfPossible, File directory, String directoryPath, String enclosingDirName, String geneName, String dataFilePath, int level, MesquiteInteger numAceFiles){		boolean addingPhrapFailures = false;		if (processFolderAborted)			return false;		String[] files = directory.list();		String sequenceName = geneName;		String originalDataFilePath = dataFilePath;		if (project!=null){			originalDataFilePath= project.getHomeFile().getPath();			originalDataFilePath=MesquiteFile.getDirectoryPathFromFilePath(originalDataFilePath);		}		boolean rename = false;		if (level == 1)			sequenceName = directory.getName();		if (level == 1 && project!=null) {			project.virginProject=false;			taxa = null;  //making sure nothing old is remembered accidentally			//getting ready to import; making matrices to be filled			if (appendIfPossible && project != null){				data = (DNAData)project.getCharacterMatrixByReference(null, directory.getName());  // Dec 2019:  removed  + " (from Phred/Phrap)"				originalData = (DNAData)project.getCharacterMatrixByReference(null, directory.getName() + " (ORIGINAL from Phred/Phrap)");				qualityData = (ContinuousData)project.getCharacterMatrixByReference(null, "Quality Scores for " + directory.getName()  + " from Phred/Phrap");			//	addedBaseData = (CategoricalData)project.getCharacterMatrixByReference(null, "Bases added for " + directory.getName()  + " from Phred/Phrap");				registrationData = (MeristicData)project.getCharacterMatrixByReference(null, "Registration of " + directory.getName()  + " from Phred/Phrap");//DAVID: if change name here have to change elsewhere				if (data !=null && (qualityData==null || originalData==null || registrationData==null)){					//discreetAlert("Cannot append chromatogram information to the matrix \"" + data.getName() + "\" that does not contain Chromaseq data");					data = null;					rename = true;				}				if (originalData != null)					originalData.saveChangeHistory = false;				if (qualityData != null)					qualityData.saveChangeHistory = false;		//		if (addedBaseData != null)		//			addedBaseData.saveChangeHistory = false;				if (data != null){					taxa = data.getTaxa();					data.saveChangeHistory = false;				}			}			if (taxa == null){				if (singleTaxaBlock) {					if (project.getNumberTaxas()>0)						taxa = project.getTaxa(0);					if (taxa == null) {						taxa = project.createTaxaBlock(0);						taxa.setName("Sequences");					}				}				else {					taxa = project.createTaxaBlock(0);					String taxaBlockName = directory.getName() + " Sequences";					if (rename) {						ListableVector taxas = getProject().getTaxas();						taxaBlockName = taxas.getUniqueName(taxaBlockName);					}					taxa.setName(taxaBlockName);				}			}			CharactersManager manageCharacters = (CharactersManager)coord.findElementManager(mesquite.lib.characters.CharacterData.class);			MesquiteString uid = new MesquiteString(ChromaseqUtil.PHPHIMPORTIDREF, MesquiteTrunk.getUniqueIDBase());			MesquiteString gN = new MesquiteString(ChromaseqUtil.GENENAMEREF, directory.getName());			if (data == null){				data =  (DNAData)manageCharacters.newCharacterData(taxa, 0, DNAData.DATATYPENAME);  //				data.saveChangeHistory = false;				data.addToFile(file, project, manageCharacters);  				String matrixName = directory.getName(); // Dec 2019  removed + " (from Phred/Phrap)";				if (rename) {					ListableVector datas = getProject().getCharacterMatrices();					matrixName = datas.getUniqueName(matrixName);				}				data.setName(matrixName);				ChromaseqUtil.attachStringToMatrix(data,uid);				ChromaseqUtil.attachStringToMatrix(data,gN);				ChromaseqUtil.attachStringToMatrix(data,new MesquiteString(ChromaseqUtil.PHPHMQVERSIONREF, ChromaseqUtil.PHPHMQVERSION));				ChromaseqUtil.attachStringToMatrix(data,new MesquiteString(ChromaseqUtil.PHPHIMPORTMATRIXTYPEREF, ChromaseqUtil.EDITEDREF));			}			if (originalData == null){				originalData =  (DNAData)manageCharacters.newCharacterData(taxa, 0, DNAData.DATATYPENAME);  //				originalData.saveChangeHistory = false;				originalData.incrementEditInhibition();				originalData.setUserVisible(ChromaseqUtil.isChromaseqDevelopment());				originalData.addToFile(file, project, manageCharacters);  				originalData.setName(directory.getName() + " (ORIGINAL from Phred/Phrap)");				//data.addToLinkageGroup(originalData); //link matrices!   //DAVID: uncomment this to reverse new registration system				originalData.setResourcePanelIsOpen(false);				ChromaseqUtil.attachStringToMatrix(originalData,uid);				ChromaseqUtil.attachStringToMatrix(originalData,gN);				ChromaseqUtil.attachStringToMatrix(originalData,new MesquiteString(ChromaseqUtil.PHPHIMPORTMATRIXTYPEREF, ChromaseqUtil.ORIGINALREF));				originalData.incrementEditInhibition();			}			if (qualityData == null){				qualityData =  (ContinuousData)manageCharacters.newCharacterData(taxa, 0, ContinuousData.DATATYPENAME);  //				qualityData.saveChangeHistory = false;				qualityData.addToFile(file, project, manageCharacters);  				//data.addToLinkageGroup(qualityData); //link matrices!  //DAVID: uncomment this to reverse new registration system				qualityData.setName("Quality Scores for " + directory.getName()  + " from Phred/Phrap");				qualityData.setResourcePanelIsOpen(false);				qualityData.setUserVisible(ChromaseqUtil.isChromaseqDevelopment());				ChromaseqUtil.attachStringToMatrix(qualityData,uid);				ChromaseqUtil.attachStringToMatrix(qualityData,gN);				ChromaseqUtil.attachStringToMatrix(qualityData,new MesquiteString(ChromaseqUtil.PHPHIMPORTMATRIXTYPEREF, ChromaseqUtil.QUALITYREF));				qualityData.incrementEditInhibition();				qualityData.setUseDiagonalCharacterNames(false);			}/*			if (addedBaseData == null){				addedBaseData =  (CategoricalData)manageCharacters.newCharacterData(taxa, 0, CategoricalData.DATATYPENAME);  //				addedBaseData.addToFile(file, project, manageCharacters);  				addedBaseData.setUserVisible(ChromaseqUtil.isChromaseqDevelopment());//				ChromaseqUtil.setAddedBaseDataValues(addedBaseData, data, directory.getName(), uid, gN);			}*/			if (registrationData == null){				registrationData =  (MeristicData)manageCharacters.newCharacterData(taxa, 0, MeristicData.DATATYPENAME);  //				registrationData.setUserVisible(ChromaseqUtil.isChromaseqDevelopment());				registrationData.addToFile(file, project, manageCharacters);  								ChromaseqUtil.setRegistryDataValues(registrationData,  data, directory.getName() ,  uid,  gN);			}			ChromaseqUtil.setChromaseqRegistrationBuildOfMatrix(data,ChromaseqUtil.ChromaseqRegistrationBuild);			if (appendIfPossible && project != null)				maxChar.setValue(data.getNumChars());  // DRM 8.Nov.2013  Added this to fix the bug whereby existing data could be truncated. 			else				maxChar.setValue(0);						//qualityData.attachIf UniqueName(new MesquiteString(ChromaseqUtil.PHPHIMPORTMATRIXTYPEREF, "quality")); use method in ChromaseqUtil instead					}		String processedAceFilePath = null;		AceFile ace = null;		int currentRead = -1;		if (uploadResultsToDatabase)			checkDatabaseSource();		SequenceUploader uploader = new SequenceUploader(databaseURLSource);		MesquiteString fullName = null;		MesquiteString voucherCode = null;		for (int i=0; i<files.length && !processFolderAborted; i++) { // going through the folders and finding the ace files			if (files[i]!=null ) {				String filePath = directoryPath + MesquiteFile.fileSeparator + files[i];				String infoFilePath = directoryPath + MesquiteFile.fileSeparator + ChromaseqUtil.infoFileName;				File cFile = new File(filePath);				if (cFile.exists()) {					if (cFile.isDirectory()) {						processFolderAfterPhrap(project, appendIfPossible, cFile, filePath, directory.getName(), sequenceName, dataFilePath, level+1,numAceFiles);						//log(".");					}					else {						if (files[i].endsWith(".ace")  && !files[i].startsWith(".") && !addingPhrapFailures) {							aceFileCount++;							if (progIndicator!=null) {								if (progIndicator.getTotalValue()==0) {									progIndicator.setTotalValue(sequenceCount);									//progIndicator.repaintBar();								}								progIndicator.setText("Processing: " + files[i] + " ("+ geneName+")");								progIndicator.setCurrentValue(aceFileCount);								if (progIndicator.isAborted()) { 									processFolderAborted = true;									return false;								}							}							loglnEchoToStringBuffer("Processing ACE file: " + files[i], logBuffer);							numAceFiles.increment();							String baseName = files[i].substring(0,files[i].length()-4);  //this is the name of the sequence							processedAceFilePath = directoryPath + MesquiteFile.fileSeparator + baseName+ChromaseqUtil.processedACESuffix+".ace";							ace = new AceFile(filePath,processedAceFilePath, dataFilePath, originalDataFilePath, this, processPolymorphisms, polyThreshold, appendIfPossible);							ace.setBaseName(baseName);							fullName = new MesquiteString(baseName);							voucherCode = new MesquiteString();							ChromaseqInfoFile.processInfoFile(infoFilePath, fullName, voucherCode);							String fragmentDirPath = StringUtil.getAllButLastItem(StringUtil.getAllButLastItem(directoryPath,MesquiteFile.fileSeparator ),MesquiteFile.fileSeparator );															ace.setLongSequenceName(fullName.toString());														if (ace.getNumContigs()>=1) {								processAceFileWithContig(project,  processedAceFilePath,  fragmentDirPath,  ace,  uploader,  geneName,  fullName,  baseName, voucherCode);								goodNews.addElement("    (" + geneName + ") -- " + fullName);							}							else {								loglnEchoToStringBuffer("   ACE file contains no contigs!", logBuffer); 								badNews.addElement("    (" + geneName + ") -- " + baseName);								if (addPhrapFailures && project !=null) {									addingPhrapFailures = true;									i=-1;  // 24 Feb 2O18: set to -1 as wasn't getting first file in directory if set to 0 as loop was setting it then to 1									ace.createEmptyContigs(MesquiteFile.numFilesEndingWith(directoryPath,files,".phd.1"));  //create an empty contig									if (renameContigsInAceFiles)										ace.renameContigs(fullName.toString(), addFragName, geneName);								}							}							if (!addingPhrapFailures)								ace.dispose();						}						else if (files[i].endsWith(".phd.1") && addingPhrapFailures) {							loglnEchoToStringBuffer("   Importing single-read Phred file "+files[i], logBuffer); 							currentRead++;							ace.addPhdFileAsSingleReadInContig(currentRead, directoryPath, files[i], processPolymorphisms, polyThreshold);						}					}				}			}		}						if (addingPhrapFailures && ace !=null ) {  // have to process AceFile that we have manually made			MesquiteFile.putFileContents(processedAceFilePath, ace.toString(processPolymorphisms), true);			if (project != null){				processAceFileWithoutContig(processedAceFilePath,  ace,  geneName,  fullName, voucherCode);			}			ace.dispose();		}						if (taxa!=null)			taxa.notifyListeners(this, new Notification(PARTS_ADDED));		if (level ==1 && project !=null){ 			//Wayne: cleaning up and showing matrix			if (maxChar.getValue()<data.getNumChars()-1) {				data.deleteCharacters(maxChar.getValue()+1, data.getNumChars()-maxChar.getValue()+1, false);//				addedBaseData.deleteCharacters(maxChar.getValue()+1, addedBaseData.getNumChars()-maxChar.getValue()+1, false);				originalData.deleteCharacters(maxChar.getValue()+1, originalData.getNumChars()-maxChar.getValue()+1, false);				qualityData.deleteCharacters(maxChar.getValue()+1, qualityData.getNumChars()-maxChar.getValue()+1, false);				registrationData.deleteCharacters(maxChar.getValue()+1, registrationData.getNumChars()-maxChar.getValue()+1, false);			}			// creating reverse registry matrices			mesquite.chromaseq.ChromaseqFileCleanup.ChromaseqFileCleanup init = (mesquite.chromaseq.ChromaseqFileCleanup.ChromaseqFileCleanup)findNearestColleagueWithDuty(mesquite.chromaseq.ChromaseqFileCleanup.ChromaseqFileCleanup.class);			if (init !=null) {				init.createReverseRegistryDataIfNeeded(file);			}			/*for (int ic = 0; ic<data.getNumChars(); ic++){			 for (int it=0; it<data.getNumTaxa(); it++){			 originalData.setState(ic, it, data.getState(ic, it));			 }			 }*/			data.showMe();  			DataWindowMaker mb = coord.findCharacterDataEditor(data);			if (mb != null) {				String commands=null;				if (appendIfPossible && project != null) {					if (showBirdsEye) 						commands = "getWindow; tell It;  toggleBirdsEye on;  showWindow; endTell;";  				}				else {					if (showBirdsEye)						commands = "getWindow; tell It; setSize 700 400; colorCells  #mesquite.chromaseq.ColorQuality.ColorQuality;  colorRowNames  #mesquite.chromaseq.ColorQuality.ColorQuality;  toggleBirdsEye on;  toggleAutoTaxonNames on; showWindow; endTell;";  					else						commands = "getWindow; tell It; setSize 700 400; colorCells  #mesquite.chromaseq.ColorQuality.ColorQuality;  colorRowNames  #mesquite.chromaseq.ColorQuality.ColorQuality;  showWindow; endTell;";  				}				if (commands!=null) {					Puppeteer p = new Puppeteer(this);					MesquiteInteger pos = new MesquiteInteger(0);					p.execute(mb, commands, pos, "", false);				}			}			data = null;			originalData = null;			qualityData = null;//			addedBaseData = null;			registrationData = null;		}		return false;	}	/*.................................................................................................................*/	public boolean postPhrapOnDirectory( MesquiteProject project, boolean appendIfPossible, String directoryPath){		if (StringUtil.blank(directoryPath))			return false;		File directory = new File(directoryPath);		if (directory.exists() && directory.isDirectory()) {			logln(" ");			String dataFilePath = null;			if (project != null) {				coord = project.getCoordinatorModule();				file = project.getHomeFile();				if (!appendIfPossible)  // don't move and rename file if you are just appending new sequences!					file.changeLocation(importedDirectoryPath, importedDirectoryName + ".nex");				dataFilePath = importedDirectoryPath;			}			aceFileCount = 0;			processFolderAborted = false;			if (progIndicator!=null)				progIndicator.setTitle("Processing Phred/Phrap output");			goodNews.removeAllElements();			badNews.removeAllElements();			MesquiteInteger numAceFiles = new MesquiteInteger(0);			processFolderAfterPhrap(project, appendIfPossible, directory, directoryPath,"", null, dataFilePath, 0, numAceFiles);			if (numAceFiles.getValue()==0){				loglnEchoToStringBuffer("WARNING: No ace files encountered. There was a problem with the processing.  Phred or Phrap may have failed.  Please check the Troubleshooting page of the Chromaseq manual.", logBuffer);			}			logln("");			loglnEchoToStringBuffer("", logBuffer);			loglnEchoToStringBuffer("========================", logBuffer);			loglnEchoToStringBuffer("Section " +(sectionNumber++) + ": Phred/Phrap processing report", logBuffer);			loglnEchoToStringBuffer("", logBuffer);			if (goodNews.size()>0){				loglnEchoToStringBuffer("Multi-read sequences obtained from the following genes and samples:", logBuffer);				for (int i=0; i<goodNews.size(); i++)					loglnEchoToStringBuffer("   " + (String)goodNews.elementAt(i), logBuffer);			}			if (badNews.size()>0){				loglnEchoToStringBuffer("Multi-read sequences FAILED to be obtained from the following genes and samples:", logBuffer);				for (int i=0; i<badNews.size(); i++)					loglnEchoToStringBuffer("   " + (String)badNews.elementAt(i), logBuffer);			}			if (badNews.size()<=0 && goodNews.size()<=0){				loglnEchoToStringBuffer("WARNING: There was a problem with the processing.  Phred or Phrap may have failed, or Chromaseq may have failed.  Please check the Troubleshooting page of the Chromaseq manual.", logBuffer);			}			loglnEchoToStringBuffer("", logBuffer);			loglnEchoToStringBuffer("========================", logBuffer);			logln("");			logln("Processing of chromatogram files completed.");			logln("");		}		return false;	}	/*.................................................................................................................*/	public boolean postPhrap(MesquiteProject project){		String directoryPath = MesquiteFile.chooseDirectory("Choose directory containing Phrap files:"); 		logBuffer.setLength(0);		return postPhrapOnDirectory(project, false, directoryPath);	}	/*.................................................................................................................*/	public void checkDatabaseSource() {		if (databaseURLSource==null)			databaseURLSource= (DNADatabaseURLSource)hireEmployee(DNADatabaseURLSource.class, "Source of Database Connectivity");	} 	public DNADatabaseURLSource getDatabaseURLSource() { 		checkDatabaseSource(); 		return databaseURLSource; 	}	/*.................................................................................................................*/	public String getName() {		return "Prepare and Run Phred and Phrap";	}	/*.................................................................................................................*/	public boolean showCitation() {		return false;	}	/*.................................................................................................................*/	public String getExplanation() {		return "Prepares a folder of abi files for Phred and Phrap, and makes a shell script to invoke Phred and Phrap within each folder, and runs the script.";	}	private SequenceNameSource replaceSequenceNameSource(String arguments) {		SequenceNameSource temp = (SequenceNameSource)replaceEmployee(SequenceNameSource.class, arguments, "Supplier of sequence names from sample codes", sequenceNameTask);		if (temp !=null) {			sequenceNameTask=temp;			sequenceNameTask.initialize();			if (sequenceNameTaskTextCanvas!=null)				sequenceNameTaskTextCanvas.setText(getModuleText(sequenceNameTask));			if (sequenceNameTaskButton!=null)				sequenceNameTaskButton.setEnabled (sequenceNameTask.hasOptions());		}		return temp;	}	/*.................................................................................................................*/	private PrimerInfoSource replacePrimerInfoSource(String arguments) {		PrimerInfoSource temp = (PrimerInfoSource)replaceEmployee(PrimerInfoSource.class,  arguments, "Supplier of information about primers and gene fragments", primerInfoTask);		if (temp !=null) {			primerInfoTask=temp;			primerInfoTask.initialize();			if (primerInfoTaskTextCanvas!=null)				primerInfoTaskTextCanvas.setText(getModuleText(primerInfoTask));		}		return temp;	}	/*.................................................................................................................*/	public Object doCommand(String commandName, String arguments, CommandChecker checker) {		if (checker.compare(this.getClass(), "Sets the module supplying sequence names", "[name of module]", commandName, "setSequenceNameSource")) {			return replaceSequenceNameSource(arguments);		}		else if (checker.compare(this.getClass(), "Sets the module supplying primer information", "[name of module]", commandName, "setPrimerInfoSource")) {			return replacePrimerInfoSource(arguments);		}		else			return  super.doCommand(commandName, arguments, checker);	}	/*.................................................................................................................*/	public  void actionPerformed(ActionEvent e) {		if (e.getActionCommand().equalsIgnoreCase("phLocations")) {			queryFileLocations();		}				else if (e.getActionCommand().equalsIgnoreCase("postOptions")) {			queryPostOptions();		}		else if (e.getActionCommand().equalsIgnoreCase("nameParserButton")) {			if (nameParserManager!=null) {				if (nameParserManager.queryOptions() && nameParserTextCanvas!=null)					nameParserTextCanvas.setText(getModuleText(nameParserManager));			}		}		else if (e.getActionCommand().equalsIgnoreCase("sequenceNameTaskButton")) {			if (sequenceNameTask!=null) {				if (sequenceNameTask.queryOptions() && sequenceNameTaskTextCanvas!=null)					sequenceNameTaskTextCanvas.setText(getModuleText(sequenceNameTask));			}		}		else if (e.getActionCommand().equalsIgnoreCase("primerInfoTaskButton")) {			if (primerInfoTask!=null) {				if (primerInfoTask.queryOptions() && primerInfoTaskTextCanvas!=null)					primerInfoTaskTextCanvas.setText(getModuleText(primerInfoTask));			}		}		else if (e.getActionCommand().equalsIgnoreCase("sequenceNameTaskReplace")) {			MesquiteCommand command = new MesquiteCommand("setSequenceNameSource", this);			command.doItMainThread(null, null, false, false);		}		else if (e.getActionCommand().equalsIgnoreCase("primerInfoTaskReplace")) {			MesquiteCommand command = new MesquiteCommand("setPrimerInfoSource", this);			command.doItMainThread(null, null, false, false);		}		else if (e.getActionCommand().equalsIgnoreCase("phBrowse")) {			phredPath = MesquiteFile.chooseDirectory("Choose directory containing phred, phrap, and phd2fasta: ");			if (!StringUtil.blank(phredPath)) {				if (!phredPath.endsWith(MesquiteFile.fileSeparator))					phredPath+=MesquiteFile.fileSeparator;				phredPathField.setText(phredPath);			}		}		/*		else if (e.getActionCommand().equalsIgnoreCase("primerBrowse")) {			MesquiteString primerListDir = new MesquiteString();			MesquiteString primerListFile = new MesquiteString();			String s = MesquiteFile.openFileDialog("Choose file containing primer list", primerListDir, primerListFile);			if (!StringUtil.blank(s)) {				primerListPath = s;				if (primerListField!=null) 					primerListField.setText(primerListPath);			}		}		else if (e.getActionCommand().equalsIgnoreCase("DNANumbersBrowse")) {			MesquiteString dnaNumberListDir = new MesquiteString();			MesquiteString dnaNumberListFile = new MesquiteString();			String s = MesquiteFile.openFileDialog("Choose file containing sample codes and names", dnaNumberListDir, dnaNumberListFile);			if (!StringUtil.blank(s)) {				sampleCodeListPath = s;				if (dnaCodesField!=null) 					dnaCodesField.setText(sampleCodeListPath);			}		}*/		else if (e.getActionCommand().equalsIgnoreCase("paramBrowse")) {			MesquiteString paramDir = new MesquiteString();			MesquiteString paramFile = new MesquiteString();			phredParamPath = MesquiteFile.openFileDialog("Choose phred parameter file: ", paramDir, paramFile);			if (!StringUtil.blank(phredParamPath)) {				paramPathField.setText(phredParamPath);			}		}	}	/*.................................................................................................................*/	public String[] modifyOutputPaths(String[] outputFilePaths){		return outputFilePaths;	}	public boolean continueShellProcess(Process proc) {		// TODO Auto-generated method stub		return true;	}	public boolean fatalErrorDetected() {		// TODO Auto-generated method stub		return false;	}	public void processOutputFile(String[] outputFilePaths, int fileNum) {		String s = MesquiteFile.getFileLastContents(outputFilePaths[0]);  // status file		logln(s);		//outputFilePaths[1] =phphLogFilePath;		//outputFilePaths[2] =phrapStdErrFilePath;	}	public void processCompletedOutputFiles(String[] outputFilePaths) {		// TODO Auto-generated method stub			}}